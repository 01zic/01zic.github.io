<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/orange.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/orange.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/orange.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"01zic.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="C++学习路线">
<meta property="og:type" content="article">
<meta property="og:title" content="公众号程序喵大人的C++学习记录">
<meta property="og:url" content="https://01zic.github.io/2022/07/09/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A8%8B%E5%BA%8F%E5%96%B5%E5%A4%A7%E4%BA%BA%E7%9A%84C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="orangeWBlog">
<meta property="og:description" content="C++学习路线">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://qiniu.orangew.cn/img/640.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/20220710171205.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80%E5%9B%BE.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/%E5%AD%90%E7%B1%BB%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%B8%83%E5%B1%80.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/%E5%AD%90%E7%B1%BB%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%B8%83%E5%B1%80.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80%E5%9B%BE.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/%E5%A4%9A%E7%BB%A7%E6%89%BF%E8%A6%86%E7%9B%96%E8%99%9A%E5%87%BD%E6%95%B0%E5%B8%83%E5%B1%80.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/%E4%B8%8D%E5%90%8C%E7%BB%A7%E6%89%BF%E9%A1%BA%E5%BA%8F.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/%E8%99%9A%E7%BB%A7%E6%89%BF.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/%E8%99%9A%E7%BB%A7%E6%89%BF%E6%9C%AA%E8%A6%86%E7%9B%96.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80%E5%9B%BE.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%99%9A%E7%BB%A7%E6%89%BF.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/%E8%99%9A%E5%87%BD%E6%95%B0%E7%BB%93%E6%9E%84.png">
<meta property="article:published_time" content="2022-07-09T00:48:26.000Z">
<meta property="article:modified_time" content="2022-07-10T14:31:17.089Z">
<meta property="article:author" content="OrangeW">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://qiniu.orangew.cn/img/640.png">

<link rel="canonical" href="https://01zic.github.io/2022/07/09/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A8%8B%E5%BA%8F%E5%96%B5%E5%A4%A7%E4%BA%BA%E7%9A%84C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>公众号程序喵大人的C++学习记录 | orangeWBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">orangeWBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://01zic.github.io/2022/07/09/%E5%85%AC%E4%BC%97%E5%8F%B7%E7%A8%8B%E5%BA%8F%E5%96%B5%E5%A4%A7%E4%BA%BA%E7%9A%84C-%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/orange.png">
      <meta itemprop="name" content="OrangeW">
      <meta itemprop="description" content="demo_study record">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="orangeWBlog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          公众号程序喵大人的C++学习记录
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-09 08:48:26" itemprop="dateCreated datePublished" datetime="2022-07-09T08:48:26+08:00">2022-07-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-10 22:31:17" itemprop="dateModified" datetime="2022-07-10T22:31:17+08:00">2022-07-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>107k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>3:14</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="C-学习路线"><a href="#C-学习路线" class="headerlink" title="C++学习路线"></a>C++学习路线</h2><p><img src="http://qiniu.orangew.cn/img/640.png" alt="640"></p>
<ul>
<li>C语言入门基础知识</li>
<li>C++基础</li>
<li>C++进阶</li>
<li>C++新特性</li>
<li>操作系统</li>
<li>编译链接</li>
<li>C++项目</li>
<li>推荐工具</li>
<li>编码规范</li>
<li>推荐网站</li>
<li>推荐书籍</li>
</ul>
<h2 id="C语言入门基础知识"><a href="#C语言入门基础知识" class="headerlink" title="C语言入门基础知识"></a>C语言入门基础知识</h2><ul>
<li>数据类型</li>
<li>流程控制</li>
<li>函数</li>
<li>指针</li>
<li>内存布局</li>
<li>结构体、共用体</li>
<li>文件操作</li>
<li>回调函数</li>
</ul>
<h2 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h2><ul>
<li>constexpr</li>
<li>namespace</li>
<li>引用与指针的区别</li>
<li>new/delete、new[]/delete[]</li>
<li>C/C++混合编程</li>
<li>类的封装</li>
<li>class与struct的区别</li>
<li>面向对象编程思想</li>
<li>构造和析构</li>
<li>拷贝构造、移动构造</li>
<li>赋值构造、移动赋值</li>
<li>四种强制类型转换</li>
<li>静态成员</li>
<li>对象管理</li>
<li>函数重载</li>
<li>友元函数与友元类</li>
<li>操作符重载</li>
<li>继承与多继承</li>
<li>多态</li>
<li>虚函数与抽象类</li>
<li>函数模板与类模板</li>
<li>输入输出类</li>
<li>异常处理</li>
</ul>
<h2 id="C-进阶"><a href="#C-进阶" class="headerlink" title="C++进阶"></a>C++进阶</h2><ul>
<li><p>new/delete、new[]/delete[]为什么要配对使用</p>
</li>
<li><p>RAII特性</p>
</li>
<li><p>智能指针</p>
</li>
<li><p>内存泄漏的调试</p>
</li>
<li><p>STL</p>
<p>♦️ vector</p>
</li>
<li><p>resize</p>
</li>
<li><p>reserve</p>
</li>
<li><p>capacity</p>
</li>
<li><p>clear</p>
</li>
<li><p>swap</p>
</li>
<li><p>at</p>
<pre><code>  ♦️ array
</code></pre>
</li>
</ul>
<p>​        ♦️ map</p>
<pre><code>    ♦️ unordered_map
   
    ♦️ list
   
     ♦️ tuple
</code></pre>
<h2 id="C-新特性-C-11"><a href="#C-新特性-C-11" class="headerlink" title="C++新特性(C++11)"></a>C++新特性(C++11)</h2><ul>
<li>auto/decltype</li>
<li>列表初始化</li>
<li>左值、右值、左值引用、右值引用</li>
<li>移动语义、完美转发</li>
<li>std::function、std::bind</li>
<li>lambda表达式</li>
<li>std::thread</li>
<li>std::lock_guard、std::unique_lock</li>
<li>std::shared_ptr、std::unique_ptr</li>
<li>std::mutex</li>
<li>原子操作</li>
<li>enum class</li>
<li>条件变量</li>
<li>nullptr</li>
<li>chrono</li>
</ul>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul>
<li>操作系统非常重要，要学好C++就一定要打好操作系统的基础，但操作系统我们也没必要全都钻到细节里去，重点攻克下面几个知识点即可：</li>
<li>进程与线程的区别</li>
<li>进程管理与调度</li>
<li>内存管理</li>
<li>并发与同步</li>
<li>文件I/O</li>
</ul>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a><strong>工具</strong></h2><ul>
<li>调试工具：gdb、lldb</li>
<li>构建工具：Cmake、bazel</li>
<li>静态代码检测工具：cppcheck、Clang-Tidy、SonarQube</li>
<li>内存检测工具：valgrind、ASan</li>
<li>profiling工具：gperftools、perf</li>
</ul>
<h2 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h2><ul>
<li>使用一门语言一定要了解一下它常用的编码规范，有了编码规范代码写的才能稍微漂亮一点，目前多数C++开发团队都会参考Google编码规范来写代码。</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83.png" alt="代码规范"></p>
<h2 id="编译链接知识点"><a href="#编译链接知识点" class="headerlink" title="编译链接知识点"></a><strong>编译链接知识点</strong></h2><ul>
<li>预处理、编译、汇编、链接</li>
<li>静态链接</li>
<li>动态链接</li>
<li>Debug与Release的区别</li>
</ul>
<h2 id="C-基础知识重点"><a href="#C-基础知识重点" class="headerlink" title="C++基础知识重点"></a>C++基础知识重点</h2><ul>
<li>这个地方只有C++模板有点意思</li>
<li>函数模板</li>
<li>模板函数定义的一般形式如下所示：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class type&gt; ret-type func-name(parameter list) 
&#123;
 &#x2F;&#x2F; 函数的主体 
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>在这里，type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。</p>
<p>下面是函数模板的实例，返回两个数中的最大值：</p>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
#include &lt;iostream&gt;
#include &lt;string&gt;
 
using namespace std;
 
template &lt;typename T&gt;
inline T const&amp; Max (T const&amp; a, T const&amp; b) 
&#123; 
    return a &lt; b ? b:a; 
&#125; 
int main ()
&#123;
 
    int i &#x3D; 39;
    int j &#x3D; 20;
    cout &lt;&lt; &quot;Max(i, j): &quot; &lt;&lt; Max(i, j) &lt;&lt; endl; 
 
    double f1 &#x3D; 13.5; 
    double f2 &#x3D; 20.7; 
    cout &lt;&lt; &quot;Max(f1, f2): &quot; &lt;&lt; Max(f1, f2) &lt;&lt; endl; 
 
    string s1 &#x3D; &quot;Hello&quot;; 
    string s2 &#x3D; &quot;World&quot;; 
    cout &lt;&lt; &quot;Max(s1, s2): &quot; &lt;&lt; Max(s1, s2) &lt;&lt; endl; 
 
   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>正如我们定义函数模板一样，我们也可以定义类模板。泛型类声明的一般形式如下所示：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class type&gt; class class-name &#123;
.
.
.
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>在这里，<strong>type 是占位符类型名称，</strong>可以在类被实例化的时候进行指定。您可以使用一个逗号分隔的列表来定义多个泛型数据类型。</li>
<li>下面的实例定义了类 Stack&lt;&gt;，并实现了泛型方法来对元素进行入栈出栈操作：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cstdlib&gt;
#include &lt;string&gt;
#include &lt;stdexcept&gt;
 
using namespace std;
 
template &lt;class T&gt;
class Stack &#123; 
  private: 
    vector&lt;T&gt; elems;     &#x2F;&#x2F; 元素 
 
  public: 
    void push(T const&amp;);  &#x2F;&#x2F; 入栈
    void pop();               &#x2F;&#x2F; 出栈
    T top() const;            &#x2F;&#x2F; 返回栈顶元素
    bool empty() const&#123;       &#x2F;&#x2F; 如果为空则返回真。
        return elems.empty(); 
    &#125; 
&#125;; 
 
template &lt;class T&gt;
void Stack&lt;T&gt;::push (T const&amp; elem) 
&#123; 
    &#x2F;&#x2F; 追加传入元素的副本
    elems.push_back(elem);    
&#125; 
 
template &lt;class T&gt;
void Stack&lt;T&gt;::pop () 
&#123; 
    if (elems.empty()) &#123; 
        throw out_of_range(&quot;Stack&lt;&gt;::pop(): empty stack&quot;); 
    &#125;
    &#x2F;&#x2F; 删除最后一个元素
    elems.pop_back();         
&#125; 
 
template &lt;class T&gt;
T Stack&lt;T&gt;::top () const 
&#123; 
    if (elems.empty()) &#123; 
        throw out_of_range(&quot;Stack&lt;&gt;::top(): empty stack&quot;); 
    &#125;
    &#x2F;&#x2F; 返回最后一个元素的副本 
    return elems.back();      
&#125; 
 
int main() 
&#123; 
    try &#123; 
        Stack&lt;int&gt;         intStack;  &#x2F;&#x2F; int 类型的栈 
        Stack&lt;string&gt; stringStack;    &#x2F;&#x2F; string 类型的栈 
 
        &#x2F;&#x2F; 操作 int 类型的栈 
        intStack.push(7); 
        cout &lt;&lt; intStack.top() &lt;&lt;endl; 
 
        &#x2F;&#x2F; 操作 string 类型的栈 
        stringStack.push(&quot;hello&quot;); 
        cout &lt;&lt; stringStack.top() &lt;&lt; std::endl; 
        stringStack.pop(); 
        stringStack.pop(); 
    &#125; 
    catch (exception const&amp; ex) &#123; 
        cerr &lt;&lt; &quot;Exception: &quot; &lt;&lt; ex.what() &lt;&lt;endl; 
        return -1;
    &#125; 
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="new-和delete-配对使用"><a href="#new-和delete-配对使用" class="headerlink" title="new[]和delete[]配对使用"></a>new[]和delete[]配对使用</h2><blockquote>
<p>当类型为int, float等内置类型时，new、delete、new[]、delete[]不需要配对使用；</p>
<p>当是自定义类型时，new、delete和new[]、delete[]才需要配对使用。</p>
<p>当然，我们平时编程过程中，为了保证代码的可读性，以及养成良好的编程习惯，最好确保所有情况都配对使用。</p>
</blockquote>
<h2 id="指针和函数的使用场景"><a href="#指针和函数的使用场景" class="headerlink" title="指针和函数的使用场景"></a>指针和函数的使用场景</h2><blockquote>
<p>指针其实就是一个存放内存地址的整数，这个整数表示的是被指向的变量的地址。</p>
<p>引用其实就是变量的别名，就是给变量重新起了一个名字，注意引用既然是个别名，<strong>那它一定要有本体</strong>，一个人叫王二小，我们也可以给它起个别名叫二蛋，我们提到二蛋和王二小其实都是同一个人。</p>
</blockquote>
<ul>
<li>区别</li>
</ul>
<blockquote>
<ul>
<li>指针在声明时可以暂时不初始化，即pointer = nullptr，指针在生命周期内随时都可能是空指针，所以在每次使用时都要做检查，防止出现空指针异常问题，而引用却不需要做检查，因为引用永远都不会为空，它一定有本体，一定得代表某个对象，引用在创建的同时必须被初始化。</li>
</ul>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
void FuncPtr(int *ptr) &#123;
  if (ptr !&#x3D; nullptr) &#123;
    cout &lt;&lt; *ptr;
  &#125;
&#125;

void FuncReference(int &amp;ref) &#123;
    cout &lt;&lt; ref;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>指针存放的是地址，指针可以被重新赋值，可以在初始化时指向一个对象，在其它时刻也可以指向另一个对象，而引用<strong>非常专一</strong>，它会从一而终，它总是指向它最初代表的那个对象。</p>
</li>
<li><p>指针和引用的使用场景</p>
</li>
<li><p>引用的主要功能就是作为函数的参数和返回值，看一段代码：</p>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct A &#123;
    int a;
&#125;;
void func(const A &amp;a) &#123;
    cout &lt;&lt; a.a;
&#125;

vector&lt;int&gt; vec(10);
vec[3] &#x3D; 3;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>为什么通过vec[3] =3可以改变vector容器的值，因为[]操作符返回的就是引用，相当于为内部的变量起了一个别名，这里还可以让[]操作符返回一个指针，即*vec[3]=3，这是不是有点丑，而且不符合语法需求。</li>
<li>其实我们平时编程过程中可能也注意到，实际上引用可以做的事情指针都可以做，但为什么还要引用这个东西？</li>
</ul>
<blockquote>
<p>用恰当的工具做恰如其分的工作，指针可以毫无约束的操作内存中的任何东西，功能十分强大，但是也很危险，所以可以在恰当的时机使用引用，当你需要指向某个东西，而且一定专一，绝不会让其指向其它东西，例如有些函数参数为了避免拷贝可以使用引用，或者实现一个操作符而其语法需求无法由指针达成，例如vec[3]=3，可以使用引用，其它任何时候，都要使用指针。</p>
</blockquote>
<ul>
<li>引用在c++11后其实有很多知识点，具体可以看我之前的文章：</li>
</ul>
<h2 id="左值引用、右值引用、移动语义、完美转发"><a href="#左值引用、右值引用、移动语义、完美转发" class="headerlink" title="左值引用、右值引用、移动语义、完美转发"></a>左值引用、右值引用、移动语义、完美转发</h2><ul>
<li>C++11新增了右值引用，谈右值引用我们也可以扩展一些相关概念：</li>
<li>左值</li>
<li>右值</li>
<li>纯右值</li>
<li>将亡值</li>
<li>左值引用</li>
<li>右值引用</li>
<li>移动语义</li>
<li>完美转发</li>
<li>返回值优化</li>
</ul>
<h3 id="左值、右值"><a href="#左值、右值" class="headerlink" title="左值、右值"></a>左值、右值</h3><ul>
<li>左值：可以放到等号左边的东西叫左值。</li>
<li>右值：不可以放到等号左边的东西就叫右值。</li>
<li>左值：可以取地址并且有名字的东西就是左值。</li>
<li>右值：不能取地址的没有名字的东西就是右值。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a &#x3D; b + c; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>a是左值，有变量名，可以取地址，也可以放到等号左边, 表达式b+c的返回值是右值，没有名字且不能取地址，&amp;(b+c)不能通过编译，而且也不能放到等号左边。</li>
<li><strong>左值一般有：</strong></li>
<li>函数名和变量名</li>
<li>返回左值引用的函数调用</li>
<li>前置自增自减表达式++i、–i</li>
<li>由赋值表达式或赋值运算符连接的表达式(a=b, a += b等)</li>
<li>解引用表达式*p</li>
<li>字符串字面值”abcd”</li>
</ul>
<h3 id="纯右值、将亡值"><a href="#纯右值、将亡值" class="headerlink" title="纯右值、将亡值"></a>纯右值、将亡值</h3><ul>
<li>纯右值和将亡值都属于右值。</li>
<li><strong>纯右值</strong></li>
<li>运算表达式产生的临时变量、不和对象关联的原始字面量、非引用返回的临时变量、lambda表达式等都是纯右值。</li>
<li><strong>举例：</strong></li>
<li>除字符串字面值外的字面值</li>
<li>返回非引用类型的函数调用</li>
<li>后置自增自减表达式i++、i–</li>
<li>算术表达式(a+b, a*b, a&amp;&amp;b, a==b等)</li>
<li>取地址表达式等(&amp;a)</li>
<li><strong>将亡值</strong></li>
<li>将亡值是指C++11新增的和右值引用相关的表达式，通常指将要被移动的对象、T&amp;&amp;函数的返回值、std::move函数的返回值、转换为T&amp;&amp;类型转换函数的返回值，将亡值可以理解为即将要销毁的值，通过“盗取”其它变量内存空间方式获取的值，在确保其它变量不再被使用或者即将被销毁时，可以避免内存空间的释放和分配，延长变量值的生命周期，常用来完成移动构造或者移动赋值的特殊任务。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A &#123;
    xxx;
&#125;;
A a;
auto c &#x3D; std::move(a); &#x2F;&#x2F; c是将亡值
auto d &#x3D; static_cast&lt;A&amp;&amp;&gt;(a); &#x2F;&#x2F; d是将亡值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>左值引用、右值引用</strong></li>
<li>根据名字大概就可以猜到意思，左值引用就是对左值进行引用的类型，右值引用就是对右值进行引用的类型，他们都是引用，都是对象的一个别名，并不拥有所绑定对象的堆存，所以都必须立即初始化。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">type &amp;name &#x3D; exp; &#x2F;&#x2F; 左值引用
type &amp;&amp;name &#x3D; exp; &#x2F;&#x2F; 右值引用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li><strong>左值引用</strong></li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a &#x3D; 5;
int &amp;b &#x3D; a; &#x2F;&#x2F; b是左值引用
b &#x3D; 4;
int &amp;c &#x3D; 10; &#x2F;&#x2F; error，10无法取地址，无法进行引用
const int &amp;d &#x3D; 10; &#x2F;&#x2F; ok，因为是常引用，引用常量数字，这个常量数字会存储在内存中，可以取地址<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>可以得出结论：对于左值引用，等号右边的值必须可以取地址，如果不能取地址，则会编译失败，或者可以使用const引用形式，但这样就只能通过引用来读取输出，不能修改数组，因为是常量引用。</li>
<li><strong>右值引用</strong></li>
<li>如果使用右值引用，那表达式等号右边的值需要时右值，可以使用std::move函数强制把左值转换为右值。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a &#x3D; 4;
int &amp;&amp;b &#x3D; a; &#x2F;&#x2F; error, a是左值
int &amp;&amp;c &#x3D; std::move(a); &#x2F;&#x2F; ok<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>移动语义</strong></li>
<li><strong>深拷贝、浅拷贝</strong></li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A &#123;
public:
    A(int size) : size_(size) &#123;
        data_ &#x3D; new int[size];
    &#125;
    A()&#123;&#125;
    A(const A&amp; a) &#123;
        size_ &#x3D; a.size_;
        data_ &#x3D; a.data_;
        cout &lt;&lt; &quot;copy &quot; &lt;&lt; endl;
    &#125;
    ~A() &#123;
        delete[] data_;
    &#125;
    int *data_;
    int size_;
&#125;;
int main() &#123;
    A a(10);
    A b &#x3D; a;
    cout &lt;&lt; &quot;b &quot; &lt;&lt; b.data_ &lt;&lt; endl;
    cout &lt;&lt; &quot;a &quot; &lt;&lt; a.data_ &lt;&lt; endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>上面代码中，两个输出的是相同的地址，a和b的data _ 指针指向了同一块内存，这就是浅拷贝，只是数据的简单赋值，那再析构时data _ 内存会被释放两次，导致程序出问题，这里正常会出现double free导致程序崩溃的，但是不知道为什么我自己测试程序却没有崩溃，能力有限，没搞明白，无论怎样，这样的程序肯定是有隐患的，如何消除这种隐患呢，可以使用如下深拷贝：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
class A &#123;
public:
    A(int size) : size_(size) &#123;
        data_ &#x3D; new int[size];
    &#125;
    A()&#123;&#125;
    A(const A&amp; a) &#123;
        size_ &#x3D; a.size_;
        data_ &#x3D; new int[size_];
        cout &lt;&lt; &quot;copy &quot; &lt;&lt; endl;
    &#125;
    ~A() &#123;
        delete[] data_;
    &#125;
    int *data_;
    int size_;
&#125;;
int main() &#123;
    A a(10);
    A b &#x3D; a;
    cout &lt;&lt; &quot;b &quot; &lt;&lt; b.data_ &lt;&lt; endl;
    cout &lt;&lt; &quot;a &quot; &lt;&lt; a.data_ &lt;&lt; endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>深拷贝就是再拷贝对象时，如果被拷贝对象内部还有指针引用指向其它资源，自己需要重新开辟一块新内存存储资源，而不是简单的赋值。</li>
<li>聊完了深拷贝浅拷贝，可以聊聊<strong>移动语义</strong>啦：</li>
<li>移动语义，在程序喵看来可以理解为转移所有权，之前的拷贝是对于别人的资源，自己重新分配一块内存存储复制过来的资源，而对于移动语义，类似于转让或者资源窃取的意思，对于那块资源，转为自己所拥有，别人不再拥有也不会再使用，通过C++11新增的移动语义可以省去很多拷贝负担，怎么利用移动语义呢，是通过移动构造函数。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
class A &#123;
public:
    A(int size) : size_(size) &#123;
        data_ &#x3D; new int[size];
    &#125;
    A()&#123;&#125;
    A(const A&amp; a) &#123;
        size_ &#x3D; a.size_;
        data_ &#x3D; new int[size_];
        cout &lt;&lt; &quot;copy &quot; &lt;&lt; endl;
    &#125;
    A(A&amp;&amp; a) &#123;
        this-&gt;data_ &#x3D; a.data_;
        a.data_ &#x3D; nullptr;
        cout &lt;&lt; &quot;move &quot; &lt;&lt; endl;
    &#125;
    ~A() &#123;
        if (data_ !&#x3D; nullptr) &#123;
         delete[] data_;
        &#125;
    &#125;
    int *data_;
    int size_;
&#125;;
int main() &#123;
    A a(10);
    A b &#x3D; a;
    A c &#x3D; std::move(a); &#x2F;&#x2F; 调用移动构造函数
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>如果不使用std::move()，会有很大的拷贝代价，使用移动语义可以避免很多无用的拷贝，提供程序性能，C++所有的STL都实现了移动语义，方便我们使用。例如：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::vector&lt;string&gt; vecs;
...
std::vector&lt;string&gt; vecm &#x3D; std::move(vecs); &#x2F;&#x2F; 免去很多拷贝<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>注意：</strong>移动语义仅针对于那些实现了移动构造函数的类的对象，对于那种基本类型int、float等没有任何优化作用，还是会拷贝，因为它们实现没有对应的移动构造函数。</li>
<li><strong>完美转发</strong></li>
<li>完美转发指可以写一个接受任意实参的函数模板，并转发到其它函数，目标函数会收到与转发函数完全相同的实参，转发函数实参是左值那目标函数实参也是左值，转发函数实参是右值那目标函数实参也是右值。那如何实现完美转发呢，答案是使用std::forward()。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
void PrintV(int &amp;t) &#123;
    cout &lt;&lt; &quot;lvalue&quot; &lt;&lt; endl;
&#125;

void PrintV(int &amp;&amp;t) &#123;
    cout &lt;&lt; &quot;rvalue&quot; &lt;&lt; endl;
&#125;

template&lt;typename T&gt;
void Test(T &amp;&amp;t) &#123;
    PrintV(t);
    PrintV(std::forward&lt;T&gt;(t));
    PrintV(std::move(t));
&#125;

int main() &#123;
    Test(1); &#x2F;&#x2F; lvalue rvalue rvalue
    int a &#x3D; 1;
    Test(a); &#x2F;&#x2F; lvalue lvalue rvalue
    Test(std::forward&lt;int&gt;(a)); &#x2F;&#x2F; lvalue rvalue rvalue
    Test(std::forward&lt;int&amp;&gt;(a)); &#x2F;&#x2F; lvalue lvalue rvalue
    Test(std::forward&lt;int&amp;&amp;&gt;(a)); &#x2F;&#x2F; lvalue rvalue rvalue
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>Test(1)：1是右值，模板中T &amp;&amp;t这种为万能引用，右值1传到Test函数中变成了右值引用，但是调用PrintV()时候，t变成了左值，因为它变成了一个拥有名字的变量，所以打印lvalue，而PrintV(std::forward<T>(t))时候，会进行完美转发，按照原来的类型转发，所以打印rvalue，PrintV(std::move(t))毫无疑问会打印rvalue。</p>
</li>
<li><p>Test(a)：a是左值，模板中T &amp;&amp;这种为万能引用，左值a传到Test函数中变成了左值引用，所以有代码中打印。</p>
</li>
<li><p>Test(std::forward<T>(a))：转发为左值还是右值，依赖于T，T是左值那就转发为左值，T是右值那就转发为右值。</p>
</li>
<li><p><strong>返回值优化</strong></p>
</li>
<li><p>返回值优化(RVO)是一种C++编译优化技术，当函数需要返回一个对象实例时候，就会创建一个临时对象并通过复制构造函数将目标对象复制到临时对象，这里有复制构造函数和析构函数会被多余的调用到，有代价，而通过返回值优化，C++标准允许省略调用这些复制构造函数。</p>
</li>
<li><p>那什么时候编译器会进行返回值优化呢?</p>
<ul>
<li>return的值类型与函数的返回值类型相同</li>
<li>return的是一个局部对象</li>
</ul>
</li>
<li><p>看几个例子:</p>
</li>
<li><p><strong>示例1：</strong></p>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::vector&lt;int&gt; return_vector(void) &#123;
    std::vector&lt;int&gt; tmp &#123;1,2,3,4,5&#125;;
    return tmp;
&#125;
std::vector&lt;int&gt; &amp;&amp;rval_ref &#x3D; return_vector();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>不会触发RVO，拷贝构造了一个临时的对象，临时对象的生命周期和rval_ref绑定，等价于下面这段代码：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const std::vector&lt;int&gt;&amp; rval_ref &#x3D; return_vector();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><strong>示例2:</strong></li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::vector&lt;int&gt;&amp;&amp; return_vector(void) &#123;
    std::vector&lt;int&gt; tmp &#123;1,2,3,4,5&#125;;
    return std::move(tmp);
&#125;
std::vector&lt;int&gt; &amp;&amp;rval_ref &#x3D; return_vector();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>和示例1类似，std::move一个临时对象是没有必要的，也会忽略掉返回值优化。</li>
<li><strong>最好的代码：</strong></li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">std::vector&lt;int&gt; return_vector(void) &#123;
    std::vector&lt;int&gt; tmp &#123;1,2,3,4,5&#125;;
    return tmp;
&#125;
std::vector&lt;int&gt; rval_ref &#x3D; return_vector();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>这段代码会触发RVO，不拷贝也不移动，不生成临时对象。</li>
</ul>
<h2 id="C-对象布局"><a href="#C-对象布局" class="headerlink" title="C++对象布局"></a>C++对象布局</h2><p>我们都知道C++多态是通过虚函数表来实现的，那具体是什么样的大家清楚吗？开篇依旧提出来几个问题：</p>
<ul>
<li>普通类对象是什么布局？</li>
<li>带虚函数的类对象是什么布局？</li>
<li>单继承下不含有覆盖函数的类对象是什么布局？</li>
<li>单继承下含有覆盖函数的类对象是什么布局？</li>
<li>多继承下不含有覆盖函数的类对象是什么布局？</li>
<li>多继承下含有覆盖函数的类对象的是什么布局？</li>
<li>多继承中不同的继承顺序产生的类对象布局相同吗？</li>
<li>虚继承的类对象是什么布局？</li>
<li>菱形继承下类对象是什么布局？</li>
<li>为什么要引入虚继承？</li>
<li>为什么虚函数表中有两个析构函数？</li>
<li>为什么构造函数不能是虚函数？</li>
<li>为什么基类析构函数需要是虚函数？</li>
</ul>
<p>要回答上述问题我们首先需要了解什么是多态。</p>
<h3 id="什么是多态？"><a href="#什么是多态？" class="headerlink" title="什么是多态？"></a>什么是多态？</h3><ul>
<li>多态可以分为编译时多态和运行时多态。</li>
<li>编译时多态：基于模板和函数重载方式，在编译时就已经确定对象的行为，也称为静态绑定。</li>
<li>运行时多态：面向对象的一大特色，通过继承方式使得程序在运行时才会确定相应调用的方法，也称为动态绑定，它的实现主要是依赖于传说中的虚函数表。</li>
</ul>
<h3 id="如何查看对象的布局"><a href="#如何查看对象的布局" class="headerlink" title="如何查看对象的布局"></a>如何查看对象的布局</h3><ul>
<li>在gcc中可以使用如下命令查看对象布局：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">g++ -fdump-class-hierarchy model.cc后查看生成的文件<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>在clang中可以使用如下命令：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">clang -Xclang -fdump-record-layouts -stdlib&#x3D;libc++ -c model.cc
&#x2F;&#x2F; 查看对象布局
clang -Xclang -fdump-vtable-layouts -stdlib&#x3D;libc++ -c model.cc
&#x2F;&#x2F; 查看虚函数表布局<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="普通类对象的布局"><a href="#普通类对象的布局" class="headerlink" title="普通类对象的布局"></a><strong>普通类对象的布局</strong></h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Base &#123;
   Base() &#x3D; default;
   ~Base() &#x3D; default;
   
   void Func() &#123;&#125;

   int a;
   int b;
&#125;;

int main() &#123;
   Base a;
   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>输出如下</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">*** Dumping AST Record Layout
        0 | struct Base
        0 |   int a
        4 |   int b
          | [sizeof&#x3D;8, dsize&#x3D;8, align&#x3D;4,
          |  nvsize&#x3D;8, nvalign&#x3D;4]

*** Dumping IRgen Record Layout<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="http://qiniu.orangew.cn/img/20220710171205.png" alt="20220710171205"></p>
<ul>
<li>从结果中可以看见，这个普通结构体Base的大小为8字节，a占4个字节，b占4个字节。</li>
</ul>
<h3 id="带虚函数的类的对象布局"><a href="#带虚函数的类的对象布局" class="headerlink" title="带虚函数的类的对象布局"></a>带虚函数的类的对象布局</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
struct Base &#123;
   Base() &#x3D; default;
   virtual ~Base() &#x3D; default;
   
   void FuncA() &#123;&#125;

   virtual void FuncB() &#123;
       printf(&quot;FuncB\n&quot;);
  &#125;

   int a;
   int b;
&#125;;

int main() &#123;
   Base a;
   return 0;
&#125;

&#x2F;&#x2F; 这里可以查看对象的布局和相应虚函数表的布局
clang -Xclang -fdump-record-layouts -stdlib&#x3D;libc++ -c model.cc
clang -Xclang -fdump-vtable-layouts -stdlib&#x3D;libc++ -c model.cc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>对象布局如下</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">*** Dumping AST Record Layout
        0 | struct Base
        0 |   (Base vtable pointer)
        8 |   int a
       12 |   int b
          | [sizeof&#x3D;16, dsize&#x3D;16, align&#x3D;8,
          |  nvsize&#x3D;16, nvalign&#x3D;8]

*** Dumping IRgen Record Layout<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>这个含有虚函数的结构体大小为16，在对象的头部，前8个字节是虚函数表的指针，指向虚函数的相应函数指针地址，a占4个字节，b占4个字节，总大小为16。</li>
<li>虚函数表布局：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Vtable for &#39;Base&#39; (5 entries).
  0 | offset_to_top (0)
  1 | Base RTTI
      -- (Base, 0) vtable address --
  2 | Base::~Base() [complete]
  3 | Base::~Base() [deleting]
  4 | void Base::FuncB()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>对象布局图</li>
<li><img src="http://qiniu.orangew.cn/img/%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80%E5%9B%BE.jpg" alt="对象布局图"></li>
<li>我们来探秘下传说中的虚函数表：</li>
<li>**offset_to_top(0)**：表示当前这个虚函数表地址距离对象顶部地址的偏移量，因为对象的头部就是虚函数表的指针，所以偏移量为0。</li>
<li><strong>RTTI指针</strong>：指向存储运行时类型信息(type_info)的地址，用于运行时类型识别，用于typeid和dynamic_cast。</li>
<li>RTTI下面就是虚函数表指针真正指向的地址啦，存储了类里面所有的虚函数，至于这里为什么会有两个析构函数，大家可以先关注对象的布局，最下面会介绍。</li>
</ul>
<h3 id="单继承下不含有覆盖函数的类对象的布局"><a href="#单继承下不含有覆盖函数的类对象的布局" class="headerlink" title="单继承下不含有覆盖函数的类对象的布局"></a>单继承下不含有覆盖函数的类对象的布局</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
struct Base &#123;
   Base() &#x3D; default;
   virtual ~Base() &#x3D; default;
   
   void FuncA() &#123;&#125;

   virtual void FuncB() &#123;
       printf(&quot;Base FuncB\n&quot;);
  &#125;

   int a;
   int b;
&#125;;

struct Derive : public Base&#123;
&#125;;

int main() &#123;
   Base a;
   Derive d;
   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>子类对象布局</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
*** Dumping AST Record Layout
        0 | struct Derive
        0 |   struct Base (primary base)
        0 |     (Base vtable pointer)
        8 |     int a
       12 |     int b
          | [sizeof&#x3D;16, dsize&#x3D;16, align&#x3D;8,
          |  nvsize&#x3D;16, nvalign&#x3D;8]

*** Dumping IRgen Record Layout<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>和上面相同，这个含有虚函数的结构体大小为16，在对象的头部，前8个字节是虚函数表的指针，指向虚函数的相应函数指针地址，a占4个字节，b占4个字节，总大小为16。</li>
<li>子类虚函数表布局：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Vtable for &#39;Derive&#39; (5 entries).
  0 | offset_to_top (0)
  1 | Derive RTTI
      -- (Base, 0) vtable address --
      -- (Derive, 0) vtable address --
  2 | Derive::~Derive() [complete]
  3 | Derive::~Derive() [deleting]
  4 | void Base::FuncB()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>图</li>
<li><img src="http://qiniu.orangew.cn/img/%E5%AD%90%E7%B1%BB%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%B8%83%E5%B1%80.jpg" alt="子类虚函数表布局"></li>
<li>这个和上面也是相同的，注意下虚函数表这里的FuncB函数，还是Base类中的FuncB，因为在子类中没有重写这个函数，那么如果子类重写这个函数后对象布局是什么样的，请继续往下看哈。</li>
</ul>
<h3 id="单继承下含有覆盖函数的类对象的布局"><a href="#单继承下含有覆盖函数的类对象的布局" class="headerlink" title="单继承下含有覆盖函数的类对象的布局"></a>单继承下含有覆盖函数的类对象的布局</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
struct Base &#123;
   Base() &#x3D; default;
   virtual ~Base() &#x3D; default;
   
   void FuncA() &#123;&#125;

   virtual void FuncB() &#123;
       printf(&quot;Base FuncB\n&quot;);
  &#125;

   int a;
   int b;
&#125;;

struct Derive : public Base&#123;
   void FuncB() override &#123;
       printf(&quot;Derive FuncB \n&quot;);
  &#125;
&#125;;

int main() &#123;
   Base a;
   Derive d;
   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>子类对象布局</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
*** Dumping AST Record Layout
        0 | struct Derive
        0 |   struct Base (primary base)
        0 |     (Base vtable pointer)
        8 |     int a
       12 |     int b
          | [sizeof&#x3D;16, dsize&#x3D;16, align&#x3D;8,
          |  nvsize&#x3D;16, nvalign&#x3D;8]

*** Dumping IRgen Record Layout<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>依旧和上面相同，这个含有虚函数的结构体大小为16，在对象的头部，前8个字节是虚函数表的指针，指向虚函数的相应函数指针地址，a占4个字节，b占4个字节，总大小为16。</li>
<li>子类虚函数表布局：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
Vtable for &#39;Derive&#39; (5 entries).
  0 | offset_to_top (0)
  1 | Derive RTTI
      -- (Base, 0) vtable address --
      -- (Derive, 0) vtable address --
  2 | Derive::~Derive() [complete]
  3 | Derive::~Derive() [deleting]
  4 | void Derive::FuncB()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><img src="http://qiniu.orangew.cn/img/%E5%AD%90%E7%B1%BB%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%B8%83%E5%B1%80.jpg" alt="子类虚函数表布局"></li>
<li>注意这里虚函数表中的FuncB函数已经是Derive中的FuncB啦，因为在子类中重写了父类的这个函数。</li>
<li>再注意这里的RTTI中有了两项，表示Base和Derive的虚表地址是相同的，Base类里的虚函数和Derive类里的虚函数都在这个链条下，这里可以继续关注下面多继承的情况，看看有何不同。</li>
</ul>
<h3 id="多继承下不含有覆盖函数的类对象的布局"><a href="#多继承下不含有覆盖函数的类对象的布局" class="headerlink" title="多继承下不含有覆盖函数的类对象的布局"></a>多继承下不含有覆盖函数的类对象的布局</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct BaseA &#123;
   BaseA() &#x3D; default;
   virtual ~BaseA() &#x3D; default;
   
   void FuncA() &#123;&#125;

   virtual void FuncB() &#123;
       printf(&quot;BaseA FuncB\n&quot;);
  &#125;

   int a;
   int b;
&#125;;

struct BaseB &#123;
   BaseB() &#x3D; default;
   virtual ~BaseB() &#x3D; default;
   
   void FuncA() &#123;&#125;

   virtual void FuncC() &#123;
       printf(&quot;BaseB FuncC\n&quot;);
  &#125;

   int a;
   int b;
&#125;;

struct Derive : public BaseA, public BaseB&#123;
&#125;;

int main() &#123;
   BaseA a;
   Derive d;
   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>类对象布局</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
*** Dumping AST Record Layout
        0 | struct Derive
        0 |   struct BaseA (primary base)
        0 |     (BaseA vtable pointer)
        8 |     int a
       12 |     int b
       16 |   struct BaseB (base)
       16 |     (BaseB vtable pointer)
       24 |     int a
      28 |     int b
         | [sizeof&#x3D;32, dsize&#x3D;32, align&#x3D;8,
         |  nvsize&#x3D;32, nvalign&#x3D;8]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>Derive大小为32，注意这里有了两个虚表指针，因为Derive是多继承，一般情况下继承了几个带有虚函数的类，对象布局中就有几个虚表指针，并且子类也会继承基类的数据，<strong>一般来说，不考虑内存对齐的话，子类（继承父类）的大小=子类（不继承父类）的大小+所有父类的大小</strong>。</li>
<li>虚函数表布局</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Vtable for &#39;Derive&#39; (10 entries).
  0 | offset_to_top (0)
  1 | Derive RTTI
      -- (BaseA, 0) vtable address --
      -- (Derive, 0) vtable address --
  2 | Derive::~Derive() [complete]
  3 | Derive::~Derive() [deleting]
  4 | void BaseA::FuncB()
  5 | offset_to_top (-16)
  6 | Derive RTTI
      -- (BaseB, 16) vtable address --
  7 | Derive::~Derive() [complete]
      [this adjustment: -16 non-virtual]
  8 | Derive::~Derive() [deleting]
      [this adjustment: -16 non-virtual]
  9 | void BaseB::FuncC()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>对象布局图</li>
<li><img src="http://qiniu.orangew.cn/img/%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80%E5%9B%BE.png" alt="多继承对象布局图"></li>
<li>**offset_to_top(0)**：表示当前这个虚函数表（BaseA，Derive）地址距离对象顶部地址的偏移量，因为对象的头部就是虚函数表的指针，所以偏移量为0。</li>
<li>再注意这里的<strong>RTTI</strong>中有了两项，表示BaseA和Derive的虚表地址是相同的，BaseA类里的虚函数和Derive类里的虚函数都在这个链条下，截至到offset_to_top(-16)之前都是BaseA和Derive的虚函数表。</li>
<li>**offset_to_top(-16)**：表示当前这个虚函数表（BaseB）地址距离对象顶部地址的偏移量，因为对象的头部就是虚函数表的指针，所以偏移量为-16，这里用于this指针偏移，下一小节会介绍。</li>
<li>注意下后面的这个RTTI：只有一项，表示BaseB的虚函数表，后面也有两个虚析构函数，为什么有四个Derive类的析构函数呢，又是怎么调用呢，请继续往下看~</li>
</ul>
<h3 id="多继承下含有覆盖函数的类对象的布局"><a href="#多继承下含有覆盖函数的类对象的布局" class="headerlink" title="多继承下含有覆盖函数的类对象的布局"></a>多继承下含有覆盖函数的类对象的布局</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
struct BaseA &#123;
   BaseA() &#x3D; default;
   virtual ~BaseA() &#x3D; default;
   
   void FuncA() &#123;&#125;

   virtual void FuncB() &#123;
       printf(&quot;BaseA FuncB\n&quot;);
  &#125;

   int a;
   int b;
&#125;;

struct BaseB &#123;
   BaseB() &#x3D; default;
   virtual ~BaseB() &#x3D; default;
   
   void FuncA() &#123;&#125;

   virtual void FuncC() &#123;
       printf(&quot;BaseB FuncC\n&quot;);
  &#125;

   int a;
   int b;
&#125;;

struct Derive : public BaseA, public BaseB&#123;
   void FuncB() override &#123;
       printf(&quot;Derive FuncB \n&quot;);
  &#125;

   void FuncC() override &#123;
       printf(&quot;Derive FuncC \n&quot;);
  &#125;
&#125;;

int main() &#123;
   BaseA a;
   Derive d;
   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>对象布局</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">*** Dumping AST Record Layout
        0 | struct Derive
        0 |   struct BaseA (primary base)
        0 |     (BaseA vtable pointer)
        8 |     int a
       12 |     int b
       16 |   struct BaseB (base)
       16 |     (BaseB vtable pointer)
       24 |     int a
       28 |     int b
          | [sizeof&#x3D;32, dsize&#x3D;32, align&#x3D;8,
          |  nvsize&#x3D;32, nvalign&#x3D;8]

*** Dumping IRgen Record Layout<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>类大小仍然是32，和上面一样。</li>
<li>虚函数表布局：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Vtable for &#39;Derive&#39; (11 entries).
  0 | offset_to_top (0)
  1 | Derive RTTI
      -- (BaseA, 0) vtable address --
      -- (Derive, 0) vtable address --
  2 | Derive::~Derive() [complete]
  3 | Derive::~Derive() [deleting]
  4 | void Derive::FuncB()
  5 | void Derive::FuncC()
  6 | offset_to_top (-16)
  7 | Derive RTTI
      -- (BaseB, 16) vtable address --
  8 | Derive::~Derive() [complete]
      [this adjustment: -16 non-virtual]
  9 | Derive::~Derive() [deleting]
      [this adjustment: -16 non-virtual]
 10 | void Derive::FuncC()
      [this adjustment: -16 non-virtual]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><img src="http://qiniu.orangew.cn/img/%E5%A4%9A%E7%BB%A7%E6%89%BF%E8%A6%86%E7%9B%96%E8%99%9A%E5%87%BD%E6%95%B0%E5%B8%83%E5%B1%80.jpg" alt="多继承覆盖虚函数布局"></li>
<li>**offset_to_top(0)**：表示当前这个虚函数表（BaseA，Derive）地址距离对象顶部地址的偏移量，因为对象的头部就是虚函数表的指针，所以偏移量为0。</li>
<li>再注意这里的<strong>RTTI</strong>中有了两项，表示BaseA和Derive的虚表地址是相同的，BaseA类里的虚函数和Derive类里的虚函数都在这个链条下，截至到**offset_to_top(-16)**之前都是BaseA和Derive的虚函数表。</li>
<li>**offset_to_top(-16)<strong>：表示当前这个虚函数表（BaseB）地址距离对象顶部地址的偏移量，因为对象的头部就是虚函数表的指针，所以偏移量为-16。当基类BaseB的引用或指针base实际接受的是Derive类型的对象，执行base-&gt;FuncC()时候，由于FuncC()已经被重写，而此时的this指针指向的是BaseB类型的对象，需要对this指针进行调整，就是</strong>offset_to_top(-16)**，所以this指针向上调整了16字节，之后调用FuncC()，就调用到了被重写后Derive虚函数表中的FuncC()函数。这些带adjustment标记的函数都是需要进行指针调整的。至于上面所说的这里虚函数是怎么调用的，估计您也明白了吧~</li>
</ul>
<h3 id="多重继承不同的继承顺序导致的类对象的布局相同吗？"><a href="#多重继承不同的继承顺序导致的类对象的布局相同吗？" class="headerlink" title="多重继承不同的继承顺序导致的类对象的布局相同吗？"></a>多重继承不同的继承顺序导致的类对象的布局相同吗？</h3><ul>
<li>对象布局和上面的不相同啦，BaseB的虚函数表指针和数据在上面，BaseA的虚函数表指针和数据在下面，以A，B的顺序继承，对象的布局就是A在上B在下，以B，A的顺序继承，对象的布局就是B在上A在下。</li>
<li><img src="http://qiniu.orangew.cn/img/%E4%B8%8D%E5%90%8C%E7%BB%A7%E6%89%BF%E9%A1%BA%E5%BA%8F.png" alt="不同继承顺序"></li>
</ul>
<h3 id="虚继承的布局"><a href="#虚继承的布局" class="headerlink" title="虚继承的布局"></a>虚继承的布局</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
struct Base &#123;
   Base() &#x3D; default;
   virtual ~Base() &#x3D; default;
   
   void FuncA() &#123;&#125;

   virtual void FuncB() &#123;
       printf(&quot;BaseA FuncB\n&quot;);
  &#125;

   int a;
   int b;
&#125;;

struct Derive : virtual public Base&#123;
   void FuncB() override &#123;
       printf(&quot;Derive FuncB \n&quot;);
  &#125;
&#125;;

int main() &#123;
   Base a;
   Derive d;
   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>对象布局</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
*** Dumping AST Record Layout
        0 | struct Derive
        0 |   (Derive vtable pointer)
        8 |   struct Base (virtual base)
        8 |     (Base vtable pointer)
       16 |     int a
       20 |     int b
          | [sizeof&#x3D;24, dsize&#x3D;24, align&#x3D;8,
          |  nvsize&#x3D;8, nvalign&#x3D;8]

*** Dumping IRgen Record Layout<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>虚继承下，这里的对象布局和普通单继承有所不同，普通单继承下子类和基类共用一个虚表地址，而在虚继承下，子类和虚基类分别有一个虚表地址的指针，两个指针大小总和为16，再加上a和b的大小8，为24。</li>
<li>虚函数表：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
Vtable for &#39;Derive&#39; (13 entries).
  0 | vbase_offset (8)
  1 | offset_to_top (0)
  2 | Derive RTTI
      -- (Derive, 0) vtable address --
  3 | void Derive::FuncB()
  4 | Derive::~Derive() [complete]
  5 | Derive::~Derive() [deleting]
  6 | vcall_offset (-8)
  7 | vcall_offset (-8)
  8 | offset_to_top (-8)
  9 | Derive RTTI
      -- (Base, 8) vtable address --
 10 | Derive::~Derive() [complete]
      [this adjustment: 0 non-virtual, -24 vcall offset offset]
 11 | Derive::~Derive() [deleting]
      [this adjustment: 0 non-virtual, -24 vcall offset offset]
 12 | void Derive::FuncB()
      [this adjustment: 0 non-virtual, -32 vcall offset offset]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>对象布局图</li>
<li><img src="http://qiniu.orangew.cn/img/%E8%99%9A%E7%BB%A7%E6%89%BF.png" alt="虚继承"></li>
<li>**vbase_offset(8)**：对象在对象布局中与指向虚基类虚函数表的指针地址的偏移量</li>
<li><strong>vcall_offset(-8)<strong>：当</strong>虚基类</strong>Base的引用或指针base实际接受的是Derive类型的对象，执行base-&gt;FuncB()时候，由于FuncB()已经被重写，而此时的this指针指向的是Base类型的对象，需要对this指针进行调整，就是vcall_offset(-8)，所以this指针向上调整了8字节，之后调用FuncB()，就调用到了被重写后的FuncB()函数。</li>
</ul>
<h3 id="虚继承带未覆盖函数的对象布局"><a href="#虚继承带未覆盖函数的对象布局" class="headerlink" title="虚继承带未覆盖函数的对象布局"></a>虚继承带未覆盖函数的对象布局</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Base &#123;
   Base() &#x3D; default;
   virtual ~Base() &#x3D; default;
   
   void FuncA() &#123;&#125;

   virtual void FuncB() &#123;
       printf(&quot;Base FuncB\n&quot;);
  &#125;

   virtual void FuncC() &#123;
       printf(&quot;Base FuncC\n&quot;);
  &#125;

   int a;
   int b;
&#125;;

struct Derive : virtual public Base&#123;
   void FuncB() override &#123;
       printf(&quot;Derive FuncB \n&quot;);
  &#125;
&#125;;

int main() &#123;
   Base a;
   Derive d;
   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>对象布局</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
*** Dumping AST Record Layout
        0 | struct Derive
        0 |   (Derive vtable pointer)
        8 |   struct Base (virtual base)
        8 |     (Base vtable pointer)
       16 |     int a
       20 |     int b
          | [sizeof&#x3D;24, dsize&#x3D;24, align&#x3D;8,
          |  nvsize&#x3D;8, nvalign&#x3D;8]

*** Dumping IRgen Record Layout<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>和上面虚继承情况下相同，普通单继承下子类和基类共用一个虚表地址，而在虚继承下，子类和虚基类分别有一个虚表地址的指针，两个指针大小总和为16，再加上a和b的大小8，为24。</li>
<li>虚函数表布局：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Vtable for &#39;Derive&#39; (15 entries).
  0 | vbase_offset (8)
  1 | offset_to_top (0)
  2 | Derive RTTI
      -- (Derive, 0) vtable address --
  3 | void Derive::FuncB()
  4 | Derive::~Derive() [complete]
  5 | Derive::~Derive() [deleting]
  6 | vcall_offset (0)
  7 | vcall_offset (-8)
  8 | vcall_offset (-8)
  9 | offset_to_top (-8)
 10 | Derive RTTI
      -- (Base, 8) vtable address --
 11 | Derive::~Derive() [complete]
      [this adjustment: 0 non-virtual, -24 vcall offset offset]
 12 | Derive::~Derive() [deleting]
      [this adjustment: 0 non-virtual, -24 vcall offset offset]
 13 | void Derive::FuncB()
      [this adjustment: 0 non-virtual, -32 vcall offset offset]
 14 | void Base::FuncC()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>对象布局图</li>
<li><img src="http://qiniu.orangew.cn/img/%E8%99%9A%E7%BB%A7%E6%89%BF%E6%9C%AA%E8%A6%86%E7%9B%96.png" alt="虚继承未覆盖"></li>
<li>**vbase_offset(8)**：对象在对象布局中与指向虚基类虚函数表的指针地址的偏移量</li>
<li><strong>vcall_offset(-8)<strong>：当</strong>虚基类</strong>Base的引用或指针base实际接受的是Derive类型的对象，执行base-&gt;FuncB()时候，由于FuncB()已经被重写，而此时的this指针指向的是Base类型的对象，需要对this指针进行调整，就是vcall_offset(-8)，所以this指针向上调整了8字节，之后调用FuncB()，就调用到了被重写后的FuncB()函数</li>
<li>**vcall_offset(0)**：当Base的引用或指针base实际接受的是Derive类型的对象，执行base-&gt;FuncC()时候，由于FuncC()没有被重写，所以不需要对this指针进行调整，就是vcall_offset(0)，之后调用FuncC()。</li>
</ul>
<h3 id="菱形继承下类对象的布局"><a href="#菱形继承下类对象的布局" class="headerlink" title="菱形继承下类对象的布局"></a>菱形继承下类对象的布局</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
struct Base &#123;
   Base() &#x3D; default;
   virtual ~Base() &#x3D; default;
   
   void FuncA() &#123;&#125;

   virtual void FuncB() &#123;
       printf(&quot;BaseA FuncB\n&quot;);
  &#125;

   int a;
   int b;
&#125;;

struct BaseA : virtual public Base &#123;
   BaseA() &#x3D; default;
   virtual ~BaseA() &#x3D; default;
   
   void FuncA() &#123;&#125;

   virtual void FuncB() &#123;
       printf(&quot;BaseA FuncB\n&quot;);
  &#125;

   int a;
   int b;
&#125;;

struct BaseB : virtual public Base &#123;
   BaseB() &#x3D; default;
   virtual ~BaseB() &#x3D; default;
   
   void FuncA() &#123;&#125;

   virtual void FuncC() &#123;
       printf(&quot;BaseB FuncC\n&quot;);
  &#125;

   int a;
   int b;
&#125;;

struct Derive : public BaseB, public BaseA&#123;
   void FuncB() override &#123;
       printf(&quot;Derive FuncB \n&quot;);
  &#125;

   void FuncC() override &#123;
       printf(&quot;Derive FuncC \n&quot;);
  &#125;
&#125;;

int main() &#123;
   BaseA a;
   Derive d;
   return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>类对象布局</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
*** Dumping AST Record Layout
        0 | struct Derive
        0 |   struct BaseB (primary base)
        0 |     (BaseB vtable pointer)
        8 |     int a
       12 |     int b
       16 |   struct BaseA (base)
       16 |     (BaseA vtable pointer)
       24 |     int a
       28 |     int b
       32 |   struct Base (virtual base)
       32 |     (Base vtable pointer)
       40 |     int a
       44 |     int b
          | [sizeof&#x3D;48, dsize&#x3D;48, align&#x3D;8,
          |  nvsize&#x3D;32, nvalign&#x3D;8]

*** Dumping IRgen Record Layout<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>大小为48，这里不用做过多介绍啦，相信您已经知道了吧。</li>
<li>虚函数表</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">table for &#39;Derive&#39; (20 entries).
  0 | vbase_offset (32)
  1 | offset_to_top (0)
  2 | Derive RTTI
      -- (BaseB, 0) vtable address --
      -- (Derive, 0) vtable address --
  3 | Derive::~Derive() [complete]
  4 | Derive::~Derive() [deleting]
  5 | void Derive::FuncC()
  6 | void Derive::FuncB()
  7 | vbase_offset (16)
  8 | offset_to_top (-16)
  9 | Derive RTTI
      -- (BaseA, 16) vtable address --
 10 | Derive::~Derive() [complete]
      [this adjustment: -16 non-virtual]
 11 | Derive::~Derive() [deleting]
      [this adjustment: -16 non-virtual]
 12 | void Derive::FuncB()
      [this adjustment: -16 non-virtual]
 13 | vcall_offset (-32)
 14 | vcall_offset (-32)
 15 | offset_to_top (-32)
 16 | Derive RTTI
      -- (Base, 32) vtable address --
 17 | Derive::~Derive() [complete]
      [this adjustment: 0 non-virtual, -24 vcall offset offset]
 18 | Derive::~Derive() [deleting]
      [this adjustment: 0 non-virtual, -24 vcall offset offset]
 19 | void Derive::FuncB()
      [this adjustment: 0 non-virtual, -32 vcall offset offset]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="http://qiniu.orangew.cn/img/%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80%E5%9B%BE.png" alt="菱形继承对象布局图"></p>
<ul>
<li><p><strong>vbase_offset (32)</strong></p>
<p>**vbase_offset (16)**：对象在对象布局中与指向虚基类虚函数表的指针地址的偏移量</p>
<p><strong>offset_to_top (0)</strong></p>
<p><strong>offset_to_top (-16)</strong></p>
<p>**offset_to_top (-32)**：指向虚函数表的地址与对象顶部地址的偏移量。</p>
<p><strong>vcall_offset(-32)<strong>：当</strong>虚基类</strong>Base的引用或指针base实际接受的是Derive类型的对象，执行base-&gt;FuncB()时候，由于FuncB()已经被重写，而此时的this指针指向的是Base类型的对象，需要对this指针进行调整，就是vcall_offset(-32)，所以this指针向上调整了32字节，之后调用FuncB()，就调用到了被重写后的FuncB()函数。</p>
</li>
</ul>
<h4 id="为什么要虚继承？"><a href="#为什么要虚继承？" class="headerlink" title="为什么要虚继承？"></a>为什么要虚继承？</h4><p><img src="http://qiniu.orangew.cn/img/%E4%B8%BA%E4%BB%80%E4%B9%88%E8%99%9A%E7%BB%A7%E6%89%BF.jpg" alt="为什么虚继承"></p>
<ul>
<li>非虚继承时，显然D会继承两次A，内部就会存储两份A的数据浪费空间，而且还有二义性，D调用A的方法时，由于有两个A，究竟时调用哪个A的方法呢，编译器也不知道，就会报错，所以有了虚继承，解决了空间浪费以及二义性问题。在虚拟继承下，只有一个共享的基类子对象被继承，而无论该基类在派生层次中出现多少次。共享的基类子对象被称为虚基类。在虚继承下，基类子对象的复制及由此而引起的二义性都被消除了。</li>
</ul>
<h4 id="为什么虚函数表中有两个析构函数？"><a href="#为什么虚函数表中有两个析构函数？" class="headerlink" title="为什么虚函数表中有两个析构函数？"></a>为什么虚函数表中有两个析构函数？</h4><ul>
<li>前面的代码输出中我们可以看到虚函数表中有两个析构函数，一个标志为deleting，一个标志为complete，因为对象有两种构造方式，栈构造和堆构造，所以对应的实现上，对象也有两种析构方式，其中堆上对象的析构和栈上对象的析构不同之处在于，栈内存的析构不需要执行 delete 函数，会自动被回收。</li>
</ul>
<h4 id="为什么构造函数不能是虚函数？"><a href="#为什么构造函数不能是虚函数？" class="headerlink" title="为什么构造函数不能是虚函数？"></a>为什么构造函数不能是虚函数？</h4><ul>
<li>构造函数就是为了在编译阶段确定对象的类型以及为对象分配空间，如果类中有虚函数，那就会在构造函数中初始化虚函数表，虚函数的执行却需要依赖虚函数表。如果构造函数是虚函数，那它就需要依赖虚函数表才可执行，而只有在构造函数中才会初始化虚函数表，鸡生蛋蛋生鸡的问题，很矛盾，所以构造函数不能是虚函数。</li>
</ul>
<h4 id="为什么基类析构函数要是虚函数？"><a href="#为什么基类析构函数要是虚函数？" class="headerlink" title="为什么基类析构函数要是虚函数？"></a>为什么基类析构函数要是虚函数？</h4><ul>
<li>一般基类的析构函数都要设置成虚函数，因为如果不设置成虚函数，在析构的过程中只会调用到基类的析构函数而不会调用到子类的析构函数，可能会产生内存泄漏。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p><strong>offset_to_top</strong>：对象在对象布局中与对象顶部地址的偏移量。</p>
<p><strong>RTTI指针</strong>：指向存储运行时类型信息(type_info)的地址，用于运行时类型识别，用于typeid和dynamic_cast。</p>
<p><strong>vbase_offset</strong>：对象在对象布局中与指向虚基类虚函数表的指针地址的偏移量。</p>
<p><strong>vcall_offset</strong>：父类引用或指针指向子类对象，调用被子类重写的方法时，用于对虚函数执行指针地址调整，方便成功调用被重写的方法。</p>
<p><strong>thunk</strong>: 表示上面虚函数表中带有adjustment字段的函数调用需要先进行this指针调整，才可以调用到被子类重写的函数。</p>
<p>最后通过两张图总结一下对象在Linux中的布局：</p>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">A *a &#x3D; new Derive(); &#x2F;&#x2F; A为Derive的基类<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li><img src="http://qiniu.orangew.cn/img/%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80.png" alt="对象布局"></li>
<li>a作为对象指针存储在栈中，指向在堆中的类A的实例内存，其中实例内存布局中有虚函数表指针，指针指向的虚函数表存放在数据段中，虚函数表中的各个函数指针指向的函数在代码段中。</li>
<li><img src="http://qiniu.orangew.cn/img/%E8%99%9A%E5%87%BD%E6%95%B0%E7%BB%93%E6%9E%84.png" alt="虚函数结构"></li>
<li>虚表结构大体如上图，正常的虚表结构中都含有后三项，当有虚继承情况下会有前两个表项。</li>
</ul>
<h2 id="为什么要引入四种类型转换"><a href="#为什么要引入四种类型转换" class="headerlink" title="为什么要引入四种类型转换"></a>为什么要引入四种类型转换</h2><ul>
<li><p>C++关于类型转换引入了<strong>四种</strong>方式：</p>
</li>
<li><p>static_cast</p>
</li>
<li><p>const_cast</p>
</li>
<li><p>dynamic_cast</p>
</li>
<li><p>reinterpret_cast</p>
</li>
<li><p>为什么要引入这几种类型转换，它与C语言中的强制类型转换有什么区别？</p>
</li>
<li><p>这四种类型转换分别应用在什么场景？</p>
</li>
</ul>
<blockquote>
<p><strong>C++为什么要引入这几种强制类型转换？</strong></p>
<p>我们都知道C++完全兼容C语言，C语言的转换方式很简单，可以在任意类型之间转换，但这也恰恰是缺点，因为极其不安全，可能不经意间将指向const对象的指针转换成非const对象的指针，可能将基类对象指针转成了派生类对象的指针，这种转换很容易出bug，需要严格审查代码才能消除这种隐患，但是C这种转换方式不利于我们审查代码，且程序运行时也可能会出bug。</p>
<p>而C++引入的这几种类型转换可以完美的解决上述问题，不同场景下不同需求使用不同的类型转换方式，同时有利于代码审查。</p>
</blockquote>
<p><strong>static_cast</strong></p>
<p>使用方式：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
#include &lt;iostream&gt;

using namespace std;

struct Base &#123;
    virtual void Func() &#123; cout &lt;&lt; &quot;Base Func \n&quot;; &#125;
&#125;;

struct Derive : public Base &#123;
    void Func() override &#123; cout &lt;&lt; &quot;Derive Func \n&quot;; &#125;
&#125;;

int main() &#123;
    float f &#x3D; 1.23;
    cout &lt;&lt; &quot;f &quot; &lt;&lt; f &lt;&lt; endl;
    int i &#x3D; static_cast&lt;int&gt;(f);
    cout &lt;&lt; &quot;i &quot; &lt;&lt; i &lt;&lt; endl;

    int *pi &#x3D; static_cast&lt;int *&gt;(&amp;f);  &#x2F;&#x2F; error invalid static_cast from type ‘float*’ to type ‘int*’

    Derive d;
    d.Func();
    Base *b &#x3D; static_cast&lt;Base *&gt;(&amp;d); 
    b-&gt;Func();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>使用场景</strong>：基本数据类型之间的转换使用，例如float转int，int转char等，在有类型指针和void*之间转换使用，子类对象指针转换成父类对象指针也可以使用static_cast。</li>
<li>非多态类型转换一般都使用static_cast，而且最好把所有的隐式类型转换都是用static_cast进行显示替换，不能使用static_cast在有类型指针之间进行类型转换。</li>
</ul>
<p><strong>dynamic_cast</strong></p>
<p>使用方式：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
#include &lt;iostream&gt;

using namespace std;

struct Base &#123;
    virtual void Func() &#123; cout &lt;&lt; &quot;Base Func \n&quot;; &#125;
&#125;;

struct Derive : public Base &#123;
    void Func() override &#123; cout &lt;&lt; &quot;Derive Func \n&quot;; &#125;
&#125;;

int main() &#123;
    Derive d;
    d.Func();
    Base *b &#x3D; dynamic_cast&lt;Base *&gt;(&amp;d);
    b-&gt;Func();
    Derive *dd &#x3D; dynamic_cast&lt;Derive *&gt;(b);
    dd-&gt;Func();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>使用场景</strong>：用于将父类的指针或引用转换为子类的指针或引用，此场景下父类必须要有虚函数，因为dynamic_cast是运行时检查，检查需要运行时信息RTTI，而RTTI存储在虚函数表中</li>
</ul>
<p><strong>const_cast</strong></p>
<p>使用方式：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int main() &#123;
    int data &#x3D; 10;
    const int *cpi &#x3D; &amp;data;

    int *pi &#x3D; const_cast&lt;int *&gt;(cpi);

    const int *cpii &#x3D; const_cast&lt;const int *&gt;(pi);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li> <strong>使用场景</strong>：用于常量指针或引用与非常量指针或引用之间的转换，只有const_cast才可以对常量进行操作，一般都是用它来去除常量性，去除常量性是危险操作，还是要谨慎操作。</li>
</ul>
<p><strong>reinterpret_cast</strong></p>
<p>使用方式：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
int main() &#123;
    int data &#x3D; 10;
    int *pi &#x3D; &amp;data;

    float *fpi &#x3D; reinterpret_cast&lt;float *&gt;(pi);

    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>使用场景</strong>：没啥场景，类似C语言中的强制类型转换，什么都可以转，万不得已不要使用，一般前三种转换方式不能解决问题了使用这种强制类型转换方式。</li>
</ul>
<h2 id="为什么会出现nullptr"><a href="#为什么会出现nullptr" class="headerlink" title="为什么会出现nullptr"></a>为什么会出现nullptr</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int *ptr &#x3D; nullptr;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>同样是表示空指针，之前NULL使用的好好的，为什么要引入nullptr？</li>
<li>nullptr和NULL又有什么区别呢？</li>
<li>NULL究竟是什么？</li>
<li>源码在此：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef NULL
    #ifdef __cplusplus
        #define NULL 0
    #else
        #define NULL ((void *)0)
    #endif
#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>从源码中可以知道，在C中NULL是((void *)0)指针，在C++中NULL却是个整数0。</li>
<li>C++中有一个很特别的规定就是0既表示<strong>整形常量</strong>也用来表示<strong>空指针常量</strong>。</li>
<li>C++03标准中的一段话：</li>
<li>主要规定空指针常量需要被转化成指针类型，同时这个转化为指针类型的值还不能和其它的对象指针或者函数指针的值相同。两个空指针常量的值还需要相等。</li>
<li>C99标准</li>
<li>主要就是说C中的空指针常量是整型0被强转成了void*，这就可以确保这个空指针的值与其它对象或函数指针值不相等。</li>
<li>这里C++中的NULL如果和C语言一样也是(void <em>)0指针，而C++却又不允许void</em>隐式转换成其它指针类型，那还怎么用NULL来表示空指针呢，岂不是尴尬了。</li>
<li>下面代码编译会报错：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
#include &lt;iostream&gt;

int main() &#123;
    int *a &#x3D; (void *)0;
    return 0;
&#125;
error: cannot initialize a variable of type &#39;int *&#39; with an rvalue of type &#39;void *&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>为什么要引入nullptr？</strong></li>
<li>一个原因是可以让整形0放下重担，0只表示一件事情，它只是一个整数类型0，没有任何其它语义，空指针的活就安排给其它员工，这个员工就是nullptr关键字。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
void func(char*) &#123;
    cout &lt;&lt; &quot;char*&quot;;
&#125;
void func(int) &#123;
    cout &lt;&lt; &quot;int&quot;;
&#125;

int main() &#123;
     func(NULL); &#x2F;&#x2F; 编译失败 error: call of overloaded ‘func(NULL)’ is ambiguous
    func(nullptr); &#x2F;&#x2F; char*
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>另一个原因是在C++的函数重载中，传入NULL会导致编译失败，所以需要引入nullptr，使用nullptr可以解决函数重载中的参数匹配问题。</li>
<li>总结<ol>
<li>使用nullptr可以不用担心整型和指针类型的重载，不会产生二义性导致编译失败。</li>
<li>0和空指针分别表示不同的含义，使用nullptr可以更好的支持模板编程。</li>
<li>使用nullptr使代码更安全，让用户编写代码更清晰直观。</li>
</ol>
</li>
<li>NULL其实就是一个宏，对于宏，C++之父一直推崇尽量避免使用它，在实际编程中，可以减少宏的使用，直接使用0。Bjarne Stroustrup语录也给出了解释。所以在C++中，完全可以抛弃掉NULL，不得已可以使用0替代。</li>
<li>既然NULL就是0，那为什么不直接使用0，而搞出来一个NULL呢？</li>
<li>因为需要为空指针常量起一个名字，更清晰的表明它表达的是什么含义，就像3.1415926为什么要用π表示一样，尽管宏一直是被各方吐槽的，但为了有名字在当时C++也只能这样，这也是NULL宏面世的唯一一个理由。</li>
<li>空指针应该有什么特性吗？<ol>
<li>它应该有一个自己的名字，它应该是一个保留关键字。</li>
<li>空指针不能够被用于算数表达式中，不能被赋值给整型，也不能用于和指针类型外的类型做比较。</li>
<li>空指针可以被转化成任何指针类型，不能被转换成指针类型外的任何类型。</li>
</ol>
</li>
<li>nullptr为什么可以转换成int * ， float *等？</li>
<li>看下它可能的实现吧：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct nullptr_t
&#123;
    void operator&amp;() const &#x3D; delete;  &#x2F;&#x2F; Can&#39;t take address of nullptr

    template &lt;class T&gt;
    inline operator T*() const
    &#123;
        return 0;
    &#125;

    template &lt;class C, class T&gt;
    inline operator T C::*() const
    &#123;
        return 0;
    &#125;
&#125;;

nullptr_t nullptr;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>通过实现了部分运算符，所以nullptr可以转换成int*等，同时，为什么不能对nullptr取址？因为它的取址操作被delete修饰了。</li>
<li>使用nullptr还有什么好处呢？可以用于抛出异常。</li>
<li>nullptr是有类型的：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typdef decltype(nullptr) nullptr_t;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>当空指针用nullptr表示时，空指针就终于有类型了，当有异常需要抛出时，就可以抛出nullptr。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main() &#123;
    try &#123;
        ...
        throw nullptr;
    &#125; catch(nullptr_t) &#123;
        ...
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="C-C-时间相关的那些函数"><a href="#C-C-时间相关的那些函数" class="headerlink" title="C/C++时间相关的那些函数"></a>C/C++时间相关的那些函数</h2><ul>
<li>首先介绍下C++标准中的chrono库</li>
<li>chrono是一个关于时间的库，起源于boost，现在是C++的标准，话说现在的C++标准好多都是源于boost，要进标准的特性似乎都会先在boost试验一番。</li>
<li>首先看一下使用chrono简单计时的示例代码：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void func() &#123;  &#x2F;&#x2F; 计时
   std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; begin &#x3D; high_resolution_clock::now();
   std::this_thread::sleep_for(std::chrono::milliseconds(20));
   auto end &#x3D; high_resolution_clock::now();
   cout &lt;&lt; &quot;time &quot; &lt;&lt; duration_cast&lt;milliseconds&gt;(end - begin).count() &lt;&lt; endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>chrono中有三个概念duration、time_point、clock</li>
<li>duration：表示一段时间，三分钟、三秒等，它的定义如下：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class _Rep, class _Period &#x3D; ratio&lt;1&gt;&gt; class duration;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>ratio的定义如下：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;intmax_t N, intmax_t D &#x3D; 1&gt; class ratio;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>Rep表示数据类型，int，long等，Period表示时间单位，N是分子，D是分母，直接看例子吧：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">using atto  &#x3D; ratio&lt;1, 1000000000000000000LL&gt;;
using femto &#x3D; ratio&lt;1, 1000000000000000LL&gt;;
using pico  &#x3D; ratio&lt;1, 1000000000000LL&gt;;
using nano  &#x3D; ratio&lt;1, 1000000000&gt;;
using micro &#x3D; ratio&lt;1, 1000000&gt;;
using milli &#x3D; ratio&lt;1, 1000&gt;;
using centi &#x3D; ratio&lt;1, 100&gt;;
using deci  &#x3D; ratio&lt;1, 10&gt;;
using deca  &#x3D; ratio&lt;10, 1&gt;;
using hecto &#x3D; ratio&lt;100, 1&gt;;
using kilo  &#x3D; ratio&lt;1000, 1&gt;;
using mega  &#x3D; ratio&lt;1000000, 1&gt;;
using giga  &#x3D; ratio&lt;1000000000, 1&gt;;
using tera  &#x3D; ratio&lt;1000000000000LL, 1&gt;;
using peta  &#x3D; ratio&lt;1000000000000000LL, 1&gt;;
using exa   &#x3D; ratio&lt;1000000000000000000LL, 1&gt;;

using nanoseconds  &#x3D; duration&lt;long long, nano&gt;;
using microseconds &#x3D; duration&lt;long long, micro&gt;;
using milliseconds &#x3D; duration&lt;long long, milli&gt;;
using seconds      &#x3D; duration&lt;long long&gt;;
using minutes      &#x3D; duration&lt;int, ratio&lt;60&gt;&gt;;
using hours        &#x3D; duration&lt;int, ratio&lt;3600&gt;&gt;;

using hours2       &#x3D; duration&lt;int, ratio&lt;3600, 1&gt;&gt;;
using hours2       &#x3D; duration&lt;int, ratio&lt;7200, 2&gt;&gt;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>详细看完上述例子您也明白了，ratio的默认的时间单位是1秒，以小时为例，一小时等于3600秒，3600 / 1 == 7200 / 2 == 3600，所以hours == hours2 == hours3。</li>
<li>标准库还提供了duration_cast用于转换各种duration。</li>
<li>标准库还提供了duration_cast用于转换各种duration。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class _To, class _Rep, class _Period, enable_if_t&lt;_Is_duration_v&lt;_To&gt;, int&gt; &#x3D; 0&gt;
   constexpr _To duration_cast(const duration&lt;_Rep, _Period&gt;&amp;) noexcept(
   is_arithmetic_v&lt;_Rep&gt;&amp;&amp; is_arithmetic_v&lt;typename _To::rep&gt;);

template &lt;class _Ty&gt;
   _INLINE_VAR constexpr bool _Is_duration_v &#x3D; _Is_specialization_v&lt;_Ty, duration&gt;;

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_arithmetic_v &#x3D; &#x2F;&#x2F; determine whether _Ty is an arithmetic type
   is_integral_v&lt;_Ty&gt; || is_floating_point_v&lt;_Ty&gt;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>函数看着很繁琐，直接看看示例代码吧：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void func() &#123;
   auto sec &#x3D; std::chrono::seconds(10);
   auto mill &#x3D; std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(sec);
   cout &lt;&lt; sec.count() &lt;&lt; endl; &#x2F;&#x2F; 返回多少s
   cout &lt;&lt; mill.count() &lt;&lt; endl; &#x2F;&#x2F; 返回多少ms
&#125;
输出：
10
10000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>time_point：用来表示某个具体时间点。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class _Clock, class _Duration &#x3D; typename _Clock::duration&gt;
   class time_point;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void func() &#123;
   std::chrono::time_point&lt;std::chrono::system_clock, std::chrono::milliseconds&gt; tp(std::chrono::seconds(12));
   cout &lt;&lt; tp.time_since_epoch().count() &lt;&lt; endl;
   std::time_t t &#x3D; system_clock::to_time_t(tp);
   cout &lt;&lt; &quot;time &quot; &lt;&lt; ctime(&amp;t) &lt;&lt; endl;
&#125;
输出：
12000
time Thu Jan  1 08:00:12 1970<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>这里有个函数time_since_epoch()，表示这个time_point距离元年也就是1970年1月1日所经过的duration。</li>
<li>time_point也有各种表示方式，类似于duration，也提供了转换函数time_point_cast()。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void func() &#123;
    time_point&lt;system_clock, milliseconds&gt; tp(seconds(12));
    cout &lt;&lt; tp.time_since_epoch().count() &lt;&lt; endl;
    time_point&lt;system_clock, seconds&gt; tp2 &#x3D; time_point_cast&lt;seconds&gt;(tp);
    cout &lt;&lt; tp2.time_since_epoch().count() &lt;&lt; endl;
&#125;
输出:
12000
12<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>Clocks：</li>
<li>这里的时钟大体有三种：</li>
<li>system_clock</li>
<li>steady_clock</li>
<li>high_resolution_clock</li>
<li>system_clock表示当前的系统时钟，有三个函数：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">now()：表示当前时间的time_point
to_time_t()：将time_point转换成time_t秒
from_time_t()：将time_t转换成time_point<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li>源码如下</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct system_clock &#123; &#x2F;&#x2F; wraps GetSystemTimePreciseAsFileTime&#x2F;GetSystemTimeAsFileTime
    using rep &#x3D; long long;

    using period &#x3D; ratio_multiply&lt;ratio&lt;_XTIME_NSECS_PER_TICK, 1&gt;, nano&gt;;

    using duration                  &#x3D; chrono::duration&lt;rep, period&gt;;
    using time_point                &#x3D; chrono::time_point&lt;system_clock&gt;;
    static constexpr bool is_steady &#x3D; false;

    _NODISCARD static time_point now() noexcept &#123; &#x2F;&#x2F; get current time
        return time_point(duration(_Xtime_get_ticks()));
    &#125;

    _NODISCARD static __time64_t to_time_t(const time_point&amp; _Time) noexcept &#123; &#x2F;&#x2F; convert to __time64_t
        return static_cast&lt;__time64_t&gt;(_Time.time_since_epoch().count() &#x2F; _XTIME_TICKS_PER_TIME_T);
    &#125;

    _NODISCARD static time_point from_time_t(__time64_t _Tm) noexcept &#123; &#x2F;&#x2F; convert from __time64_t
        return time_point(duration(_Tm * _XTIME_TICKS_PER_TIME_T));
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>steady_clock表示稳定的时钟，它只有一个函数，就是now()，后一次调用now()肯定比上一次调用now()的返回值大，不受系统时间修改的影响。</li>
<li>源码如下：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
struct steady_clock &#123; &#x2F;&#x2F; wraps QueryPerformanceCounter
    using rep                       &#x3D; long long;
    using period                    &#x3D; nano;
    using duration                  &#x3D; nanoseconds;
    using time_point                &#x3D; chrono::time_point&lt;steady_clock&gt;;
    static constexpr bool is_steady &#x3D; true;

    _NODISCARD static time_point now() noexcept &#123; &#x2F;&#x2F; get current time
        const long long _Freq &#x3D; _Query_perf_frequency(); &#x2F;&#x2F; doesn&#39;t change after system boot
        const long long _Ctr  &#x3D; _Query_perf_counter();
        static_assert(period::num &#x3D;&#x3D; 1, &quot;This assumes period::num &#x3D;&#x3D; 1.&quot;);
        const long long _Whole &#x3D; (_Ctr &#x2F; _Freq) * period::den;
        const long long _Part  &#x3D; (_Ctr % _Freq) * period::den &#x2F; _Freq;
        return time_point(duration(_Whole + _Part));
    &#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void func() &#123;  &#x2F;&#x2F; 计时
    std::chrono::time_point&lt;std::chrono::steady_clock&gt; begin &#x3D; steady_clock::now();
    std::this_thread::sleep_for(std::chrono::milliseconds(20));
    auto end &#x3D; steady_clock::now();
    cout &lt;&lt; &quot;time &quot; &lt;&lt; duration_cast&lt;milliseconds&gt;(end - begin).count() &lt;&lt; endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>high_resolution_clock表示高精度时钟，是系统可用的最高精度的时钟，它其实就是system_clock或者steady_clock的别名：</li>
<li><code>using high_resolution_clock = steady_clock;</code></li>
<li>介绍完了C++的chrono那下面再看下C语言的各种时间相关的API吧：</li>
<li>首先可以通过C语言的clock拿到程序执行时处理器所使用的时钟数来计时：</li>
<li><code>clock_t clock(void);</code></li>
<li>该函数返回程序执行起（一般为程序的开头），处理器时钟所使用的时间。也获取 CPU 所使用的秒数，除以 CLOCKS_PER_SEC即可，返回的clock_t其实就是long类型的重命名。</li>
<li>使用方式如下：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void func() &#123;
    clock_t start_t &#x3D; clock();
    cout &lt;&lt; start_t &lt;&lt; &quot; 个时钟 \n&quot;;
    for (int i &#x3D; 0; i &lt; 100000000; i++) &#123;
    &#125;
    clock_t end_t &#x3D; clock();
    cout &lt;&lt; end_t &lt;&lt; &quot; 个时钟 \n&quot;;
    cout &lt;&lt; &quot;循环的秒数：&quot; &lt;&lt; (double)(end_t - start_t) &#x2F; CLOCKS_PER_SEC &lt;&lt; endl;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>如何获取当前时间戳，单位为秒</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void func() &#123;  &#x2F;&#x2F; 获取当前时间戳，单位为秒
    struct timeval time;
    gettimeofday(&amp;time, NULL);
    cout &lt;&lt; time.tv_sec &lt;&lt; &quot; s \n&quot;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>也可以使用time函数：</li>
<li>该函数返回系统的当前日历时间，返回的是自1970年1月1日以来所经过的秒数。</li>
<li>time_t其实就是一个整数类型，是int64_t的重命名，该函数直接使用返回值就好，参数一般传空即可。</li>
<li>timer 存取结果的时间指针变量，类型为time_t，指针变量可以为null。</li>
<li>如果timer指针非null，则time()函数返回值变量与timer指针一样，都指向同一个内存地址；</li>
<li>否则如果timer指针为null，则time()函数返回一个time_t变量时间。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void func() &#123;  &#x2F;&#x2F; 获取当前时间戳，单位为秒
    time_t now &#x3D; time(NULL);
    cout &lt;&lt; static_cast&lt;int64_t&gt;(now) &lt;&lt; &quot; s \n&quot;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>如何获取当前时间戳？单位为毫秒</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void func() &#123;  &#x2F;&#x2F; 获取当前时间戳，单位为毫秒
    struct timeval time;
    gettimeofday(&amp;time, NULL);
    cout &lt;&lt; time.tv_sec * 1000 + time.tv_usec &#x2F; 1000 &lt;&lt; &quot; ms \n&quot;;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="C-项目"><a href="#C-项目" class="headerlink" title="C++项目"></a>C++项目</h2><h3 id="手撸STL"><a href="#手撸STL" class="headerlink" title="手撸STL"></a>手撸STL</h3><ul>
<li><a href="https://github.com/Alinshans/MyTinySTL">简易版STL:项目的学习地址</a></li>
<li>algo.h头文件 包含了这个项目的一系列算法</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef MYTINYSTL_ALGO_H_
#define MYTINYSTL_ALGO_H_

#ifdef _MSC_VER
#pragma warning(push)
#pragma warning(disable : 4244)
#endif

&#x2F;&#x2F; 这个头文件包含了 mystl 的一系列算法

#include &lt;cstddef&gt;
#include &lt;ctime&gt;

#include &quot;algobase.h&quot;
#include &quot;memory.h&quot;
#include &quot;heap_algo.h&quot;
#include &quot;functional.h&quot;

namespace mystl
&#123;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; all_of
&#x2F;&#x2F; 检查[first, last)内是否全部元素都满足一元操作 unary_pred 为 true 的情况，满足则返回 true
&#x2F;*****************************************************************************************&#x2F;
template &lt;class InputIter, class UnaryPredicate&gt;
bool all_of(InputIter first, InputIter last, UnaryPredicate unary_pred)
&#123;
  for (; first !&#x3D; last; ++first)
  &#123;
    if (!unary_pred(*first))
      return false;
  &#125;
  return true;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; any_of
&#x2F;&#x2F; 检查[first, last)内是否存在某个元素满足一元操作 unary_pred 为 true 的情况，满足则返回 true
&#x2F;*****************************************************************************************&#x2F;
template &lt;class InputIter, class UnaryPredicate&gt;
bool any_of(InputIter first, InputIter last, UnaryPredicate unary_pred)
&#123;
  for (; first !&#x3D; last; ++first)
  &#123;
    if (unary_pred(*first))
      return true;
  &#125;
  return false;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; none_of
&#x2F;&#x2F; 检查[first, last)内是否全部元素都不满足一元操作 unary_pred 为 true 的情况，满足则返回 true
&#x2F;*****************************************************************************************&#x2F;
template &lt;class InputIter, class UnaryPredicate&gt;
bool none_of(InputIter first, InputIter last, UnaryPredicate unary_pred)
&#123;
  for (; first !&#x3D; last; ++first)
  &#123;
    if (unary_pred(*first))
      return false;
  &#125;
  return true;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; count
&#x2F;&#x2F; 对[first, last)区间内的元素与给定值进行比较，缺省使用 operator&#x3D;&#x3D;，返回元素相等的个数
&#x2F;*****************************************************************************************&#x2F;
template &lt;class InputIter, class T&gt;
size_t count(InputIter first, InputIter last, const T&amp; value)
&#123;
  size_t n &#x3D; 0;
  for (; first !&#x3D; last; ++first)
  &#123;
    if (*first &#x3D;&#x3D; value)
      ++n;
  &#125;
  return n;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; count_if
&#x2F;&#x2F; 对[first, last)区间内的每个元素都进行一元 unary_pred 操作，返回结果为 true 的个数
&#x2F;*****************************************************************************************&#x2F;
template &lt;class InputIter, class UnaryPredicate&gt;
size_t count_if(InputIter first, InputIter last, UnaryPredicate unary_pred)
&#123;
  size_t n &#x3D; 0;
  for (; first !&#x3D; last; ++first)
  &#123;
    if (unary_pred(*first))
      ++n;
  &#125;
  return n;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; find
&#x2F;&#x2F; 在[first, last)区间内找到等于 value 的元素，返回指向该元素的迭代器
&#x2F;*****************************************************************************************&#x2F;
template &lt;class InputIter, class T&gt;
InputIter
find(InputIter first, InputIter last, const T&amp; value)
&#123;
  while (first !&#x3D; last &amp;&amp; *first !&#x3D; value)
    ++first;
  return first;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; find_if
&#x2F;&#x2F; 在[first, last)区间内找到第一个令一元操作 unary_pred 为 true 的元素并返回指向该元素的迭代器
&#x2F;*****************************************************************************************&#x2F;
template &lt;class InputIter, class UnaryPredicate&gt;
InputIter
find_if(InputIter first, InputIter last, UnaryPredicate unary_pred)
&#123;
  while (first !&#x3D; last &amp;&amp; !unary_pred(*first))
    ++first;
  return first;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; find_if_not
&#x2F;&#x2F; 在[first, last)区间内找到第一个令一元操作 unary_pred 为 false 的元素并返回指向该元素的迭代器
&#x2F;*****************************************************************************************&#x2F;
template &lt;class InputIter, class UnaryPredicate&gt;
InputIter
find_if_not(InputIter first, InputIter last, UnaryPredicate unary_pred)
&#123;
  while (first !&#x3D; last &amp;&amp; unary_pred(*first))
    ++first;
  return first;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; search
&#x2F;&#x2F; 在[first1, last1)中查找[first2, last2)的首次出现点
&#x2F;*****************************************************************************************&#x2F;
template &lt;class ForwardIter1, class ForwardIter2&gt;
ForwardIter1
search(ForwardIter1 first1, ForwardIter1 last1,
       ForwardIter2 first2, ForwardIter2 last2)
&#123;
  auto d1 &#x3D; mystl::distance(first1, last1);
  auto d2 &#x3D; mystl::distance(first2, last2);
  if (d1 &lt; d2)
    return last1;
  auto current1 &#x3D; first1;
  auto current2 &#x3D; first2;
  while (current2 !&#x3D; last2)
  &#123;
    if (*current1 &#x3D;&#x3D; *current2)
    &#123;
      ++current1;
      ++current2;
    &#125;
    else
    &#123;
      if (d1 &#x3D;&#x3D; d2)
      &#123;
        return last1;
      &#125;
      else
      &#123;
        current1 &#x3D; ++first1;
        current2 &#x3D; first2;
        --d1;
      &#125;
    &#125;
  &#125;
  return first1;
&#125;

&#x2F;&#x2F; 重载版本使用函数对象 comp 代替比较操作
template &lt;class ForwardIter1, class ForwardIter2, class Compared&gt;
ForwardIter1
search(ForwardIter1 first1, ForwardIter1 last1,
       ForwardIter2 first2, ForwardIter2 last2, Compared comp)
&#123;
  auto d1 &#x3D; mystl::distance(first1, last1);
  auto d2 &#x3D; mystl::distance(first2, last2);
  if (d1 &lt; d2)
    return last1;
  auto current1 &#x3D; first1;
  auto current2 &#x3D; first2;
  while (current2 !&#x3D; last2)
  &#123;
    if (comp(*current1, *current2))
    &#123;
      ++current1;
      ++current2;
    &#125;
    else
    &#123;
      if (d1 &#x3D;&#x3D; d2)
      &#123;
        return last1;
      &#125;
      else
      &#123;
        current1 &#x3D; ++first1;
        current2 &#x3D; first2;
        --d1;
      &#125;
    &#125;
  &#125;
  return first1;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; search_n
&#x2F;&#x2F; 在[first, last)中查找连续 n 个 value 所形成的子序列，返回一个迭代器指向该子序列的起始处
&#x2F;*****************************************************************************************&#x2F;
template &lt;class ForwardIter, class Size, class T&gt;
ForwardIter
search_n(ForwardIter first, ForwardIter last, Size n, const T&amp; value)
&#123;
  if (n &lt;&#x3D; 0)
  &#123;
    return first;
  &#125;
  else
  &#123;
    first &#x3D; mystl::find(first, last, value);
    while (first !&#x3D; last)
    &#123;
      auto m &#x3D; n - 1;
      auto i &#x3D; first;
      ++i;
      while (i !&#x3D; last &amp;&amp; m !&#x3D; 0 &amp;&amp; *i &#x3D;&#x3D; value)
      &#123;
        ++i;
        --m;
      &#125;
      if (m &#x3D;&#x3D; 0)
      &#123;
        return first;
      &#125;
      else
      &#123;
        first &#x3D; mystl::find(i, last, value);
      &#125;
    &#125;
    return last;
  &#125;
&#125;

&#x2F;&#x2F; 重载版本使用函数对象 comp 代替比较操作
template &lt;class ForwardIter, class Size, class T, class Compared&gt;
ForwardIter
search_n(ForwardIter first, ForwardIter last,
         Size n, const T&amp; value, Compared comp)
&#123;
  if (n &lt;&#x3D; 0)
  &#123;
    return first;
  &#125;
  else
  &#123;
    while (first !&#x3D; last)
    &#123;
      if (comp(*first, value))
        break;
      ++first;
    &#125;
    while (first !&#x3D; last)
    &#123;
      auto m &#x3D; n - 1;
      auto i &#x3D; first;
      ++i;
      while (i !&#x3D; last &amp;&amp; m !&#x3D; 0 &amp;&amp; comp(*i, value))
      &#123;
        ++i;
        --m;
      &#125;
      if (m &#x3D;&#x3D; 0)
      &#123;
        return first;
      &#125;
      else
      &#123;
        while (i !&#x3D; last)
        &#123;
          if (comp(*i, value))
            break;
          ++i;
        &#125;
        first &#x3D; i;
      &#125;
    &#125;
    return last;
  &#125;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; find_end
&#x2F;&#x2F; 在[first1, last1)区间中查找[first2, last2)最后一次出现的地方，若不存在返回 last1
&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; find_end_dispatch 的 forward_iterator_tag 版本
template &lt;class ForwardIter1, class ForwardIter2&gt;
ForwardIter1
find_end_dispatch(ForwardIter1 first1, ForwardIter1 last1,
                  ForwardIter2 first2, ForwardIter2 last2,
                  forward_iterator_tag, forward_iterator_tag)
&#123;
  if (first2 &#x3D;&#x3D; last2)
  &#123;
    return last1;
  &#125;
  else
  &#123;
    auto result &#x3D; last1;
    while (true)
    &#123;
      &#x2F;&#x2F; 利用 search 查找某个子序列的首次出现点，找不到则返回 last1
      auto new_result &#x3D; mystl::search(first1, last1, first2, last2);
      if (new_result &#x3D;&#x3D; last1)
      &#123;
        return result;
      &#125;
      else
      &#123;
        result &#x3D; new_result;
        first1 &#x3D; new_result;
        ++first1;
      &#125;
    &#125;
  &#125;
&#125;

&#x2F;&#x2F; find_end_dispatch 的 bidirectional_iterator_tag 版本
template &lt;class BidirectionalIter1, class BidirectionalIter2&gt;
BidirectionalIter1
find_end_dispatch(BidirectionalIter1 first1, BidirectionalIter1 last1,
                  BidirectionalIter2 first2, BidirectionalIter2 last2,
                  bidirectional_iterator_tag, bidirectional_iterator_tag)
&#123;
  typedef reverse_iterator&lt;BidirectionalIter1&gt; reviter1;
  typedef reverse_iterator&lt;BidirectionalIter2&gt; reviter2;
  reviter1 rlast1(first1);
  reviter2 rlast2(first2);
  reviter1 rresult &#x3D; mystl::search(reviter1(last1), rlast1, reviter2(last2), rlast2);
  if (rresult &#x3D;&#x3D; rlast1)
  &#123;
    return last1;
  &#125;
  else
  &#123;
    auto result &#x3D; rresult.base();
    mystl::advance(result, -mystl::distance(first2, last2));
    return result;
  &#125;
&#125;

template &lt;class ForwardIter1, class ForwardIter2&gt;
ForwardIter1
find_end(ForwardIter1 first1, ForwardIter1 last1,
         ForwardIter2 first2, ForwardIter2 last2)
&#123;
  typedef typename iterator_traits&lt;ForwardIter1&gt;::iterator_category Category1;
  typedef typename iterator_traits&lt;ForwardIter2&gt;::iterator_category Category2;
  return mystl::find_end_dispatch(first1, last1, first2, last2, Category1(), Category2());
&#125;

&#x2F;&#x2F; 重载版本使用函数对象 comp 代替比较操作
&#x2F;&#x2F; find_end_dispatch 的 forward_iterator_tag 版本
template &lt;class ForwardIter1, class ForwardIter2, class Compared&gt;
ForwardIter1
find_end_dispatch(ForwardIter1 first1, ForwardIter1 last1,
                  ForwardIter2 first2, ForwardIter2 last2,
                  forward_iterator_tag, forward_iterator_tag, Compared comp)
&#123;
  if (first2 &#x3D;&#x3D; last2)
  &#123;
    return last1;
  &#125;
  else
  &#123;
    auto result &#x3D; last1;
    while (true)
    &#123;
      &#x2F;&#x2F; 利用 search 查找某个子序列的首次出现点，找不到则返回 last1
      auto new_result &#x3D; mystl::search(first1, last1, first2, last2, comp);
      if (new_result &#x3D;&#x3D; last1)
      &#123;
        return result;
      &#125;
      else
      &#123;
        result &#x3D; new_result;
        first1 &#x3D; new_result;
        ++first1;
      &#125;
    &#125;
  &#125;
&#125;

&#x2F;&#x2F; find_end_dispatch 的 bidirectional_iterator_tag 版本
template &lt;class BidirectionalIter1, class BidirectionalIter2, class Compared&gt;
BidirectionalIter1
find_end_dispatch(BidirectionalIter1 first1, BidirectionalIter1 last1,
                  BidirectionalIter2 first2, BidirectionalIter2 last2,
                  bidirectional_iterator_tag, bidirectional_iterator_tag, Compared comp)
&#123;
  typedef reverse_iterator&lt;BidirectionalIter1&gt; reviter1;
  typedef reverse_iterator&lt;BidirectionalIter2&gt; reviter2;
  reviter1 rlast1(first1);
  reviter2 rlast2(first2);
  reviter1 rresult &#x3D; mystl::search(reviter1(last1), rlast1, reviter2(last2), rlast2, comp);
  if (rresult &#x3D;&#x3D; rlast1)
  &#123;
    return last1;
  &#125;
  else
  &#123;
    auto result &#x3D; rresult.base();
    mystl::advance(result, -mystl::distance(first2, last2));
    return result;
  &#125;
&#125;

template &lt;class ForwardIter1, class ForwardIter2, class Compared&gt;
ForwardIter1
find_end(ForwardIter1 first1, ForwardIter1 last1,
         ForwardIter2 first2, ForwardIter2 last2, Compared comp)
&#123;
  typedef typename iterator_traits&lt;ForwardIter1&gt;::iterator_category Category1;
  typedef typename iterator_traits&lt;ForwardIter2&gt;::iterator_category Category2;
  return mystl::find_end_dispatch(first1, last1, first2, last2, Category1(), Category2(), comp);
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; find_first_of
&#x2F;&#x2F; 在[first1, last1)中查找[first2, last2)中的某些元素，返回指向第一次出现的元素的迭代器
&#x2F;*****************************************************************************************&#x2F;
template &lt;class InputIter, class ForwardIter&gt;
InputIter
find_first_of(InputIter first1, InputIter last1,
              ForwardIter first2, ForwardIter last2)
&#123;
  for (; first1 !&#x3D; last1; ++first1)
  &#123;
    for (auto iter &#x3D; first2; iter !&#x3D; last2; ++iter)
    &#123;
      if (*first1 &#x3D;&#x3D; *iter)
        return first1;
    &#125;
  &#125;
  return last1;
&#125;

&#x2F;&#x2F; 重载版本使用函数对象 comp 代替比较操作
template &lt;class InputIter, class ForwardIter, class Compared&gt;
InputIter
find_first_of(InputIter first1, InputIter last1,
              ForwardIter first2, ForwardIter last2, Compared comp)
&#123;
  for (; first1 !&#x3D; last1; ++first1)
  &#123;
    for (auto iter &#x3D; first2; iter !&#x3D; last2; ++iter)
    &#123;
      if (comp(*first1, *iter))
        return first1;
    &#125;
  &#125;
  return last1;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; for_each
&#x2F;&#x2F; 使用一个函数对象 f 对[first, last)区间内的每个元素执行一个 operator() 操作，但不能改变元素内容
&#x2F;&#x2F; f() 可返回一个值，但该值会被忽略
&#x2F;*****************************************************************************************&#x2F;
template &lt;class InputIter, class Function&gt;
Function for_each(InputIter first, InputIter last, Function f)
&#123;
  for (; first !&#x3D; last; ++first)
  &#123;
    f(*first);
  &#125;
  return f;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; adjacent_find
&#x2F;&#x2F; 找出第一对匹配的相邻元素，缺省使用 operator&#x3D;&#x3D; 比较，如果找到返回一个迭代器，指向这对元素的第一个元素
&#x2F;*****************************************************************************************&#x2F;
template &lt;class ForwardIter&gt;
ForwardIter adjacent_find(ForwardIter first, ForwardIter last)
&#123;
  if (first &#x3D;&#x3D; last)  return last;
  auto next &#x3D; first;
  while (++next !&#x3D; last)
  &#123;
    if (*first &#x3D;&#x3D; *next)  return first;
    first &#x3D; next;
  &#125;
  return last;
&#125;

&#x2F;&#x2F; 重载版本使用函数对象 comp 代替比较操作
template &lt;class ForwardIter, class Compared&gt;
ForwardIter adjacent_find(ForwardIter first, ForwardIter last, Compared comp)
&#123;
  if (first &#x3D;&#x3D; last)  return last;
  auto next &#x3D; first;
  while (++next !&#x3D; last)
  &#123;
    if (comp(*first, *next))  return first;
    first &#x3D; next;
  &#125;
  return last;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; lower_bound
&#x2F;&#x2F; 在[first, last)中查找第一个不小于 value 的元素，并返回指向它的迭代器，若没有则返回 last
&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; lbound_dispatch 的 forward_iterator_tag 版本
template &lt;class ForwardIter, class T&gt;
ForwardIter
lbound_dispatch(ForwardIter first, ForwardIter last,
                const T&amp; value, forward_iterator_tag)
&#123;
  auto len &#x3D; mystl::distance(first, last);
  auto half &#x3D; len;
  ForwardIter middle;
  while (len &gt; 0)
  &#123;
    half &#x3D; len &gt;&gt; 1;
    middle &#x3D; first;
    mystl::advance(middle, half);
    if (*middle &lt; value)
    &#123;
      first &#x3D; middle;
      ++first;
      len &#x3D; len - half - 1;
    &#125;
    else
    &#123;
      len &#x3D; half;
    &#125;
  &#125;
  return first;
&#125;

&#x2F;&#x2F; lbound_dispatch 的 random_access_iterator_tag 版本
template &lt;class RandomIter, class T&gt;
RandomIter
lbound_dispatch(RandomIter first, RandomIter last,
                const T&amp; value, random_access_iterator_tag)
&#123;
  auto len &#x3D; last - first;
  auto half &#x3D; len;
  RandomIter middle;
  while (len &gt; 0)
  &#123;
    half &#x3D; len &gt;&gt; 1;
    middle &#x3D; first + half;
    if (*middle &lt; value)
    &#123;
      first &#x3D; middle + 1;
      len &#x3D; len - half - 1;
    &#125;
    else
    &#123;
      len &#x3D; half;
    &#125;
  &#125;
  return first;
&#125;

template &lt;class ForwardIter, class T&gt;
ForwardIter
lower_bound(ForwardIter first, ForwardIter last, const T&amp; value)
&#123;
  return mystl::lbound_dispatch(first, last, value, iterator_category(first));
&#125;

&#x2F;&#x2F; 重载版本使用函数对象 comp 代替比较操作
&#x2F;&#x2F; lbound_dispatch 的 forward_iterator_tag 版本
template &lt;class ForwardIter, class T, class Compared&gt;
ForwardIter
lbound_dispatch(ForwardIter first, ForwardIter last,
                const T&amp; value, forward_iterator_tag, Compared comp)
&#123;
  auto len &#x3D; mystl::distance(first, last);
  auto half &#x3D; len;
  ForwardIter middle;
  while (len &gt; 0)
  &#123;
    half &#x3D; len &gt;&gt; 1;
    middle &#x3D; first;
    mystl::advance(middle, half);
    if (comp(*middle, value))
    &#123;
      first &#x3D; middle;
      ++first;
      len &#x3D; len - half - 1;
    &#125;
    else
    &#123;
      len &#x3D; half;
    &#125;
  &#125;
  return first;
&#125;

&#x2F;&#x2F; lbound_dispatch 的 random_access_iterator_tag 版本
template &lt;class RandomIter, class T, class Compared&gt;
RandomIter
lbound_dispatch(RandomIter first, RandomIter last,
                const T&amp; value, random_access_iterator_tag, Compared comp)
&#123;
  auto len &#x3D; last - first;
  auto half &#x3D; len;
  RandomIter middle;
  while (len &gt; 0)
  &#123;
    half &#x3D; len &gt;&gt; 1;
    middle &#x3D; first + half;
    if (comp(*middle, value))
    &#123;
      first &#x3D; middle + 1;
      len &#x3D; len - half - 1;
    &#125;
    else
    &#123;
      len &#x3D; half;
    &#125;
  &#125;
  return first;
&#125;

template &lt;class ForwardIter, class T, class Compared&gt;
ForwardIter
lower_bound(ForwardIter first, ForwardIter last, const T&amp; value, Compared comp)
&#123;
  return mystl::lbound_dispatch(first, last, value, iterator_category(first), comp);
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; upper_bound
&#x2F;&#x2F; 在[first, last)中查找第一个大于value 的元素，并返回指向它的迭代器，若没有则返回 last
&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; ubound_dispatch 的 forward_iterator_tag 版本
template &lt;class ForwardIter, class T&gt;
ForwardIter
ubound_dispatch(ForwardIter first, ForwardIter last,
                const T&amp; value, forward_iterator_tag)
&#123;
  auto len &#x3D; mystl::distance(first, last);
  auto half &#x3D; len;
  ForwardIter middle;
  while (len &gt; 0)
  &#123;
    half &#x3D; len &gt;&gt; 1;
    middle &#x3D; first;
    mystl::advance(middle, half);
    if (value &lt; *middle)
    &#123;
      len &#x3D; half;
    &#125;
    else
    &#123;
      first &#x3D; middle;
      ++first;
      len &#x3D; len - half - 1;
    &#125;
  &#125;
  return first;
&#125;

&#x2F;&#x2F; ubound_dispatch 的 random_access_iterator_tag 版本
template &lt;class RandomIter, class T&gt;
RandomIter
ubound_dispatch(RandomIter first, RandomIter last,
                const T&amp; value, random_access_iterator_tag)
&#123;
  auto len &#x3D; last - first;
  auto half &#x3D; len;
  RandomIter middle;
  while (len &gt; 0)
  &#123;
    half &#x3D; len &gt;&gt; 1;
    middle &#x3D; first + half;
    if (value &lt; *middle)
    &#123;
      len &#x3D; half;
    &#125;
    else
    &#123;
      first &#x3D; middle + 1;
      len &#x3D; len - half - 1;
    &#125;
  &#125;
  return first;
&#125;

template &lt;class ForwardIter, class T&gt;
ForwardIter
upper_bound(ForwardIter first, ForwardIter last, const T&amp; value)
&#123;
  return mystl::ubound_dispatch(first, last, value, iterator_category(first));
&#125;

&#x2F;&#x2F; 重载版本使用函数对象 comp 代替比较操作
&#x2F;&#x2F; ubound_dispatch 的 forward_iterator_tag 版本
template &lt;class ForwardIter, class T, class Compared&gt;
ForwardIter
ubound_dispatch(ForwardIter first, ForwardIter last,
                const T&amp; value, forward_iterator_tag, Compared comp)
&#123;
  auto len &#x3D; mystl::distance(first, last);
  auto half &#x3D; len;
  ForwardIter middle;
  while (len &gt; 0)
  &#123;
    half &#x3D; len &gt;&gt; 1;
    middle &#x3D; first;
    mystl::advance(middle, half);
    if (comp(value, *middle))
    &#123;
      len &#x3D; half;
    &#125;
    else
    &#123;
      first &#x3D; middle;
      ++first;
      len &#x3D; len - half - 1;
    &#125;
  &#125;
  return first;
&#125;

&#x2F;&#x2F; ubound_dispatch 的 random_access_iterator_tag 版本
template &lt;class RandomIter, class T, class Compared&gt;
RandomIter
ubound_dispatch(RandomIter first, RandomIter last,
                const T&amp; value, random_access_iterator_tag, Compared comp)
&#123;
  auto len &#x3D; last - first;
  auto half &#x3D; len;
  RandomIter middle;
  while (len &gt; 0)
  &#123;
    half &#x3D; len &gt;&gt; 1;
    middle &#x3D; first + half;
    if (comp(value, *middle))
    &#123;
      len &#x3D; half;
    &#125;
    else
    &#123;
      first &#x3D; middle + 1;
      len &#x3D; len - half - 1;
    &#125;
  &#125;
  return first;
&#125;

template &lt;class ForwardIter, class T, class Compared&gt;
ForwardIter
upper_bound(ForwardIter first, ForwardIter last, const T&amp; value, Compared comp)
&#123;
  return mystl::ubound_dispatch(first, last, value, iterator_category(first), comp);
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; binary_search
&#x2F;&#x2F; 二分查找，如果在[first, last)内有等同于 value 的元素，返回 true，否则返回 false
&#x2F;*****************************************************************************************&#x2F;
template &lt;class ForwardIter, class T&gt;
bool binary_search(ForwardIter first, ForwardIter last, const T&amp; value)
&#123;
  auto i &#x3D; mystl::lower_bound(first, last, value);
  return i !&#x3D; last &amp;&amp; !(value &lt; *i);
&#125;

&#x2F;&#x2F; 重载版本使用函数对象 comp 代替比较操作
template &lt;class ForwardIter, class T, class Compared&gt;
bool binary_search(ForwardIter first, ForwardIter last, const T&amp; value, Compared comp)
&#123;
  auto i &#x3D; mystl::lower_bound(first, last, value);
  return i !&#x3D; last &amp;&amp; !comp(value, *i);
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; equal_range
&#x2F;&#x2F; 查找[first,last)区间中与 value 相等的元素所形成的区间，返回一对迭代器指向区间首尾
&#x2F;&#x2F; 第一个迭代器指向第一个不小于 value 的元素，第二个迭代器指向第一个大于 value 的元素
&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; erange_dispatch 的 forward_iterator_tag 版本
template &lt;class ForwardIter, class T&gt;
mystl::pair&lt;ForwardIter, ForwardIter&gt;
erange_dispatch(ForwardIter first, ForwardIter last,
                const T&amp; value, forward_iterator_tag)
&#123;
  auto len &#x3D; mystl::distance(first, last);
  auto half &#x3D; len;
  ForwardIter middle, left, right;
  while (len &gt; 0)
  &#123;
    half &#x3D; len &gt;&gt; 1;
    middle &#x3D; first;
    mystl::advance(middle, half);
    if (*middle &lt; value)
    &#123;
      first &#x3D; middle;
      ++first;
      len &#x3D; len - half - 1;
    &#125;
    else if (value &lt; *middle)
    &#123;
      len &#x3D; half;
    &#125;
    else
    &#123;
      left &#x3D; mystl::lower_bound(first, last, value);
      mystl::advance(first, len);
      right &#x3D; mystl::upper_bound(++middle, first, value);
      return mystl::pair&lt;ForwardIter, ForwardIter&gt;(left, right);
    &#125;
  &#125;
  return mystl::pair&lt;ForwardIter, ForwardIter&gt;(last, last);
&#125;

&#x2F;&#x2F; erange_dispatch 的 random_access_iterator_tag 版本
template &lt;class RandomIter, class T&gt;
mystl::pair&lt;RandomIter, RandomIter&gt;
erange_dispatch(RandomIter first, RandomIter last,
                const T&amp; value, random_access_iterator_tag)
&#123;
  auto len &#x3D; last - first;
  auto half &#x3D; len;
  RandomIter middle, left, right;
  while (len &gt; 0)
  &#123;
    half &#x3D; len &gt;&gt; 1;
    middle &#x3D; first + half;
    if (*middle &lt; value)
    &#123;
      first &#x3D; middle + 1;
      len &#x3D; len - half - 1;
    &#125;
    else if (value &lt; *middle)
    &#123;
      len &#x3D; half;
    &#125;
    else
    &#123;
      left &#x3D; mystl::lower_bound(first, middle, value);
      right &#x3D; mystl::upper_bound(++middle, first + len, value);
      return mystl::pair&lt;RandomIter, RandomIter&gt;(left, right);
    &#125;
  &#125;
  return mystl::pair&lt;RandomIter, RandomIter&gt;(last, last);
&#125;

template &lt;class ForwardIter, class T&gt;
mystl::pair&lt;ForwardIter, ForwardIter&gt;
equal_range(ForwardIter first, ForwardIter last, const T&amp; value)
&#123;
  return mystl::erange_dispatch(first, last, value, iterator_category(first));
&#125;

&#x2F;&#x2F; 重载版本使用函数对象 comp 代替比较操作
&#x2F;&#x2F; erange_dispatch 的 forward iterator 版本
template &lt;class ForwardIter, class T, class Compared&gt;
mystl::pair&lt;ForwardIter, ForwardIter&gt;
erange_dispatch(ForwardIter first, ForwardIter last,
                const T&amp; value, forward_iterator_tag, Compared comp)
&#123;
  auto len &#x3D; mystl::distance(first, last);
  auto half &#x3D; len;
  ForwardIter middle, left, right;
  while (len &gt; 0)
  &#123;
    half &#x3D; len &gt;&gt; 1;
    middle &#x3D; first;
    mystl::advance(middle, half);
    if (comp(*middle, value))
    &#123;
      first &#x3D; middle;
      ++first;
      len &#x3D; len - half - 1;
    &#125;
    else if (comp(value, *middle))
    &#123;
      len &#x3D; half;
    &#125;
    else
    &#123;
      left &#x3D; mystl::lower_bound(first, last, value, comp);
      mystl::advance(first, len);
      right &#x3D; mystl::upper_bound(++middle, first, value, comp);
      return mystl::pair&lt;ForwardIter, ForwardIter&gt;(left, right);
    &#125;
  &#125;
  return mystl::pair&lt;ForwardIter, ForwardIter&gt;(last, last);
&#125;

&#x2F;&#x2F; erange_dispatch 的 random access iterator 版本
template &lt;class RandomIter, class T, class Compared&gt;
mystl::pair&lt;RandomIter, RandomIter&gt;
erange_dispatch(RandomIter first, RandomIter last,
                const T&amp; value, random_access_iterator_tag, Compared comp)
&#123;
  auto len &#x3D; last - first;
  auto half &#x3D; len;
  RandomIter middle, left, right;
  while (len &gt; 0)
  &#123;
    half &#x3D; len &gt;&gt; 1;
    middle &#x3D; first + half;
    if (comp(*middle, value))
    &#123;
      first &#x3D; middle + 1;
      len &#x3D; len - half - 1;
    &#125;
    else if (comp(value, *middle))
    &#123;
      len &#x3D; half;
    &#125;
    else
    &#123;
      left &#x3D; mystl::lower_bound(first, middle, value, comp);
      right &#x3D; mystl::upper_bound(++middle, first + len, value, comp);
      return mystl::pair&lt;RandomIter, RandomIter&gt;(left, right);
    &#125;
  &#125;
  return mystl::pair&lt;RandomIter, RandomIter&gt;(last, last);
&#125;

template &lt;class ForwardIter, class T, class Compared&gt;
mystl::pair&lt;ForwardIter, ForwardIter&gt;
equal_range(ForwardIter first, ForwardIter last, const T&amp; value, Compared comp)
&#123;
  return mystl::erange_dispatch(first, last, value, iterator_category(first), comp);
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; generate
&#x2F;&#x2F; 将函数对象 gen 的运算结果对[first, last)内的每个元素赋值
&#x2F;*****************************************************************************************&#x2F;
template &lt;class ForwardIter, class Generator&gt;
void generate(ForwardIter first, ForwardIter last, Generator gen)
&#123;
  for (; first !&#x3D; last; ++first)
  &#123;
    *first &#x3D; gen();
  &#125;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; generate_n
&#x2F;&#x2F; 用函数对象 gen 连续对 n 个元素赋值
&#x2F;*****************************************************************************************&#x2F;
template &lt;class ForwardIter, class Size, class Generator&gt;
void generate_n(ForwardIter first, Size n, Generator gen)
&#123;
  for (; n &gt; 0; --n, ++first)
  &#123;
    *first &#x3D; gen();
  &#125;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; includes
&#x2F;&#x2F; 判断序列一S1 是否包含序列二S2
&#x2F;*****************************************************************************************&#x2F;
template &lt;class InputIter1, class InputIter2&gt;
bool includes(InputIter1 first1, InputIter1 last1,
              InputIter2 first2, InputIter2 last2)
&#123;
  while (first1 !&#x3D; last1 &amp;&amp; first2 !&#x3D; last2)
  &#123;
    if (*first2 &lt; *first1)
    &#123;
      return false;
    &#125;
    else if (*first1 &lt; *first2)
    &#123;
      ++first1;
    &#125;
    else
    &#123;
      ++first1, ++first2;
    &#125;
  &#125;
  return first2 &#x3D;&#x3D; last2;
&#125;

&#x2F;&#x2F; 重载版本使用函数对象 comp 代替比较操作
template &lt;class InputIter1, class InputIter2, class Compared&gt;
bool includes(InputIter1 first1, InputIter1 last1,
              InputIter2 first2, InputIter2 last2, Compared comp)
&#123;
  while (first1 !&#x3D; last1 &amp;&amp; first2 !&#x3D; last2)
  &#123;
    if (comp(*first2, *first1))
    &#123;
      return false;
    &#125;
    else if (comp(*first1, *first2))
    &#123;
      ++first1;
    &#125;
    else
    &#123;
      ++first1, ++first2;
    &#125;
  &#125;
  return first2 &#x3D;&#x3D; last2;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; is_heap
&#x2F;&#x2F; 检查[first, last)内的元素是否为一个堆，如果是，则返回 true
&#x2F;*****************************************************************************************&#x2F;
template &lt;class RandomIter&gt;
bool is_heap(RandomIter first, RandomIter last)
&#123;
  auto n &#x3D; mystl::distance(first, last);
  auto parent &#x3D; 0;
  for (auto child &#x3D; 1; child &lt; n; ++child)
  &#123;
    if (first[parent] &lt; first[child])
      return false;
    if ((child &amp; 1) &#x3D;&#x3D; 0)
      ++parent;
  &#125;
  return true;
&#125;

&#x2F;&#x2F; 重载版本使用函数对象 comp 代替比较操作
template &lt;class RandomIter, class Compared&gt;
bool is_heap(RandomIter first, RandomIter last, Compared comp)
&#123;
  auto n &#x3D; mystl::distance(first, last);
  auto parent &#x3D; 0;
  for (auto child &#x3D; 1; child &lt; n; ++child)
  &#123;
    if (comp(first[parent], first[child]))
      return false;
    if ((child &amp; 1) &#x3D;&#x3D; 0)
      ++parent;
  &#125;
  return true;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; is_sorted
&#x2F;&#x2F; 检查[first, last)内的元素是否升序，如果是升序，则返回 true
&#x2F;*****************************************************************************************&#x2F;
template &lt;class ForwardIter&gt;
bool is_sorted(ForwardIter first, ForwardIter last)
&#123;
  if (first &#x3D;&#x3D; last)
    return true;
  auto next &#x3D; first;
  ++next;
  for (; next !&#x3D; last; first &#x3D; next, ++next)
  &#123;
    if (*next &lt; *first)
      return false;
  &#125;
  return true;
&#125;

&#x2F;&#x2F; 重载版本使用函数对象 comp 代替比较操作
template &lt;class ForwardIter, class Compared&gt;
bool is_sorted(ForwardIter first, ForwardIter last, Compared comp)
&#123;
  if (first &#x3D;&#x3D; last)
    return true;
  auto next &#x3D; first;
  ++next;
  for (; next !&#x3D; last; first &#x3D; next, ++next)
  &#123;
    if (comp(*next, *first))
      return false;
  &#125;
  return true;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; median
&#x2F;&#x2F; 找出三个值的中间值
&#x2F;*****************************************************************************************&#x2F;
template &lt;class T&gt;
const T&amp; median(const T&amp; left, const T&amp; mid, const T&amp; right)
&#123;
  if (left &lt; mid)
    if (mid &lt; right)        &#x2F;&#x2F; left &lt; mid &lt; right
      return mid;
    else if (left &lt; right)  &#x2F;&#x2F; left &lt; right &lt;&#x3D; mid
      return right;
    else                    &#x2F;&#x2F; right &lt;&#x3D; left &lt; mid
      return left;
  else if (left &lt; right)      &#x2F;&#x2F; mid &lt;&#x3D; left &lt; right
    return left;
  else if (mid &lt; right)       &#x2F;&#x2F; mid &lt; right &lt;&#x3D; left
    return right;
  else                        &#x2F;&#x2F; right &lt;&#x3D; mid &lt;&#x3D; left
    return mid;
&#125;

&#x2F;&#x2F; 重载版本使用函数对象 comp 代替比较操作
template &lt;class T, class Compared&gt;
const T&amp; median(const T&amp; left, const T&amp; mid, const T&amp; right, Compared comp)
&#123;
  if (comp(left, mid))
    if (comp(mid, right))
      return mid;
    else if (comp(left, right))
      return right;
    else
      return left;
  else if (comp(left, right))
    return left;
  else if (comp(mid, right))
    return right;
  else
    return mid;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; max_element
&#x2F;&#x2F; 返回一个迭代器，指向序列中最大的元素
&#x2F;*****************************************************************************************&#x2F;
template &lt;class ForwardIter&gt;
ForwardIter max_element(ForwardIter first, ForwardIter last)
&#123;
  if (first &#x3D;&#x3D; last)
    return first;
  auto result &#x3D; first;
  while (++first !&#x3D; last)
  &#123;
    if (*result &lt; *first)
      result &#x3D; first;
  &#125;
  return result;
&#125;

&#x2F;&#x2F; 重载版本使用函数对象 comp 代替比较操作
template &lt;class ForwardIter, class Compared&gt;
ForwardIter max_element(ForwardIter first, ForwardIter last, Compared comp)
&#123;
  if (first &#x3D;&#x3D; last)
    return first;
  auto result &#x3D; first;
  while (++first !&#x3D; last)
  &#123;
    if (comp(*result, *first))
      result &#x3D; first;
  &#125;
  return result;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; min_element
&#x2F;&#x2F; 返回一个迭代器，指向序列中最小的元素
&#x2F;*****************************************************************************************&#x2F;
template &lt;class ForwardIter&gt;
ForwardIter min_elememt(ForwardIter first, ForwardIter last)
&#123;
  if (first &#x3D;&#x3D; last)
    return first;
  auto result &#x3D; first;
  while (++first !&#x3D; last)
  &#123;
    if (*first &lt; *result)
      result &#x3D; first;
  &#125;
  return result;
&#125;

&#x2F;&#x2F; 重载版本使用函数对象 comp 代替比较操作
template &lt;class ForwardIter, class Compared&gt;
ForwardIter min_elememt(ForwardIter first, ForwardIter last, Compared comp)
&#123;
  if (first &#x3D;&#x3D; last)
    return first;
  auto result &#x3D; first;
  while (++first !&#x3D; last)
  &#123;
    if (comp(*first, *result))
      result &#x3D; first;
  &#125;
  return result;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; swap_ranges
&#x2F;&#x2F; 将[first1, last1)从 first2 开始，交换相同个数元素
&#x2F;&#x2F; 交换的区间长度必须相同，两个序列不能互相重叠，返回一个迭代器指向序列二最后一个被交换元素的下一位置
&#x2F;*****************************************************************************************&#x2F;
template &lt;class ForwardIter1, class ForwardIter2&gt;
ForwardIter2
swap_ranges(ForwardIter1 first1, ForwardIter1 last1,
            ForwardIter2 first2)
&#123;
  for (; first1 !&#x3D; last1; ++first1, ++first2)
  &#123;
    mystl::iter_swap(first1, first2);
  &#125;
  return first2;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; transform
&#x2F;&#x2F; 第一个版本以函数对象 unary_op 作用于[first, last)中的每个元素并将结果保存至 result 中
&#x2F;&#x2F; 第二个版本以函数对象 binary_op 作用于两个序列[first1, last1)、[first2, last2)的相同位置
&#x2F;*****************************************************************************************&#x2F;
template &lt;class InputIter, class OutputIter, class UnaryOperation&gt;
OutputIter
transform(InputIter first, InputIter last,
          OutputIter result, UnaryOperation unary_op)
&#123;
  for (; first !&#x3D; last; ++first, ++result)
  &#123;
    *result &#x3D; unary_op(*first);
  &#125;
  return result;
&#125;

template &lt;class InputIter1, class InputIter2, class OutputIter, class BinaryOperation&gt;
OutputIter
transform(InputIter1 first1, InputIter1 last1,
          InputIter2 first2, OutputIter result, BinaryOperation binary_op)
&#123;
  for (; first1 !&#x3D; last1; ++first1, ++first2, ++result)
  &#123;
    *result &#x3D; binary_op(*first1, *first2);
  &#125;
  return result;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; remove_copy
&#x2F;&#x2F; 移除区间内与指定 value 相等的元素，并将结果复制到以 result 标示起始位置的容器上
&#x2F;*****************************************************************************************&#x2F;
template &lt;class InputIter, class OutputIter, class T&gt;
OutputIter
remove_copy(InputIter first, InputIter last, OutputIter result, const T&amp; value)
&#123;
  for (; first !&#x3D; last; ++first)
  &#123;
    if (*first !&#x3D; value)
    &#123;
      *result++ &#x3D; *first;
    &#125;
  &#125;
  return result;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; remove
&#x2F;&#x2F; 移除所有与指定 value 相等的元素
&#x2F;&#x2F; 并不从容器中删除这些元素，所以 remove 和 remove_if 不适用于 array
&#x2F;*****************************************************************************************&#x2F;
template &lt;class ForwardIter, class T&gt;
ForwardIter remove(ForwardIter first, ForwardIter last, const T&amp; value)
&#123;
  first &#x3D; mystl::find(first, last, value);  &#x2F;&#x2F; 利用 find 找出第一个匹配的地方
  auto next &#x3D; first;
  return first &#x3D;&#x3D; last ? first : mystl::remove_copy(++next, last, first, value);
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; remove_copy_if
&#x2F;&#x2F; 移除区间内所有令一元操作 unary_pred 为 true 的元素，并将结果复制到以 result 为起始位置的容器上
&#x2F;*****************************************************************************************&#x2F;
template &lt;class InputIter, class OutputIter, class UnaryPredicate&gt;
OutputIter
remove_copy_if(InputIter first, InputIter last,
               OutputIter result, UnaryPredicate unary_pred)
&#123;
  for (; first !&#x3D; last; ++first)
  &#123;
    if (!unary_pred(*first))
    &#123;
      *result &#x3D; *first;
      ++result;
    &#125;
  &#125;
  return result;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; remove_if
&#x2F;&#x2F; 移除区间内所有令一元操作 unary_pred 为 true 的元素
&#x2F;*****************************************************************************************&#x2F;
template &lt;class ForwardIter, class UnaryPredicate&gt;
ForwardIter
remove_if(ForwardIter first, ForwardIter last, UnaryPredicate unary_pred)
&#123;
  first &#x3D; mystl::find_if(first, last, unary_pred);  &#x2F;&#x2F; 利用 find_if 找出第一个匹配的地方
  auto next &#x3D; first;
  return first &#x3D;&#x3D; last ? first : mystl::remove_copy_if(++next, last, first, unary_pred);
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; replace
&#x2F;&#x2F; 将区间内所有的 old_value 都以 new_value 替代
&#x2F;*****************************************************************************************&#x2F;
template &lt;class ForwardIter, class T&gt;
void replace(ForwardIter first, ForwardIter last,
             const T&amp; old_value, const T&amp; new_value)
&#123;
  for (; first !&#x3D; last; ++first)
  &#123;
    if (*first &#x3D;&#x3D; old_value)
      *first &#x3D; new_value;
  &#125;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; replace_copy
&#x2F;&#x2F; 行为与 replace 类似，不同的是将结果复制到 result 所指的容器中，原序列没有改变
&#x2F;*****************************************************************************************&#x2F;
template &lt;class InputIter, class OutputIter, class T&gt;
OutputIter
replace_copy(InputIter first, InputIter last,
             OutputIter result, const T&amp; old_value, const T&amp; new_value)
&#123;
  for (; first !&#x3D; last; ++first, ++result)
  &#123;
    *result &#x3D; *first &#x3D;&#x3D; old_value ? new_value : *first;
  &#125;
  return result;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; replace_copy_if
&#x2F;&#x2F; 行为与 replace_if 类似，不同的是将结果复制到 result 所指的容器中，原序列没有改变
&#x2F;*****************************************************************************************&#x2F;
template &lt;class InputIter, class OutputIter, class UnaryPredicate, class T&gt;
OutputIter
replace_copy_if(InputIter first, InputIter last,
                OutputIter result, UnaryPredicate unary_pred, const T&amp; new_value)
&#123;
  for (; first !&#x3D; last; ++first, ++result)
  &#123;
    *result &#x3D; unary_pred(*first) ? new_value : *first;
  &#125;
  return result;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; replace_if
&#x2F;&#x2F; 将区间内所有令一元操作 unary_pred 为 true 的元素都用 new_value 替代
&#x2F;*****************************************************************************************&#x2F;
template &lt;class ForwardIter, class UnaryPredicate, class T&gt;
void replace_if(ForwardIter first, ForwardIter last,
                UnaryPredicate unary_pred, const T&amp; new_value)
&#123;
  for (; first !&#x3D; last; ++first)
  &#123;
    if (unary_pred(*first))
      *first &#x3D; new_value;
  &#125;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; reverse
&#x2F;&#x2F; 将[first, last)区间内的元素反转
&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; reverse_dispatch 的 bidirectional_iterator_tag 版本
template &lt;class BidirectionalIter&gt;
void reverse_dispatch(BidirectionalIter first, BidirectionalIter last,
                      bidirectional_iterator_tag)
&#123;
  while (true)
  &#123;
    if (first &#x3D;&#x3D; last || first &#x3D;&#x3D; --last)
      return;
    mystl::iter_swap(first++, last);
  &#125;
&#125;

&#x2F;&#x2F; reverse_dispatch 的 random_access_iterator_tag 版本
template &lt;class RandomIter&gt;
void reverse_dispatch(RandomIter first, RandomIter last,
                      random_access_iterator_tag)
&#123;
  while (first &lt; last)
    mystl::iter_swap(first++, --last);
&#125;

template &lt;class BidirectionalIter&gt;
void reverse(BidirectionalIter first, BidirectionalIter last)
&#123;
  mystl::reverse_dispatch(first, last, iterator_category(first));
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; reverse_copy
&#x2F;&#x2F; 行为与 reverse 类似，不同的是将结果复制到 result 所指容器中
&#x2F;*****************************************************************************************&#x2F;
template &lt;class BidirectionalIter, class OutputIter&gt;
OutputIter
reverse_copy(BidirectionalIter first, BidirectionalIter last,
             OutputIter result)
&#123;
  while (first !&#x3D; last)
  &#123;
    --last;
    *result &#x3D; *last;
    ++result;
  &#125;
  return result;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; random_shuffle
&#x2F;&#x2F; 将[first, last)内的元素次序随机重排
&#x2F;&#x2F; 重载版本使用一个产生随机数的函数对象 rand
&#x2F;*****************************************************************************************&#x2F;
template &lt;class RandomIter&gt;
void random_shuffle(RandomIter first, RandomIter last)
&#123;
  if (first &#x3D;&#x3D; last)
    return;
  srand((unsigned)time(0));
  for (auto i &#x3D; first + 1; i !&#x3D; last; ++i)
  &#123;
    mystl::iter_swap(i, first + (rand() % (i - first + 1)));
  &#125;
&#125;

&#x2F;&#x2F; 重载版本使用一个产生随机数的函数对象 rand
template &lt;class RandomIter, class RandomNumberGenerator&gt;
void random_shuffle(RandomIter first, RandomIter last,
                    RandomNumberGenerator&amp; rand)
&#123;
  if (first &#x3D;&#x3D; last)
    return;
  auto len &#x3D; mystl::distance(first, last);
  for (auto i &#x3D; first + 1; i !&#x3D; last; ++i)
  &#123;
    mystl::iter_swap(i, first + (rand(i - first + 1) % len));
  &#125;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; rotate
&#x2F;&#x2F; 将[first, middle)内的元素和 [middle, last)内的元素互换，可以交换两个长度不同的区间
&#x2F;&#x2F; 返回交换后 middle 的位置
&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; rotate_dispatch 的 forward_iterator_tag 版本
template &lt;class ForwardIter&gt;
ForwardIter
rotate_dispatch(ForwardIter first, ForwardIter middle,
                ForwardIter last, forward_iterator_tag)
&#123;
  auto first2 &#x3D; middle;
  do
  &#123;
    mystl::swap(*first++, *first2++);
    if (first &#x3D;&#x3D; middle)
      middle &#x3D; first2;
  &#125; while (first2 !&#x3D; last);  &#x2F;&#x2F; 后半段移到前面

  auto new_middle &#x3D; first;   &#x2F;&#x2F; 迭代器返回的位置
  first2 &#x3D; middle;
  while (first2 !&#x3D; last)
  &#123;   &#x2F;&#x2F; 调整剩余元素
    mystl::swap(*first++, *first2++);
    if (first &#x3D;&#x3D; middle)
    &#123;
      middle &#x3D; first2;
    &#125;
    else if (first2 &#x3D;&#x3D; last)
    &#123;
      first2 &#x3D; middle;
    &#125;
  &#125;
  return new_middle;
&#125;

&#x2F;&#x2F; rotate_dispatch 的 bidirectional_iterator_tag 版本
template &lt;class BidirectionalIter&gt;
BidirectionalIter
rotate_dispatch(BidirectionalIter first, BidirectionalIter middle,
                BidirectionalIter last, bidirectional_iterator_tag)
&#123;
  mystl::reverse_dispatch(first, middle, bidirectional_iterator_tag());
  mystl::reverse_dispatch(middle, last, bidirectional_iterator_tag());
  while (first !&#x3D; middle &amp;&amp; middle !&#x3D; last)
    mystl::swap(*first++, *--last);
  if (first &#x3D;&#x3D; middle)
  &#123;
    mystl::reverse_dispatch(middle, last, bidirectional_iterator_tag());
    return last;
  &#125;
  else
  &#123;
    mystl::reverse_dispatch(first, middle, bidirectional_iterator_tag());
    return first;
  &#125;
&#125;

&#x2F;&#x2F; 求最大公因子
template &lt;class EuclideanRingElement&gt;
EuclideanRingElement rgcd(EuclideanRingElement m, EuclideanRingElement n)
&#123;
  while (n !&#x3D; 0)
  &#123;
    auto t &#x3D; m % n;
    m &#x3D; n;
    n &#x3D; t;
  &#125;
  return m;
&#125;

&#x2F;&#x2F; rotate_dispatch 的 random_access_iterator_tag 版本
template &lt;class RandomIter&gt;
RandomIter
rotate_dispatch(RandomIter first, RandomIter middle,
                RandomIter last, random_access_iterator_tag)
&#123;
  &#x2F;&#x2F; 因为是 random access iterator，我们可以确定每个元素的位置
  auto n &#x3D; last - first;
  auto l &#x3D; middle - first;
  auto r &#x3D; n - l;
  auto result &#x3D; first + (last - middle);
  if (l &#x3D;&#x3D; r)
  &#123;
    mystl::swap_ranges(first, middle, middle);
    return result;
  &#125;
  auto cycle_times &#x3D; rgcd(n, l);
  for (auto i &#x3D; 0; i &lt; cycle_times; ++i)
  &#123;
    auto tmp &#x3D; *first;
    auto p &#x3D; first;
    if (l &lt; r)
    &#123;
      for (auto j &#x3D; 0; j &lt; r &#x2F; cycle_times; ++j)
      &#123;
        if (p &gt; first + r)
        &#123;
          *p &#x3D; *(p - r);
          p -&#x3D; r;
        &#125;
        *p &#x3D; *(p + l);
        p +&#x3D; l;
      &#125;
    &#125;
    else
    &#123;
      for (auto j &#x3D; 0; j &lt; l &#x2F; cycle_times - 1; ++j)
      &#123;
        if (p &lt; last - l)
        &#123;
          *p &#x3D; *(p + l);
          p +&#x3D; l;
        &#125;
        *p &#x3D; *(p - r);
        p -&#x3D; r;
      &#125;
    &#125;
    *p &#x3D; tmp;
    ++first;
  &#125;
  return result;
&#125;

template &lt;class ForwardIter&gt;
ForwardIter
rotate(ForwardIter first, ForwardIter middle, ForwardIter last)
&#123;
  if (first &#x3D;&#x3D; middle)
    return last;
  if (middle &#x3D;&#x3D; last)
    return first;
  return mystl::rotate_dispatch(first, middle, last, iterator_category(first));
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; rotate_copy
&#x2F;&#x2F; 行为与 rotate 类似，不同的是将结果复制到 result 所指的容器中
&#x2F;*****************************************************************************************&#x2F;
template &lt;class ForwardIter, class OutputIter&gt;
ForwardIter
rotate_copy(ForwardIter first, ForwardIter middle,
            ForwardIter last, OutputIter result)
&#123;
  return mystl::copy(first, middle, mystl::copy(middle, last, result));
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; is_permutation
&#x2F;&#x2F; 判断[first1,last1)是否为[first2, last2)的排列组合
&#x2F;*****************************************************************************************&#x2F;
template &lt;class ForwardIter1, class ForwardIter2, class BinaryPred&gt;
bool is_permutation_aux(ForwardIter1 first1, ForwardIter1 last1,
                        ForwardIter2 first2, ForwardIter2 last2,
                        BinaryPred pred)
&#123;
  constexpr bool is_ra_it &#x3D; mystl::is_random_access_iterator&lt;ForwardIter1&gt;::value
    &amp;&amp; mystl::is_random_access_iterator&lt;ForwardIter2&gt;::value;
  if (is_ra_it)
  &#123;
    auto len1 &#x3D; last1 - first1;
    auto len2 &#x3D; last2 - first2;
    if (len1 !&#x3D; len2)
      return false;
  &#125;

  &#x2F;&#x2F; 先找出相同的前缀段
  for (; first1 !&#x3D; last1 &amp;&amp; first2 !&#x3D; last2; ++first1, (void) ++first2)
  &#123;
    if (!pred(*first1, *first2))
      break;
  &#125;
  if (is_ra_it)
  &#123;
    if (first1 &#x3D;&#x3D; last1)
      return true;
  &#125;
  else
  &#123;
    auto len1 &#x3D; mystl::distance(first1, last1);
    auto len2 &#x3D; mystl::distance(first2, last2);
    if (len1 &#x3D;&#x3D; 0 &amp;&amp; len2 &#x3D;&#x3D; 0)
      return true;
    if (len1 !&#x3D; len2)
      return false;
  &#125;

  &#x2F;&#x2F; 判断剩余部分
  for (auto i &#x3D; first1; i !&#x3D; last1; ++i)
  &#123;
    bool is_repeated &#x3D; false;
    for (auto j &#x3D; first1; j !&#x3D; i; ++j)
    &#123;
      if (pred(*j, *i))
      &#123;
        is_repeated &#x3D; true;
        break;
      &#125;
    &#125;

    if (!is_repeated)
    &#123;
      &#x2F;&#x2F; 计算 *i 在 [first2, last2) 的数目
      auto c2 &#x3D; 0;
      for (auto j &#x3D; first2; j !&#x3D; last2; ++j)
      &#123;
        if (pred(*i, *j))
          ++c2;
      &#125;
      if (c2 &#x3D;&#x3D; 0)
        return false;

      &#x2F;&#x2F; 计算 *i 在 [first1, last1) 的数目
      auto c1 &#x3D; 1;
      auto j &#x3D; i;
      for (++j; j !&#x3D; last1; ++j)
      &#123;
        if (pred(*i, *j))
          ++c1;
      &#125;
      if (c1 !&#x3D; c2)
        return false;
    &#125;
  &#125;
  return true;
&#125;

template &lt;class ForwardIter1, class ForwardIter2, class BinaryPred&gt;
bool is_permutation(ForwardIter1 first1, ForwardIter1 last1,
                    ForwardIter2 first2, ForwardIter2 last2,
                    BinaryPred pred)
&#123;
  return is_permutation_aux(first1, last1, first2, last2, pred);
&#125;

template &lt;class ForwardIter1, class ForwardIter2&gt;
bool is_permutation(ForwardIter1 first1, ForwardIter1 last1,
                    ForwardIter2 first2, ForwardIter2 last2)
&#123;
  typedef typename iterator_traits&lt;ForwardIter1&gt;::value_type v1;
  typedef typename iterator_traits&lt;ForwardIter2&gt;::value_type v2;
  static_assert(std::is_same&lt;v1, v2&gt;::value,
                &quot;the type should be same in mystl::is_permutation&quot;);
  return is_permutation_aux(first1, last1, first2, last2,
                            mystl::equal_to&lt;v1&gt;());
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; next_permutation
&#x2F;&#x2F; 取得[first, last)所标示序列的下一个排列组合，如果没有下一个排序组合，返回 false，否则返回 true
&#x2F;*****************************************************************************************&#x2F;
template &lt;class BidirectionalIter&gt;
bool next_permutation(BidirectionalIter first, BidirectionalIter last)
&#123;
  auto i &#x3D; last;
  if (first &#x3D;&#x3D; last || first &#x3D;&#x3D; --i)
    return false;
  for (;;)
  &#123;
    auto ii &#x3D; i;
    if (*--i &lt; *ii)
    &#123;                 &#x2F;&#x2F; 找到第一对小于关系的元素
      auto j &#x3D; last;
      while (!(*i &lt; *--j)) &#123;&#125;
      mystl::iter_swap(i, j);       &#x2F;&#x2F; 交换 i，j 所指元素
      mystl::reverse(ii, last);     &#x2F;&#x2F; 将 ii 之后的所有元素反转
      return true;
    &#125;
    if (i &#x3D;&#x3D; first)
    &#123;
      mystl::reverse(first, last);
      return false;
    &#125;
  &#125;
&#125;

&#x2F;&#x2F; 重载版本使用函数对象 comp 代替比较操作
template &lt;class BidirectionalIter, class Compared&gt;
bool next_permutation(BidirectionalIter first, BidirectionalIter last, Compared comp)
&#123;
  auto i &#x3D; last;
  if (first &#x3D;&#x3D; last || first &#x3D;&#x3D; --i)
    return false;
  for (;;)
  &#123;
    auto ii &#x3D; i;
    if (comp(*--i, *ii))
    &#123;
      auto j &#x3D; last;
      while (!comp(*i, *--j)) &#123;&#125;
      mystl::iter_swap(i, j);       &#x2F;&#x2F; 交换 i，j 所指元素
      mystl::reverse(ii, last);     &#x2F;&#x2F; 将 ii 之后的所有元素反转
      return true;
    &#125;
    if (i &#x3D;&#x3D; first)
    &#123;
      mystl::reverse(first, last);
      return false;
    &#125;
  &#125;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; prev_permutation
&#x2F;&#x2F; 取得[first, last)所标示序列的上一个排列组合，如果没有上一个排序组合，返回 false，否则返回 true
&#x2F;*****************************************************************************************&#x2F;
template &lt;class BidirectionalIter&gt;
bool prev_permutation(BidirectionalIter first, BidirectionalIter last)
&#123;
  auto i &#x3D; last;
  if (first &#x3D;&#x3D; last || first &#x3D;&#x3D; --i)
    return false;
  for (;;)
  &#123;
    auto ii &#x3D; i;
    if (*ii &lt; *--i)
    &#123;                 &#x2F;&#x2F; 找到第一对大于关系的元素
      auto j &#x3D; last;
      while (!(*--j &lt; *i)) &#123;&#125;
      mystl::iter_swap(i, j);       &#x2F;&#x2F; 交换i，j
      mystl::reverse(ii, last);     &#x2F;&#x2F; 将 ii 之后的所有元素反转
      return true;
    &#125;
    if (i &#x3D;&#x3D; first)
    &#123;
      mystl::reverse(first, last);
      return false;
    &#125;
  &#125;
&#125;

&#x2F;&#x2F; 重载版本使用函数对象 comp 代替比较操作
template &lt;class BidirectionalIter, class Compared&gt;
bool prev_permutation(BidirectionalIter first, BidirectionalIter last, Compared comp)
&#123;
  auto i &#x3D; last;
  if (first &#x3D;&#x3D; last || first &#x3D;&#x3D; --i)
    return false;
  for (;;)
  &#123;
    auto ii &#x3D; i;
    if (comp(*ii, *--i))
    &#123;
      auto j &#x3D; last;
      while (!comp(*--j, *i)) &#123;&#125;
      mystl::iter_swap(i, j);       &#x2F;&#x2F; 交换i，j
      mystl::reverse(ii, last);     &#x2F;&#x2F; 将 ii 之后的所有元素反转
      return true;
    &#125;
    if (i &#x3D;&#x3D; first)
    &#123;
      mystl::reverse(first, last);
      return false;
    &#125;
  &#125;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; merge
&#x2F;&#x2F; 将两个经过排序的集合 S1 和 S2 合并起来置于另一段空间，返回一个迭代器指向最后一个元素的下一位置
&#x2F;*****************************************************************************************&#x2F;
template &lt;class InputIter1, class InputIter2, class OutputIter&gt;
OutputIter
merge(InputIter1 first1, InputIter1 last1,
      InputIter2 first2, InputIter2 last2,
      OutputIter result)
&#123;
  while (first1 !&#x3D; last1 &amp;&amp; first2 !&#x3D; last2)
  &#123;
    if (*first2 &lt; *first1)
    &#123;
      *result &#x3D; *first2;
      ++first2;
    &#125;
    else
    &#123;
      *result &#x3D; *first1;
      ++first1;
    &#125;
    ++result;
  &#125;
  return mystl::copy(first2, last2, mystl::copy(first1, last1, result));
&#125;

&#x2F;&#x2F; 重载版本使用函数对象 comp 代替比较操作
template &lt;class InputIter1, class InputIter2, class OutputIter, class Compared&gt;
OutputIter
merge(InputIter1 first1, InputIter1 last1,
      InputIter2 first2, InputIter2 last2,
      OutputIter result, Compared comp)
&#123;
  while (first1 !&#x3D; last1 &amp;&amp; first2 !&#x3D; last2)
  &#123;
    if (comp(*first2, *first1))
    &#123;
      *result &#x3D; *first2;
      ++first2;
    &#125;
    else
    &#123;
      *result &#x3D; *first1;
      ++first1;
    &#125;
    ++result;
  &#125;
  return mystl::copy(first2, last2, mystl::copy(first1, last1, result));
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; inplace_merge
&#x2F;&#x2F; 把连接在一起的两个有序序列结合成单一序列并保持有序
&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; 没有缓冲区的情况下合并
template &lt;class BidirectionalIter, class Distance&gt;
void merge_without_buffer(BidirectionalIter first, BidirectionalIter middle,
                          BidirectionalIter last, Distance len1, Distance len2)
&#123;
  if (len1 &#x3D;&#x3D; 0 || len2 &#x3D;&#x3D; 0)
    return;
  if (len1 + len2 &#x3D;&#x3D; 2)
  &#123;
    if (*middle &lt; *first)
      mystl::iter_swap(first, middle);
    return;
  &#125;
  auto first_cut &#x3D; first;
  auto second_cut &#x3D; middle;
  Distance len11 &#x3D; 0;
  Distance len22 &#x3D; 0;
  if (len1 &gt; len2)
  &#123;  &#x2F;&#x2F; 序列一较长，找到序列一的中点
    len11 &#x3D; len1 &gt;&gt; 1;
    mystl::advance(first_cut, len11);
    second_cut &#x3D; mystl::lower_bound(middle, last, *first_cut);
    len22 &#x3D; mystl::distance(middle, second_cut);
  &#125;
  else
  &#123;              &#x2F;&#x2F; 序列二较长，找到序列二的中点
    len22 &#x3D; len2 &gt;&gt; 1;
    mystl::advance(second_cut, len22);
    first_cut &#x3D; mystl::upper_bound(first, middle, *second_cut);
    len11 &#x3D; mystl::distance(first, first_cut);
  &#125;
  auto new_middle &#x3D; mystl::rotate(first_cut, middle, second_cut);
  mystl::merge_without_buffer(first, first_cut, new_middle, len11, len22);
  mystl::merge_without_buffer(new_middle, second_cut, last, len1 - len11, len2 - len22);
&#125;

template &lt;class BidirectionalIter1, class BidirectionalIter2&gt;
BidirectionalIter1
merge_backward(BidirectionalIter1 first1, BidirectionalIter1 last1,
               BidirectionalIter2 first2, BidirectionalIter2 last2,
               BidirectionalIter1 result)
&#123;
  if (first1 &#x3D;&#x3D; last1)
    return mystl::copy_backward(first2, last2, result);
  if (first2 &#x3D;&#x3D; last2)
    return mystl::copy_backward(first1, last1, result);
  --last1;
  --last2;
  while (true)
  &#123;
    if (*last2 &lt; *last1)
    &#123;
      *--result &#x3D; *last1;
      if (first1 &#x3D;&#x3D; last1)
        return mystl::copy_backward(first2, ++last2, result);
      --last1;
    &#125;
    else
    &#123;
      *--result &#x3D; *last2;
      if (first2 &#x3D;&#x3D; last2)
        return mystl::copy_backward(first1, ++last1, result);
      --last2;
    &#125;
  &#125;
&#125;

template &lt;class BidirectionalIter1, class BidirectionalIter2, class Distance&gt;
BidirectionalIter1
rotate_adaptive(BidirectionalIter1 first, BidirectionalIter1 middle,
                BidirectionalIter1 last, Distance len1, Distance len2,
                BidirectionalIter2 buffer, Distance buffer_size)
&#123;
  BidirectionalIter2 buffer_end;
  if (len1 &gt; len2 &amp;&amp; len2 &lt;&#x3D; buffer_size)
  &#123;
    buffer_end &#x3D; mystl::copy(middle, last, buffer);
    mystl::copy_backward(first, middle, last);
    return mystl::copy(buffer, buffer_end, first);
  &#125;
  else if (len1 &lt;&#x3D; buffer_size)
  &#123;
    buffer_end &#x3D; mystl::copy(first, middle, buffer);
    mystl::copy(middle, last, first);
    return mystl::copy_backward(buffer, buffer_end, last);
  &#125;
  else
  &#123;
    return mystl::rotate(first, middle, last);
  &#125;
&#125;

&#x2F;&#x2F; 有缓冲区的情况下合并
template &lt;class BidirectionalIter, class Distance, class Pointer&gt;
void merge_adaptive(BidirectionalIter first, BidirectionalIter middle,
                    BidirectionalIter last, Distance len1, Distance len2,
                    Pointer buffer, Distance buffer_size)
&#123;
  &#x2F;&#x2F; 区间长度足够放进缓冲区
  if (len1 &lt;&#x3D; len2 &amp;&amp; len1 &lt;&#x3D; buffer_size)
  &#123;
    Pointer buffer_end &#x3D; mystl::copy(first, middle, buffer);
    mystl::merge(buffer, buffer_end, middle, last, first);
  &#125;
  else if (len2 &lt;&#x3D; buffer_size)
  &#123;
    Pointer buffer_end &#x3D; mystl::copy(middle, last, buffer);
    mystl::merge_backward(first, middle, buffer, buffer_end, last);
  &#125;
  else
  &#123;  &#x2F;&#x2F; 区间长度太长，分割递归处理
    auto first_cut &#x3D; first;
    auto second_cut &#x3D; middle;
    Distance len11 &#x3D; 0;
    Distance len22 &#x3D; 0;
    if (len1 &gt; len2)
    &#123;
      len11 &#x3D; len1 &gt;&gt; 1;
      mystl::advance(first_cut, len11);
      second_cut &#x3D; mystl::lower_bound(middle, last, *first_cut);
      len22 &#x3D; mystl::distance(middle, second_cut);
    &#125;
    else
    &#123;
      len22 &#x3D; len2 &gt;&gt; 1;
      mystl::advance(second_cut, len22);
      first_cut &#x3D; mystl::upper_bound(first, middle, *second_cut);
      len11 &#x3D; mystl::distance(first, first_cut);
    &#125;
    auto new_middle &#x3D; mystl::rotate_adaptive(first_cut, middle, second_cut,
                                             len1 - len11, len22, buffer, buffer_size);
    mystl::merge_adaptive(first, first_cut, new_middle, len11, len22, buffer, buffer_size);
    mystl::merge_adaptive(new_middle, second_cut, last, len1 - len11,
                          len2 - len22, buffer, buffer_size);
  &#125;
&#125;

template &lt;class BidirectionalIter, class T&gt;
void
inplace_merge_aux(BidirectionalIter first, BidirectionalIter middle,
                  BidirectionalIter last, T*)
&#123;
  auto len1 &#x3D; mystl::distance(first, middle);
  auto len2 &#x3D; mystl::distance(middle, last);
  temporary_buffer&lt;BidirectionalIter, T&gt; buf(first, last);
  if (!buf.begin())
  &#123;
    mystl::merge_without_buffer(first, middle, last, len1, len2);
  &#125;
  else
  &#123;
    mystl::merge_adaptive(first, middle, last, len1, len2, buf.begin(), buf.size());
  &#125;
&#125;

template &lt;class BidirectionalIter&gt;
void
inplace_merge(BidirectionalIter first, BidirectionalIter middle,
              BidirectionalIter last)
&#123;
  if (first &#x3D;&#x3D; middle || middle &#x3D;&#x3D; last)
    return;
  mystl::inplace_merge_aux(first, middle, last, value_type(first));
&#125;

&#x2F;&#x2F; 重载版本使用函数对象 comp 代替比较操作
&#x2F;&#x2F; 没有缓冲区的情况下合并
template &lt;class BidirectionalIter, class Distance, class Compared&gt;
void merge_without_buffer(BidirectionalIter first, BidirectionalIter middle,
                          BidirectionalIter last, Distance len1, Distance len2,
                          Compared comp)
&#123;
  if (len1 &#x3D;&#x3D; 0 || len2 &#x3D;&#x3D; 0)
    return;
  if (len1 + len2 &#x3D;&#x3D; 2)
  &#123;
    if (comp(*middle, *first))
      mystl::iter_swap(first, middle);
    return;
  &#125;
  auto first_cut &#x3D; first;
  auto second_cut &#x3D; middle;
  Distance len11 &#x3D; 0;
  Distance len22 &#x3D; 0;
  if (len1 &gt; len2)
  &#123;
    len11 &#x3D; len1 &gt;&gt; 1;
    mystl::advance(first_cut, len11);
    second_cut &#x3D; mystl::lower_bound(middle, last, *first_cut, comp);
    len22 &#x3D; mystl::distance(middle, second_cut);
  &#125;
  else
  &#123;
    len22 &#x3D; len2 &gt;&gt; 1;
    mystl::advance(second_cut, len22);
    first_cut &#x3D; mystl::upper_bound(first, middle, *second_cut, comp);
    len11 &#x3D; mystl::distance(first, first_cut);
  &#125;
  auto new_middle &#x3D; mystl::rotate(first_cut, middle, second_cut);
  mystl::merge_without_buffer(first, first_cut, new_middle, len11, len22, comp);
  mystl::merge_without_buffer(new_middle, second_cut, last, len1 - len11, len2 - len22, comp);
&#125;

template &lt;class BidirectionalIter1, class BidirectionalIter2, class Compared&gt;
BidirectionalIter1
merge_backward(BidirectionalIter1 first1, BidirectionalIter1 last1,
               BidirectionalIter2 first2, BidirectionalIter2 last2,
               BidirectionalIter1 result, Compared comp)
&#123;
  if (first1 &#x3D;&#x3D; last1)
    return mystl::copy_backward(first2, last2, result);
  if (first2 &#x3D;&#x3D; last2)
    return mystl::copy_backward(first1, last1, result);
  --last1;
  --last2;
  while (true)
  &#123;
    if (comp(*last2, *last1))
    &#123;
      *--result &#x3D; *last1;
      if (first1 &#x3D;&#x3D; last1)
        return mystl::copy_backward(first2, ++last2, result);
      --last1;
    &#125;
    else
    &#123;
      *--result &#x3D; *last2;
      if (first2 &#x3D;&#x3D; last2)
        return mystl::copy_backward(first1, ++last1, result);
      --last2;
    &#125;
  &#125;
&#125;

&#x2F;&#x2F; 有缓冲区的情况下合并
template &lt;class BidirectionalIter, class Distance, class Pointer, class Compared&gt;
void merge_adaptive(BidirectionalIter first, BidirectionalIter middle,
                    BidirectionalIter last, Distance len1, Distance len2,
                    Pointer buffer, Distance buffer_size, Compared comp)
&#123;
  &#x2F;&#x2F; 区间长度足够放进缓冲区
  if (len1 &lt;&#x3D; len2 &amp;&amp; len1 &lt;&#x3D; buffer_size)
  &#123;
    Pointer buffer_end &#x3D; mystl::copy(first, middle, buffer);
    mystl::merge(buffer, buffer_end, middle, last, first, comp);
  &#125;
  else if (len2 &lt;&#x3D; buffer_size)
  &#123;
    Pointer buffer_end &#x3D; mystl::copy(middle, last, buffer);
    mystl::merge_backward(first, middle, buffer, buffer_end, last, comp);
  &#125;
  else
  &#123;  &#x2F;&#x2F; 区间长度太长，分割递归处理
    auto first_cut &#x3D; first;
    auto second_cut &#x3D; middle;
    Distance len11 &#x3D; 0;
    Distance len22 &#x3D; 0;
    if (len1 &gt; len2)
    &#123;
      len11 &#x3D; len1 &gt;&gt; 1;
      mystl::advance(first_cut, len11);
      second_cut &#x3D; mystl::lower_bound(middle, last, *first_cut, comp);
      len22 &#x3D; mystl::distance(middle, second_cut);
    &#125;
    else
    &#123;
      len22 &#x3D; len2 &gt;&gt; 1;
      mystl::advance(second_cut, len22);
      first_cut &#x3D; mystl::upper_bound(first, middle, *second_cut, comp);
      len11 &#x3D; mystl::distance(first, first_cut);
    &#125;
    auto new_middle &#x3D; mystl::rotate_adaptive(first_cut, middle, second_cut, len1 - len11,
                                             len22, buffer, buffer_size);
    mystl::merge_adaptive(first, first_cut, new_middle, len11,
                          len22, buffer, buffer_size, comp);
    mystl::merge_adaptive(new_middle, second_cut, last, len1 - len11,
                          len2 - len22, buffer, buffer_size, comp);
  &#125;
&#125;

template &lt;class BidirectionalIter, class T, class Compared&gt;
void
inplace_merge_aux(BidirectionalIter first, BidirectionalIter middle,
                  BidirectionalIter last, T*, Compared comp)
&#123;
  auto len1 &#x3D; mystl::distance(first, middle);
  auto len2 &#x3D; mystl::distance(middle, last);
  temporary_buffer&lt;BidirectionalIter, T&gt; buf(first, last);
  if (!buf.begin())
  &#123;
    mystl::merge_without_buffer(first, middle, last, len1, len2, comp);
  &#125;
  else
  &#123;
    mystl::merge_adaptive(first, middle, last, len1, len2, buf.begin(), buf.size(), comp);
  &#125;
&#125;

template &lt;class BidirectionalIter, class Compared&gt;
void
inplace_merge(BidirectionalIter first, BidirectionalIter middle,
              BidirectionalIter last, Compared comp)
&#123;
  if (first &#x3D;&#x3D; middle || middle &#x3D;&#x3D; last)
    return;
  mystl::inplace_merge_aux(first, middle, last, value_type(first), comp);
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; partial_sort
&#x2F;&#x2F; 对整个序列做部分排序，保证较小的 N 个元素以递增顺序置于[first, first + N)中
&#x2F;*****************************************************************************************&#x2F;
template &lt;class RandomIter&gt;
void partial_sort(RandomIter first, RandomIter middle,
                  RandomIter last)
&#123;
  mystl::make_heap(first, middle);
  for (auto i &#x3D; middle; i &lt; last; ++i)
  &#123;
    if (*i &lt; *first)
    &#123;
      mystl::pop_heap_aux(first, middle, i, *i, distance_type(first));
    &#125;
  &#125;
  mystl::sort_heap(first, middle);
&#125;

&#x2F;&#x2F; 重载版本使用函数对象 comp 代替比较操作
template &lt;class RandomIter, class Compared&gt;
void partial_sort(RandomIter first, RandomIter middle,
                  RandomIter last, Compared comp)
&#123;
  mystl::make_heap(first, middle, comp);
  for (auto i &#x3D; middle; i &lt; last; ++i)
  &#123;
    if (comp(*i, *first))
    &#123;
      mystl::pop_heap_aux(first, middle, i, *i, distance_type(first), comp);
    &#125;
  &#125;
  mystl::sort_heap(first, middle, comp);
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; partial_sort_copy
&#x2F;&#x2F; 行为与 partial_sort 类似，不同的是把排序结果复制到 result 容器中
&#x2F;*****************************************************************************************&#x2F;
template &lt;class InputIter, class RandomIter, class Distance&gt;
RandomIter
psort_copy_aux(InputIter first, InputIter last,
               RandomIter result_first, RandomIter result_last,
               Distance*)
&#123;
  if (result_first &#x3D;&#x3D; result_last)
    return result_last;
  auto result_iter &#x3D; result_first;
  while (first !&#x3D; last &amp;&amp; result_iter !&#x3D; result_last)
  &#123;
    *result_iter &#x3D; *first;
    ++result_iter;
    ++first;
  &#125;
  mystl::make_heap(result_first, result_iter);
  while (first !&#x3D; last)
  &#123;
    if (*first &lt; *result_first)
    &#123;
      mystl::adjust_heap(result_first, static_cast&lt;Distance&gt;(0),
                           result_iter - result_first, *first);
    &#125;
    ++first;
  &#125;
  mystl::sort_heap(result_first, result_iter);
  return result_iter;
&#125;

template &lt;class InputIter, class RandomIter&gt;
RandomIter
partial_sort_copy(InputIter first, InputIter last,
                  RandomIter result_first, RandomIter result_last)
&#123;
  return mystl::psort_copy_aux(first, last, result_first, result_last,
                               distance_type(result_first));
&#125;

&#x2F;&#x2F; 重载版本使用函数对象 comp 代替比较操作
template &lt;class InputIter, class RandomIter, class Distance, class Compared&gt;
RandomIter
psort_copy_aux(InputIter first, InputIter last,
               RandomIter result_first, RandomIter result_last,
               Distance*, Compared comp)
&#123;
  if (result_first &#x3D;&#x3D; result_last)
    return result_last;
  auto result_iter &#x3D; result_first;
  while (first !&#x3D; last &amp;&amp; result_iter !&#x3D; result_last)
  &#123;
    *result_iter &#x3D; *first;
    ++result_iter;
    ++first;
  &#125;
  mystl::make_heap(result_first, result_iter, comp);
  while (first !&#x3D; last)
  &#123;
    if (comp(*first, *result_first))
    &#123;
      mystl::adjust_heap(result_first, static_cast&lt;Distance&gt;(0),
                           result_iter - result_first, *first, comp);
    &#125;
    ++first;
  &#125;
  mystl::sort_heap(result_first, result_iter, comp);
  return result_iter;
&#125;

template &lt;class InputIter, class RandomIter, class Compared&gt;
RandomIter
partial_sort_copy(InputIter first, InputIter last,
                  RandomIter result_first, RandomIter result_last,
                  Compared comp)
&#123;
  return mystl::psort_copy_aux(first, last, result_first, result_last,
                               distance_type(result_first), comp);
&#125;
&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; partition
&#x2F;&#x2F; 对区间内的元素重排，被一元条件运算判定为 true 的元素会放到区间的前段
&#x2F;&#x2F; 该函数不保证元素的原始相对位置
&#x2F;*****************************************************************************************&#x2F;
template &lt;class BidirectionalIter, class UnaryPredicate&gt;
BidirectionalIter
partition(BidirectionalIter first, BidirectionalIter last,
          UnaryPredicate unary_pred)
&#123;
  while (true)
  &#123;
    while (first !&#x3D; last &amp;&amp; unary_pred(*first))
    &#123;
      ++first;
    &#125;
    if (first &#x3D;&#x3D; last)
      break;
    --last;
    while (first !&#x3D; last &amp;&amp; !unary_pred(*last))
    &#123;
      --last;
    &#125;
    if (first &#x3D;&#x3D; last)
      break;
    mystl::iter_swap(first, last);
    ++first;
  &#125;
  return first;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; partition_copy
&#x2F;&#x2F; 行为与 partition 类似，不同的是，将被一元操作符判定为 true 的放到 result_true 的输出区间
&#x2F;&#x2F; 其余放到 result_false 的输出区间，并返回一个 mystl::pair 指向这两个区间的尾部
&#x2F;*****************************************************************************************&#x2F;
template &lt;class InputIter, class OutputIter1, class OutputIter2, class UnaryPredicate&gt;
mystl::pair&lt;OutputIter1, OutputIter2&gt;
partition_copy(InputIter first, InputIter last,
               OutputIter1 result_true, OutputIter2 result_false,
               UnaryPredicate unary_pred)
&#123;
  for (; first !&#x3D; last; ++first)
  &#123;
    if (unary_pred(*first))
    &#123;
      *result_true++ &#x3D; *first;
    &#125;
    else
    &#123;
      *result_false++ &#x3D; *first;
    &#125;
  &#125;
  return mystl::pair&lt;OutputIter1, OutputIter2&gt;(result_true, result_false);
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; sort
&#x2F;&#x2F; 将[first, last)内的元素以递增的方式排序
&#x2F;*****************************************************************************************&#x2F;
constexpr static size_t kSmallSectionSize &#x3D; 128;  &#x2F;&#x2F; 小型区间的大小，在这个大小内采用插入排序

                                                  &#x2F;&#x2F; 用于控制分割恶化的情况
template &lt;class Size&gt;
Size slg2(Size n)
&#123; &#x2F;&#x2F; 找出 lgk &lt;&#x3D; n 的 k 的最大值
  Size k &#x3D; 0;
  for (; n &gt; 1; n &gt;&gt;&#x3D; 1)
    ++k;
  return k;
&#125;

&#x2F;&#x2F; 分割函数 unchecked_partition
template &lt;class RandomIter, class T&gt;
RandomIter
unchecked_partition(RandomIter first, RandomIter last, const T&amp; pivot)
&#123;
  while (true)
  &#123;
    while (*first &lt; pivot)
      ++first;
    --last;
    while (pivot &lt; *last)
      --last;
    if (!(first &lt; last))
      return first;
    mystl::iter_swap(first, last);
    ++first;
  &#125;
&#125;

&#x2F;&#x2F; 内省式排序，先进行 quick sort，当分割行为有恶化倾向时，改用 heap sort
template &lt;class RandomIter, class Size&gt;
void intro_sort(RandomIter first, RandomIter last, Size depth_limit)
&#123;
  while (static_cast&lt;size_t&gt;(last - first) &gt; kSmallSectionSize)
  &#123;
    if (depth_limit &#x3D;&#x3D; 0)
    &#123;                      &#x2F;&#x2F; 到达最大分割深度限制
      mystl::partial_sort(first, last, last);  &#x2F;&#x2F; 改用 heap_sort
      return;
    &#125;
    --depth_limit;
    auto mid &#x3D; mystl::median(*(first), *(first + (last - first) &#x2F; 2), *(last - 1));
    auto cut &#x3D; mystl::unchecked_partition(first, last, mid);
    mystl::intro_sort(cut, last, depth_limit);
    last &#x3D; cut;
  &#125;
&#125;

&#x2F;&#x2F; 插入排序辅助函数 unchecked_linear_insert
template &lt;class RandomIter, class T&gt;
void unchecked_linear_insert(RandomIter last, const T&amp; value)
&#123;
  auto next &#x3D; last;
  --next;
  while (value &lt; *next)
  &#123;
    *last &#x3D; *next;
    last &#x3D; next;
    --next;
  &#125;
  *last &#x3D; value;
&#125;

&#x2F;&#x2F; 插入排序函数 unchecked_insertion_sort
template &lt;class RandomIter&gt;
void unchecked_insertion_sort(RandomIter first, RandomIter last)
&#123;
  for (auto i &#x3D; first; i !&#x3D; last; ++i)
  &#123;
    mystl::unchecked_linear_insert(i, *i);
  &#125;
&#125;

&#x2F;&#x2F; 插入排序函数 insertion_sort
template &lt;class RandomIter&gt;
void insertion_sort(RandomIter first, RandomIter last)
&#123;
  if (first &#x3D;&#x3D; last)
    return;
  for (auto i &#x3D; first + 1; i !&#x3D; last; ++i)
  &#123;
    auto value &#x3D; *i;
    if (value &lt; *first)
    &#123;
      mystl::copy_backward(first, i, i + 1);
      *first &#x3D; value;
    &#125;
    else
    &#123;
      mystl::unchecked_linear_insert(i, value);
    &#125;
  &#125;
&#125;

&#x2F;&#x2F; 最终插入排序函数 final_insertion_sort
template &lt;class RandomIter&gt;
void final_insertion_sort(RandomIter first, RandomIter last)
&#123;
  if (static_cast&lt;size_t&gt;(last - first) &gt; kSmallSectionSize)
  &#123;
    mystl::insertion_sort(first, first + kSmallSectionSize);
    mystl::unchecked_insertion_sort(first + kSmallSectionSize, last);
  &#125;
  else
  &#123;
    mystl::insertion_sort(first, last);
  &#125;
&#125;

template &lt;class RandomIter&gt;
void sort(RandomIter first, RandomIter last)
&#123;
  if (first !&#x3D; last)
  &#123;
    &#x2F;&#x2F; 内省式排序，将区间分为一个个小区间，然后对整体进行插入排序
    mystl::intro_sort(first, last, slg2(last - first) * 2);
    mystl::final_insertion_sort(first, last);
  &#125;
&#125;

&#x2F;&#x2F; 重载版本使用函数对象 comp 代替比较操作
&#x2F;&#x2F; 分割函数 unchecked_partition
template &lt;class RandomIter, class T, class Compared&gt;
RandomIter
unchecked_partition(RandomIter first, RandomIter last,
                    const T&amp; pivot, Compared comp)
&#123;
  while (true)
  &#123;
    while (comp(*first, pivot))
      ++first;
    --last;
    while (comp(pivot, *last))
      --last;
    if (!(first &lt; last))
      return first;
    mystl::iter_swap(first, last);
    ++first;
  &#125;
&#125;

&#x2F;&#x2F; 内省式排序，先进行 quick sort，当分割行为有恶化倾向时，改用 heap sort
template &lt;class RandomIter, class Size, class Compared&gt;
void intro_sort(RandomIter first, RandomIter last,
                Size depth_limit, Compared comp)
&#123;
  while (static_cast&lt;size_t&gt;(last - first) &gt; kSmallSectionSize)
  &#123;
    if (depth_limit &#x3D;&#x3D; 0)
    &#123;                            &#x2F;&#x2F; 到达最大分割深度限制
      mystl::partial_sort(first, last, last, comp);  &#x2F;&#x2F; 改用 heap_sort
      return;
    &#125;
    --depth_limit;
    auto mid &#x3D; mystl::median(*(first), *(first + (last - first) &#x2F; 2), *(last - 1));
    auto cut &#x3D; mystl::unchecked_partition(first, last, mid, comp);
    mystl::intro_sort(cut, last, depth_limit, comp);
    last &#x3D; cut;
  &#125;
&#125;

&#x2F;&#x2F; 插入排序辅助函数 unchecked_linear_insert
template &lt;class RandomIter, class T, class Compared&gt;
void unchecked_linear_insert(RandomIter last, const T&amp; value, Compared comp)
&#123;
  auto next &#x3D; last;
  --next;
  while (comp(value, *next))
  &#123;  &#x2F;&#x2F; 从尾部开始寻找第一个可插入位置
    *last &#x3D; *next;
    last &#x3D; next;
    --next;
  &#125;
  *last &#x3D; value;
&#125;

&#x2F;&#x2F; 插入排序函数 unchecked_insertion_sort
template &lt;class RandomIter, class Compared&gt;
void unchecked_insertion_sort(RandomIter first, RandomIter last,
                              Compared comp)
&#123;
  for (auto i &#x3D; first; i !&#x3D; last; ++i)
  &#123;
    mystl::unchecked_linear_insert(i, *i, comp);
  &#125;
&#125;

&#x2F;&#x2F; 插入排序函数 insertion_sort
template &lt;class RandomIter, class Compared&gt;
void insertion_sort(RandomIter first, RandomIter last, Compared comp)
&#123;
  if (first &#x3D;&#x3D; last)
    return;
  for (auto i &#x3D; first + 1; i !&#x3D; last; ++i)
  &#123;
    auto value &#x3D; *i;
    if (comp(value, *first))
    &#123;
      mystl::copy_backward(first, i, i + 1);
      *first &#x3D; value;
    &#125;
    else
    &#123;
      mystl::unchecked_linear_insert(i, value, comp);
    &#125;
  &#125;
&#125;

&#x2F;&#x2F; 最终插入排序函数 final_insertion_sort
template &lt;class RandomIter, class Compared&gt;
void final_insertion_sort(RandomIter first, RandomIter last, Compared comp)
&#123;
  if (static_cast&lt;size_t&gt;(last - first) &gt; kSmallSectionSize)
  &#123;
    mystl::insertion_sort(first, first + kSmallSectionSize, comp);
    mystl::unchecked_insertion_sort(first + kSmallSectionSize, last, comp);
  &#125;
  else
  &#123;
    mystl::insertion_sort(first, last, comp);
  &#125;
&#125;

template &lt;class RandomIter, class Compared&gt;
void sort(RandomIter first, RandomIter last, Compared comp)
&#123;
  if (first !&#x3D; last)
  &#123;
    &#x2F;&#x2F; 内省式排序，将区间分为一个个小区间，然后对整体进行插入排序
    mystl::intro_sort(first, last, slg2(last - first) * 2, comp);
    mystl::final_insertion_sort(first, last, comp);
  &#125;
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; nth_element
&#x2F;&#x2F; 对序列重排，使得所有小于第 n 个元素的元素出现在它的前面，大于它的出现在它的后面
&#x2F;*****************************************************************************************&#x2F;
template &lt;class RandomIter&gt;
void nth_element(RandomIter first, RandomIter nth,
                 RandomIter last)
&#123;
  if (nth &#x3D;&#x3D; last)
    return;
  while (last - first &gt; 3)
  &#123;
    auto cut &#x3D; mystl::unchecked_partition(first, last, mystl::median(*first,
										  *(first + (last - first) &#x2F; 2),
										  *(last - 1)));
    if (cut &lt;&#x3D; nth)  &#x2F;&#x2F; 如果 nth 位于右段
      first &#x3D; cut;   &#x2F;&#x2F; 对右段进行分割
    else
      last &#x3D; cut;    &#x2F;&#x2F; 对左段进行分割
  &#125;
  mystl::insertion_sort(first, last);
&#125;

&#x2F;&#x2F; 重载版本使用函数对象 comp 代替比较操作
template &lt;class RandomIter, class Compared&gt;
void nth_element(RandomIter first, RandomIter nth,
                 RandomIter last, Compared comp)
&#123;
  if (nth &#x3D;&#x3D; last)
    return;
  while (last - first &gt; 3)
  &#123;
    auto cut &#x3D; mystl::unchecked_partition(first, last, mystl::median(*first, 
										  *(first + (last - first) &#x2F; 2),
										  *(last - 1)), comp);
    if (cut &lt;&#x3D; nth)  &#x2F;&#x2F; 如果 nth 位于右段
      first &#x3D; cut;   &#x2F;&#x2F; 对右段进行分割
    else
      last &#x3D; cut;    &#x2F;&#x2F; 对左段进行分割
  &#125;
  mystl::insertion_sort(first, last, comp);
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; unique_copy
&#x2F;&#x2F; 从[first, last)中将元素复制到 result 上，序列必须有序，如果有重复的元素，只会复制一次
&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; unique_copy_dispatch 的 forward_iterator_tag 版本
template &lt;class InputIter, class ForwardIter&gt;
ForwardIter
unique_copy_dispatch(InputIter first, InputIter last,
                     ForwardIter result, forward_iterator_tag)
&#123;
  *result &#x3D; *first;
  while (++first !&#x3D; last)
  &#123;
    if (*result !&#x3D; *first)
      *++result &#x3D; *first;
  &#125;
  return ++result;
&#125;

&#x2F;&#x2F; unique_copy_dispatch 的 output_iterator_tag 版本
&#x2F;&#x2F; 由于 output iterator 只能进行只读操作，所以不能有 *result !&#x3D; *first 这样的判断
template &lt;class InputIter, class OutputIter&gt;
OutputIter
unique_copy_dispatch(InputIter first, InputIter last,
                     OutputIter result, output_iterator_tag)
&#123;
  auto value &#x3D; *first;
  *result &#x3D; value;
  while (++first !&#x3D; last)
  &#123;
    if (value !&#x3D; *first)
    &#123;
      value &#x3D; *first;
      *++result &#x3D; value;
    &#125;
  &#125;
  return ++result;
&#125;

template &lt;class InputIter, class OutputIter&gt;
OutputIter
unique_copy(InputIter first, InputIter last, OutputIter result)
&#123;
  if (first &#x3D;&#x3D; last)
    return result;
  return mystl::unique_copy_dispatch(first, last, result, iterator_category(result));
&#125;

&#x2F;&#x2F; 重载版本使用函数对象 comp 代替比较操作
&#x2F;&#x2F; unique_copy_dispatch 的 forward_iterator_tag 版本
template &lt;class InputIter, class ForwardIter, class Compared&gt;
ForwardIter
unique_copy_dispatch(InputIter first, InputIter last,
                     ForwardIter result, forward_iterator_tag, Compared comp)
&#123;
  *result &#x3D; *first;
  while (++first !&#x3D; last)
  &#123;
    if (!comp(*result, *first))
      *++result &#x3D; *first;
  &#125;
  return ++result;
&#125;

&#x2F;&#x2F; unique_copy_dispatch 的 output_iterator_tag 版本
&#x2F;&#x2F; 由于 output iterator 只能进行只读操作，所以不能有 *result !&#x3D; *first 这样的判断
template &lt;class InputIter, class OutputIter, class Compared&gt;
OutputIter
unique_copy_dispatch(InputIter first, InputIter last,
                     OutputIter result, output_iterator_tag, Compared comp)
&#123;
  auto value &#x3D; *first;
  *result &#x3D; value;
  while (++first !&#x3D; last)
  &#123;
    if (!comp(value, *first))
    &#123;
      value &#x3D; *first;
      *++result &#x3D; value;
    &#125;
  &#125;
  return ++result;
&#125;

template &lt;class InputIter, class OutputIter, class Compared&gt;
OutputIter
unique_copy(InputIter first, InputIter last, OutputIter result, Compared comp)
&#123;
  if (first &#x3D;&#x3D; last)
    return result;
  return mystl::unique_copy_dispatch(first, last, result, iterator_category(result), comp);
&#125;

&#x2F;*****************************************************************************************&#x2F;
&#x2F;&#x2F; unique
&#x2F;&#x2F; 移除[first, last)内重复的元素，序列必须有序，和 remove 类似，它也不能真正的删除重复元素
&#x2F;*****************************************************************************************&#x2F;
template &lt;class ForwardIter&gt;
ForwardIter unique(ForwardIter first, ForwardIter last)
&#123;
  first &#x3D; mystl::adjacent_find(first, last);
  return mystl::unique_copy(first, last, first);
&#125;

&#x2F;&#x2F; 重载版本使用函数对象 comp 代替比较操作
template &lt;class ForwardIter, class Compared&gt;
ForwardIter unique(ForwardIter first, ForwardIter last, Compared comp)
&#123;
  first &#x3D; mystl::adjacent_find(first, last, comp);
  return mystl::unique_copy(first, last, first, comp);
&#125;

&#125; &#x2F;&#x2F; namespace mystl

#ifdef _MSC_VER
#pragma warning(pop)
#endif

#endif &#x2F;&#x2F; !MYTINYSTL_ALGO_H_
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="手撸Json"><a href="#手撸Json" class="headerlink" title="手撸Json"></a>手撸Json</h3><h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3>
    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/c/" rel="tag"><i class="fa fa-tag"></i> c++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/08/C-%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/" rel="prev" title="C++机房预约系统">
      <i class="fa fa-chevron-left"></i> C++机房预约系统
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/07/11/%E6%96%B0%E4%B8%AD%E5%9C%B0%E6%9A%91%E6%9C%9F%E5%BC%80%E5%8F%91%E5%9F%B9%E8%AE%AD%E7%AC%94%E8%AE%B0/" rel="next" title="新中地暑期开发培训笔记">
      新中地暑期开发培训笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF"><span class="nav-number">1.</span> <span class="nav-text">C++学习路线</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">2.</span> <span class="nav-text">C语言入门基础知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%9F%BA%E7%A1%80"><span class="nav-number">3.</span> <span class="nav-text">C++基础</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E8%BF%9B%E9%98%B6"><span class="nav-number">4.</span> <span class="nav-text">C++进阶</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E6%96%B0%E7%89%B9%E6%80%A7-C-11"><span class="nav-number">5.</span> <span class="nav-text">C++新特性(C++11)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="nav-number">6.</span> <span class="nav-text">操作系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E5%85%B7"><span class="nav-number">7.</span> <span class="nav-text">工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83"><span class="nav-number">8.</span> <span class="nav-text">编码规范</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E9%93%BE%E6%8E%A5%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="nav-number">9.</span> <span class="nav-text">编译链接知识点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%87%8D%E7%82%B9"><span class="nav-number">10.</span> <span class="nav-text">C++基础知识重点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new-%E5%92%8Cdelete-%E9%85%8D%E5%AF%B9%E4%BD%BF%E7%94%A8"><span class="nav-number">11.</span> <span class="nav-text">new[]和delete[]配对使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">12.</span> <span class="nav-text">指针和函数的使用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E5%BC%95%E7%94%A8%E3%80%81%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E3%80%81%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E3%80%81%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="nav-number">13.</span> <span class="nav-text">左值引用、右值引用、移动语义、完美转发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B7%A6%E5%80%BC%E3%80%81%E5%8F%B3%E5%80%BC"><span class="nav-number">13.1.</span> <span class="nav-text">左值、右值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%AF%E5%8F%B3%E5%80%BC%E3%80%81%E5%B0%86%E4%BA%A1%E5%80%BC"><span class="nav-number">13.2.</span> <span class="nav-text">纯右值、将亡值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80"><span class="nav-number">14.</span> <span class="nav-text">C++对象布局</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81%EF%BC%9F"><span class="nav-number">14.1.</span> <span class="nav-text">什么是多态？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E6%9F%A5%E7%9C%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%83%E5%B1%80"><span class="nav-number">14.2.</span> <span class="nav-text">如何查看对象的布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%83%E5%B1%80"><span class="nav-number">14.3.</span> <span class="nav-text">普通类对象的布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%A6%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80"><span class="nav-number">14.4.</span> <span class="nav-text">带虚函数的类的对象布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E7%BB%A7%E6%89%BF%E4%B8%8B%E4%B8%8D%E5%90%AB%E6%9C%89%E8%A6%86%E7%9B%96%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%83%E5%B1%80"><span class="nav-number">14.5.</span> <span class="nav-text">单继承下不含有覆盖函数的类对象的布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E7%BB%A7%E6%89%BF%E4%B8%8B%E5%90%AB%E6%9C%89%E8%A6%86%E7%9B%96%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%83%E5%B1%80"><span class="nav-number">14.6.</span> <span class="nav-text">单继承下含有覆盖函数的类对象的布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8B%E4%B8%8D%E5%90%AB%E6%9C%89%E8%A6%86%E7%9B%96%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%83%E5%B1%80"><span class="nav-number">14.7.</span> <span class="nav-text">多继承下不含有覆盖函数的类对象的布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%8B%E5%90%AB%E6%9C%89%E8%A6%86%E7%9B%96%E5%87%BD%E6%95%B0%E7%9A%84%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%83%E5%B1%80"><span class="nav-number">14.8.</span> <span class="nav-text">多继承下含有覆盖函数的类对象的布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BB%A7%E6%89%BF%E9%A1%BA%E5%BA%8F%E5%AF%BC%E8%87%B4%E7%9A%84%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%83%E5%B1%80%E7%9B%B8%E5%90%8C%E5%90%97%EF%BC%9F"><span class="nav-number">14.9.</span> <span class="nav-text">多重继承不同的继承顺序导致的类对象的布局相同吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF%E7%9A%84%E5%B8%83%E5%B1%80"><span class="nav-number">14.10.</span> <span class="nav-text">虚继承的布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF%E5%B8%A6%E6%9C%AA%E8%A6%86%E7%9B%96%E5%87%BD%E6%95%B0%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B8%83%E5%B1%80"><span class="nav-number">14.11.</span> <span class="nav-text">虚继承带未覆盖函数的对象布局</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E4%B8%8B%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%83%E5%B1%80"><span class="nav-number">14.12.</span> <span class="nav-text">菱形继承下类对象的布局</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%99%9A%E7%BB%A7%E6%89%BF%EF%BC%9F"><span class="nav-number">14.12.1.</span> <span class="nav-text">为什么要虚继承？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E4%B8%AD%E6%9C%89%E4%B8%A4%E4%B8%AA%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-number">14.12.2.</span> <span class="nav-text">为什么虚函数表中有两个析构函数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-number">14.12.3.</span> <span class="nav-text">为什么构造函数不能是虚函数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9F%BA%E7%B1%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E8%A6%81%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%9F"><span class="nav-number">14.12.4.</span> <span class="nav-text">为什么基类析构函数要是虚函数？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">14.12.5.</span> <span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%BC%95%E5%85%A5%E5%9B%9B%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">15.</span> <span class="nav-text">为什么要引入四种类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0nullptr"><span class="nav-number">16.</span> <span class="nav-text">为什么会出现nullptr</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-C-%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E7%9A%84%E9%82%A3%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="nav-number">17.</span> <span class="nav-text">C&#x2F;C++时间相关的那些函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E9%A1%B9%E7%9B%AE"><span class="nav-number">18.</span> <span class="nav-text">C++项目</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E6%92%B8STL"><span class="nav-number">18.1.</span> <span class="nav-text">手撸STL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E6%92%B8Json"><span class="nav-number">18.2.</span> <span class="nav-text">手撸Json</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-number">18.3.</span> <span class="nav-text">网络编程</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="OrangeW"
      src="/images/orange.png">
  <p class="site-author-name" itemprop="name">OrangeW</p>
  <div class="site-description" itemprop="description">demo_study record</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">21</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">17</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


<!-- CloudCalendar -->
<div class="widget-wrap" style="width: 90%;margin-left: auto;margin-right: auto; opacity: 0.97;">
	<div class="widget" id="CloudCalendar"></div>
</div>
      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OrangeW</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">1.1m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">33:07</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
<!-- calendar widget -->

    <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-calendar/calendar.min.js"></script>
    <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-calendar/languages.min.js"></script>
    <script>
    $(function() {
        $('#CloudCalendar').aCalendar('zh-CN',
            $.extend(
                '', {
                    single:true,
                    root:'/calendar/'
                }
            )
        );
    });
    </script>


</body>
</html>
