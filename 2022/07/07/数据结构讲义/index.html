<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/orange.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/orange.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/orange.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"01zic.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1.数据结构概念">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构讲义">
<meta property="og:url" content="https://01zic.github.io/2022/07/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%B2%E4%B9%89/index.html">
<meta property="og:site_name" content="orangeWBlog">
<meta property="og:description" content="1.数据结构概念">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8CA4.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8CA5.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8CA6.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8CB7.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8CB8.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8CC8.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8CC9.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8CCA.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8CCB.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8CDC.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8CDD.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8CEE.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8CEF.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8CF0.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8CF1.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8CF2.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8D02.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8D03.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8D14.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8D15.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8D16.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8D26.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8D27.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8D28.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8D39.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8D4A.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8D4B.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8D5B.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8D6C.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8D6D.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8D6E.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8D7F.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8D80.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8D81.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8D82.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8D83.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8D84.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8D95.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8D96.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8D97.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8D98.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8D99.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8DAA.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8DAB.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8DAC.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8DBC.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8DBD.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8DBE.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8DCF.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8DD0.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8DD1.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8DD2.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8DE3.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8DE4.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8DF4.tmp.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8DF5.tmp.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8E06.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8E07.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8E18.tmp.jpg">
<meta property="og:image" content="e:/Computer/myblog/hexo/source_posts/数据结构讲义/wps8E19.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wps8E1A.tmp.jpg">
<meta property="article:published_time" content="2022-07-07T15:49:30.000Z">
<meta property="article:modified_time" content="2022-07-08T15:13:25.488Z">
<meta property="article:author" content="OrangeW">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://qiniu.orangew.cn/img/wps8CA4.tmp.jpg">

<link rel="canonical" href="https://01zic.github.io/2022/07/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%B2%E4%B9%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据结构讲义 | orangeWBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">orangeWBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://01zic.github.io/2022/07/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%B2%E4%B9%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/orange.png">
      <meta itemprop="name" content="OrangeW">
      <meta itemprop="description" content="demo_study record">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="orangeWBlog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据结构讲义
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-07 23:49:30" itemprop="dateCreated datePublished" datetime="2022-07-07T23:49:30+08:00">2022-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-08 23:13:25" itemprop="dateModified" datetime="2022-07-08T23:13:25+08:00">2022-07-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>81k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2:28</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="1-数据结构概念"><a href="#1-数据结构概念" class="headerlink" title="1.数据结构概念"></a><strong>1.数据结构概念</strong></h2><h3 id="1-1数据结构相关概念"><a href="#1-1数据结构相关概念" class="headerlink" title="1.1数据结构相关概念"></a><strong>1.1数据结构相关概念</strong></h3><h4 id="1-1-1为什么要学习数据结构"><a href="#1-1-1为什么要学习数据结构" class="headerlink" title="1.1.1为什么要学习数据结构?"></a><strong>1.1.1为什么要学习数据结构?</strong></h4><ul>
<li><p>为什么要学习数据结构？在回答这个问题之前，我们是不是应该弄清楚什么是数据结构，数据结构能够用来做什么？最直白的，它能够帮我们解决什么问题？</p>
</li>
<li><p>我们之前的学习的设计模式和现在数据结构，有个相似的特点，他们两个都是在思想层面的东西，和具体的语言无关，你可以用其他的语言去实现这些思想都没有问题。</p>
</li>
<li><p>设计模式在教我们如何编写代码，让我们的代码具有可扩展性，灵活性，可复用性，这个是编码层次上的，那么数据结构呢？我们举一个例子:</p>
</li>
<li><p>比如我们C语言中没有数组这么个数据结构，那么你如何实现10个数排序呢？是不是要定义10个变量，然后让10个变量互相比较，重复劳动，但是你用数组之后，是不是问题变得简单了，只需要通过数组下表就可以，提高了程序的编写效率。</p>
</li>
<li><p>再比如说，我们有了数组了，为什么还需要学习链表这种数据结构？数组是连续内存空间，一旦定义了不能概念，适应性差，但是链表你有多少数据，我就创建多少个结点，而且比如说数据，你删除中间位置一个元素，会引起后面数据的移动，但是链表不会啊，在有些场合下，你使用链表是不是会增加程序的效率。</p>
</li>
<li><p>从我们的讲的东西中，也可以得出数据结构的概念，数据结构就是帮我们解决如何组织和存储数据的方式。</p>
</li>
<li><p>数据结构主要<strong>研究非数值计算问题的程序中的操作对象以及他们之间的关系</strong>，<strong>不是研究复杂的算法</strong>。</p>
</li>
<li><p><strong>数据结构是计算机存储、组织数据的方式。</strong></p>
</li>
</ul>
<h4 id="1-1-2数据结构中的基本概念"><a href="#1-1-2数据结构中的基本概念" class="headerlink" title="1.1.2数据结构中的基本概念"></a><strong>1.1.2数据结构中的基本概念</strong></h4><ul>
<li>数据 – 程序的操作对象，用于描述客观事物。</li>
</ul>
<ul>
<li>数据是一个抽象的概念，将其进行分类后得到程序设计语言中的类型。如：int，float，char等等。</li>
</ul>
<ul>
<li>数据元素：组成数据的基本单位。</li>
</ul>
<ul>
<li>数据项：一个数据元素由若干数据项组成。</li>
</ul>
<ul>
<li>数据对象 – 性质相同的数据元素的集合（比如：数组，链表）。 </li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;声明一个结构体类型
struct _MyTeacher   &#x2F;&#x2F;一种数据类型
&#123;
	char	name[32];
	char	tile[32];
	int		age;
	char	addr[128];
&#125;;

int main()
&#123;
	struct _MyTeacher  t1; &#x2F;&#x2F;数据元素
	struct _MyTeacher tArray[30]; &#x2F;&#x2F;数据对象
	memset(&amp;t1, 0, sizeof(t1));

	strcpy(t1.name, &quot;name&quot;); &#x2F;&#x2F;数据项
	strcpy(t1.addr, &quot;addr&quot;); &#x2F;&#x2F;数据项
	strcpy(t1.tile, &quot;addr&quot;); &#x2F;&#x2F;数据项
	t1.age &#x3D; 1;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="1-2算法"><a href="#1-2算法" class="headerlink" title="1.2算法"></a><strong>1.2算法</strong></h3><h4 id="1-2-1算法的概念"><a href="#1-2-1算法的概念" class="headerlink" title="1.2.1算法的概念"></a><strong>1.2.1算法的概念</strong></h4><ul>
<li><p><strong>为啥子我们学习数据结构还要了解算法？</strong></p>
</li>
<li><p><strong>比如说:我有10个学生，我们将是10个学生保存在一个链表中，但是我不能把学生保存进去就完事了吧？我放进去是为了使用这些个数据完成一定的业务需求，比如按成绩大小排序并显示，比如计算这些学生的平均分等等，这些才是我们最终要解决的问题，既然要解决问题，那么就需要一些算法，比如排序算法，比如计算平均分的算法，对吧？所以数据结构和算法是互相配合完成工作。</strong></p>
</li>
<li><p>算法是特定问题求解步骤的描述，在计算机中表现为<strong>指令的有限序列</strong>，算法是独立存在的一种解决问题的方法和思想。</p>
</li>
</ul>
<ul>
<li>对于算法而言，语言并不重要，重要的是思想。</li>
</ul>
<h4 id="1-2-2算法和数据结构区别"><a href="#1-2-2算法和数据结构区别" class="headerlink" title="1.2.2算法和数据结构区别"></a><strong>1.2.2算法和数据结构区别</strong></h4><ul>
<li>数据结构只是静态的描述了数据元素之间的关系，高效的程序需要在数据结构的基础上设计和选择算法。</li>
<li><strong>算法是为了解决实际问题而设计的。</strong></li>
<li><strong>数据结构是算法需要处理的问题载体。</strong></li>
<li><strong>数据结构与算法相辅相成</strong></li>
</ul>
<h4 id="1-2-3算法特性"><a href="#1-2-3算法特性" class="headerlink" title="1.2.3算法特性"></a><strong>1.2.3算法特性</strong></h4><ul>
<li><p> <strong>输入</strong>: 算法具有0个或多个输入</p>
</li>
<li><p> <strong>输出</strong>: 算法至少有1个或多个输出</p>
</li>
<li><p> <strong>有穷性</strong>: 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在接收的实际内完成</p>
</li>
<li><p> <strong>确定性</strong>：算法中的每一步都有确定的含义，不会出现二义性</p>
</li>
<li><p><strong>可行性</strong>：算法的每一步都是可行的，也就是说每一步都能够执行有限的次数完成。</p>
</li>
<li><p><strong>问题:针对某一具体的问题，解决此问题的算法是唯一的吗？</strong></p>
</li>
</ul>
<p><strong>比如说:求从1到100的和？</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
&#x2F;&#x2F;算法1
long sum1(int n)&#123;
	long ret &#x3D; 0;
	int* array &#x3D; (int*)malloc(n * sizeof(int));
	int i &#x3D; 0;
	for (int i &#x3D; 0; i &lt; n; i ++)&#123;
		array[i] &#x3D; i + 1;
	&#125;
	for (int i &#x3D; 0; i &lt; n;i++)&#123;
		ret +&#x3D; array[i];
	&#125;
	free(array);

	return ret;
&#125;
&#x2F;&#x2F;算法2
long sum2(int n)&#123;
	long ret &#x3D; 0; 
	int i &#x3D; 0;
	for (i &#x3D; 1; i &lt;&#x3D; n;i++)&#123; 
		ret +&#x3D; i;
	&#125;
	return ret;
&#125;
&#x2F;&#x2F;算法3
long sum3(int n)&#123;
	long ret &#x3D; 0; &#x2F;&#x2F; 1
	if (n &gt; 0)&#123; 
		ret &#x3D; (1 + n)*n &#x2F; 2;
	&#125;
	return ret;
&#125;
int main()&#123;
	printf(&quot;%d&quot;, sum1(100));
	printf(&quot;%d&quot;, sum2(100));
	printf(&quot;%d&quot;, sum3(100));
	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>同样一个问题，我有三种不同的算法，这三种算法都可以解决同样的问题，那么我们如何选择？需要有个方法来衡量算法的效率吧？</strong></li>
</ul>
<h4 id="1-2-4算法效率的度量"><a href="#1-2-4算法效率的度量" class="headerlink" title="1.2.4算法效率的度量"></a><strong>1.2.4算法效率的度量</strong></h4><h5 id="1-2-4-1事后统计法"><a href="#1-2-4-1事后统计法" class="headerlink" title="1.2.4.1事后统计法"></a><strong>1.2.4.1事后统计法</strong></h5><ul>
<li>主要通过设计好的测试程序和数据，利用计算机的计时器对不同算法的编制的程序的运行时间进行比较，从而确定算法效率的高低。</li>
</ul>
<ul>
<li><p>统计方法</p>
<ul>
<li>比较不同算法对同一组输入数据的运行处理时间。</li>
</ul>
</li>
</ul>
<ul>
<li><p>缺陷 </p>
<ul>
<li>为了获得不同算法的运行时间必须编写相应程序</li>
</ul>
</li>
</ul>
<ul>
<li>运行时间严重依赖硬件以及运行时的环境因素</li>
</ul>
<ul>
<li>算法的测试数据的选取相当困难</li>
</ul>
<ul>
<li><p>总结</p>
<ul>
<li>事后统计法虽然直观，但是实施困难且缺陷多</li>
</ul>
</li>
</ul>
<h5 id="1-2-4-2事前分析估算"><a href="#1-2-4-2事前分析估算" class="headerlink" title="1.2.4.2事前分析估算"></a><strong>1.2.4.2事前分析估算</strong></h5><ul>
<li>在计算机程序编制前，依据统计方法对算法进行估算。</li>
</ul>
<ul>
<li><p>统计方法：</p>
<ul>
<li>依据统计的方法对算法效率进行估算</li>
</ul>
</li>
<li><p>影响算法效率的主要因素：</p>
<ul>
<li>算法采用的策略和方法</li>
<li>问题的输入规模</li>
<li>编译器所产生的代码</li>
<li>计算机执行速度</li>
</ul>
</li>
</ul>
<p><strong>算法推倒的理论基础：</strong></p>
<ul>
<li>算法最终编译成具体的计算机指令</li>
<li>每一个指令，在具体的计算机上运行速度固定</li>
<li>通过具体的步骤，就可以推导出算法的复杂度（如下表）</li>
</ul>
<table>
<thead>
<tr>
<th><strong>次数</strong></th>
<th><strong>算法C（4n+8）</strong></th>
<th><strong>算法C’（n）</strong></th>
<th><strong>算法D（2n^2+1）</strong></th>
<th><strong>算法D1(n^2)</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>n = 1</strong></td>
<td><strong>12</strong></td>
<td><strong>1</strong></td>
<td><strong>3</strong></td>
<td><strong>1</strong></td>
</tr>
<tr>
<td><strong>n = 2</strong></td>
<td><strong>16</strong></td>
<td><strong>2</strong></td>
<td><strong>9</strong></td>
<td><strong>4</strong></td>
</tr>
<tr>
<td><strong>n = 3</strong></td>
<td><strong>20</strong></td>
<td><strong>3</strong></td>
<td><strong>19</strong></td>
<td><strong>9</strong></td>
</tr>
<tr>
<td><strong>n = 10</strong></td>
<td><strong>48</strong></td>
<td><strong>10</strong></td>
<td><strong>201</strong></td>
<td><strong>100</strong></td>
</tr>
<tr>
<td><strong>n = 100</strong></td>
<td><strong>408</strong></td>
<td><strong>100</strong></td>
<td><strong>20001</strong></td>
<td><strong>10000</strong></td>
</tr>
<tr>
<td><strong>n = 1000</strong></td>
<td><strong>4008</strong></td>
<td><strong>1000</strong></td>
<td><strong>2000001</strong></td>
<td><strong>1000000</strong></td>
</tr>
</tbody></table>
<p>​    </p>
<table>
<thead>
<tr>
<th><strong>次数</strong></th>
<th><strong>算法G（2n……^2）</strong></th>
<th><strong>算法H（3n+1）</strong></th>
<th><strong>算法I（2n^2+3n+1）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>n = 1</strong></td>
<td><strong>2</strong></td>
<td><strong>4</strong></td>
<td><strong>6</strong></td>
</tr>
<tr>
<td><strong>n = 2</strong></td>
<td><strong>8</strong></td>
<td><strong>7</strong></td>
<td><strong>15</strong></td>
</tr>
<tr>
<td><strong>n =</strong> <strong>5</strong></td>
<td><strong>50</strong></td>
<td><strong>16</strong></td>
<td><strong>66</strong></td>
</tr>
<tr>
<td><strong>n =</strong> <strong>10</strong></td>
<td><strong>200</strong></td>
<td><strong>31</strong></td>
<td><strong>231</strong></td>
</tr>
<tr>
<td><strong>n =</strong> <strong>100</strong></td>
<td><strong>20000</strong></td>
<td><strong>301</strong></td>
<td><strong>20301</strong></td>
</tr>
<tr>
<td><strong>n =</strong> <strong>1000</strong></td>
<td><strong>2000000</strong></td>
<td><strong>3001</strong></td>
<td><strong>2003001</strong></td>
</tr>
<tr>
<td><strong>n =</strong> <strong>10000</strong></td>
<td><strong>2000000000</strong></td>
<td><strong>30001</strong></td>
<td><strong>200030001</strong></td>
</tr>
<tr>
<td><strong>n =</strong> <strong>100000</strong></td>
<td><strong>20000000000</strong></td>
<td><strong>300001</strong></td>
<td><strong>20000300001</strong></td>
</tr>
<tr>
<td><strong>n =</strong> <strong>1000000</strong></td>
<td><strong>2000000000000</strong></td>
<td><strong>3000001</strong></td>
<td><strong>2000003000001</strong></td>
</tr>
</tbody></table>
<p><strong>怎么判断一个算法的效率?（规则如下）</strong></p>
<ul>
<li>判断一个算法的效率时，往往<strong>只需要关注操作数量的最高次项，其它次要项和常数项可以忽略。</strong></li>
</ul>
<ul>
<li>在没有特殊说明时，我们所分析的<strong>算法的时间复杂度都是指最坏时间复杂度</strong>。</li>
<li><strong>只有常数项记做1</strong></li>
<li><strong>操作数量的估算可以作为时间复杂度的估算</strong></li>
</ul>
<h5 id="1-2-4-3大O表示法"><a href="#1-2-4-3大O表示法" class="headerlink" title="1.2.4.3大O表示法"></a><strong>1.2.4.3大O表示法</strong></h5><ul>
<li>算法的时间复杂度<ul>
<li>常见的时间复杂度</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>执行次数函数</th>
<th>阶</th>
<th>非正式术语</th>
</tr>
</thead>
<tbody><tr>
<td>12</td>
<td>O(1)</td>
<td>常数阶</td>
</tr>
<tr>
<td>2n+3</td>
<td>O(n)</td>
<td>线性阶</td>
</tr>
<tr>
<td>3n^2+2n+1</td>
<td>O(n^2)</td>
<td>平方阶</td>
</tr>
<tr>
<td>5log2n+20</td>
<td>O(logn)</td>
<td>对数阶</td>
</tr>
<tr>
<td>2n+3nlog2n+19</td>
<td>O(nlogn)</td>
<td>nlogn阶</td>
</tr>
<tr>
<td>6n^3+2n^2+3n+4</td>
<td>O(n^3)</td>
<td>立方阶</td>
</tr>
<tr>
<td>2n</td>
<td>O(2^n)</td>
<td>指数阶</td>
</tr>
</tbody></table>
<ul>
<li>常见的时间复杂度之间的关系</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8CA4.tmp.jpg" alt="img"> </p>
<p>常用的时间复杂度所耗费的时间从小到大依次是：</p>
<p><strong>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)</strong></p>
<ul>
<li>时间复杂度练习( 参考算法的效率规则判断 )</li>
<li>O(5) = O(1)</li>
<li>O(2n + 1) = O(n) </li>
<li>O(6n²+ n + 1) = O(n²)</li>
<li>O(3n³+1) = O(n³)</li>
</ul>
<p><strong>总结:</strong></p>
<ul>
<li><p><strong>只关注最高次项</strong></p>
</li>
<li><p><strong>时间复杂度是指最坏时间复杂度</strong></p>
</li>
<li><p><strong>只有常数项记做1</strong></p>
</li>
<li><p>算法的空间复杂度</p>
<ul>
<li>算法的空间复杂度并不是计算所有算法所占的空间，而是使用的辅助空间的大小。</li>
</ul>
</li>
</ul>
<h2 id="2-线性表"><a href="#2-线性表" class="headerlink" title="2.线性表"></a><strong>2.线性表</strong></h2><h3 id="2-1线性表基本概念"><a href="#2-1线性表基本概念" class="headerlink" title="2.1线性表基本概念"></a><strong>2.1线性表基本概念</strong></h3><h4 id="2-1-1基本概念"><a href="#2-1-1基本概念" class="headerlink" title="2.1.1基本概念"></a><strong>2.1.1基本概念</strong></h4><p><strong>线性表是零个或者多个数据元素的有限序列</strong>。</p>
<p><strong>特性:</strong></p>
<ul>
<li>数据元素之间是<strong>有顺序的.</strong></li>
<li>数据元素个数是<strong>有限的.</strong></li>
<li>数据元素的<strong>类型必须相同.</strong></li>
</ul>
<p><strong>例：</strong>先来看一个大家感兴趣的话题，一年里的星座列表，是不是线性表呢？如图所示：</p>
<p><img src="http://qiniu.orangew.cn/img/wps8CA5.tmp.jpg" alt="img"> </p>
<h4 id="2-1-1数学定义"><a href="#2-1-1数学定义" class="headerlink" title="2.1.1数学定义"></a><strong>2.1.1数学定义</strong></h4><ul>
<li>线性表是具有相同类型的 n（ ≥ 0）个数据元素的有限序列（a0,a1, a2, …, an）</li>
</ul>
<p>ai是表项，n 是表长度。</p>
<h4 id="2-1-2性质"><a href="#2-1-2性质" class="headerlink" title="2.1.2性质"></a><strong>2.1.2性质</strong></h4><ul>
<li>a0为线性表的第一个元素，只有一个后继。</li>
<li>an为线性表的最后一个元素，只有一个前驱。</li>
<li>除a0和an外的其它元素ai，既有前驱，又有后继。</li>
<li>线性表能够逐项访问和顺序存取。</li>
</ul>
<h4 id="2-1-3线性表的操作"><a href="#2-1-3线性表的操作" class="headerlink" title="2.1.3线性表的操作"></a><strong>2.1.3线性表的操作</strong></h4><ul>
<li>创建线性表</li>
<li>销毁线性表</li>
<li>清空线性表</li>
<li>将元素插入线性表</li>
<li>将元素从线性表中删除</li>
<li>获取线性表中某个位置的元素</li>
<li>获取线性表的长度</li>
</ul>
<p>线性表的抽象数据类型定义：</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ADT线性表（List）
Data
线性表的数据对象集合为&#123; a1, a2, ……, an &#125;，每个元素的类型均为DataType。其中，除第一个元素a1外，每个元素有且只有一个直接前驱元素，除了最后一个元素an外，每个元素有且只有一个直接后继元素。数据元素之间的关系是一一对应的。

Operation（操作）
&#x2F;&#x2F; 初始化，建立一个空的线性表L。
InitList(*L);
&#x2F;&#x2F; 若线性表为空，返回true，否则返回false
ListEmpty(L);
&#x2F;&#x2F; 将线性表清空
ClearList(*L);
&#x2F;&#x2F; 将线性表L中的第i个位置的元素返回给e
GetElem(L, i, *e);
&#x2F;&#x2F; 在线性表L中的第i个位置插入新元素e
ListInsert(*L, i, e);
&#x2F;&#x2F; 删除线性表L中的第i个位置元素，并用e返回其值
ListDelete(*L, i, *e);
&#x2F;&#x2F; 返回线性表L的元素个数
ListLength(L);
&#x2F;&#x2F; 销毁线性表
DestroyList(*L);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-2线性表的顺序存储"><a href="#2-2线性表的顺序存储" class="headerlink" title="2.2线性表的顺序存储"></a><strong>2.2线性表的顺序存储</strong></h3><h4 id="2-2-1线性表顺序存储基本概念"><a href="#2-2-1线性表顺序存储基本概念" class="headerlink" title="2.2.1线性表顺序存储基本概念"></a><strong>2.2.1线性表顺序存储基本概念</strong></h4><ul>
<li>线性表的顺序存储结构，指的是<strong>用一段地址连续的存储单元依次存储线性表的数据元素</strong>。</li>
</ul>
<ul>
<li>线性表 （a1，a2，……，an）的顺序存储示意图如下：</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8CA6.tmp.jpg" alt="img"> </p>
<h4 id="2-2-2线性表顺序存储的设计与实现"><a href="#2-2-2线性表顺序存储的设计与实现" class="headerlink" title="2.2.2线性表顺序存储的设计与实现"></a><strong>2.2.2线性表顺序存储的设计与实现</strong></h4><p><strong>操作要点:</strong></p>
<ul>
<li><p>插入元素算法</p>
<ul>
<li>判断线性表是否合法</li>
<li>判断插入位置是否合法</li>
<li>把最后一个元素到插入位置的元素后移一个位置</li>
<li>将新元素插入</li>
<li>线性表长度加1</li>
</ul>
</li>
<li><p>获取元素操作</p>
<ul>
<li>判断线性表是否合法</li>
<li>判断位置是否合法</li>
<li>直接通过数组下标的方式获取元素</li>
</ul>
</li>
<li><p>删除元素算法</p>
<ul>
<li>判断线性表是否合法</li>
<li>判断删除位置是否合法</li>
<li>将元素取出</li>
<li>将删除位置后的元素分别向前移动一个位置</li>
<li>线性表长度减1</li>
</ul>
</li>
</ul>
<p><strong>链表顺序存储插入算法和删除算法:</strong></p>
<ul>
<li>元素的插入</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8CB7.tmp.jpg" alt="img"> </p>
<ul>
<li>元素的删除</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8CB8.tmp.jpg" alt="img"> </p>
<ul>
<li><strong>注意:</strong> <strong>链表的容量和链表的长度是两个不同的概念</strong></li>
</ul>
<h4 id="2-2-3优点和缺点"><a href="#2-2-3优点和缺点" class="headerlink" title="2.2.3优点和缺点"></a><strong>2.2.3优点和缺点</strong></h4><p><strong>优点：</strong></p>
<ul>
<li>无需为线性表中的逻辑关系增加额外的空间。</li>
<li>可以快速的获取表中合法位置的元素。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>插入和删除操作需要移动大量元素。</li>
<li>当线性表长度变化较大的时候，难以确定存储空间的容量。 </li>
</ul>
<h4 id="2-2-4-线性表顺序存储案例"><a href="#2-2-4-线性表顺序存储案例" class="headerlink" title="2.2.4 线性表顺序存储案例"></a><strong>2.2.4 线性表顺序存储案例</strong></h4><p><strong>动态数组案例:</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

#define MYARRAY_TRUE 1
#define MYARRAY_FALSE 0

&#x2F;&#x2F;定义结构体 保存数据首地址和数组长度
typedef struct MyArray&#123;
	int* ArrayAddr; &#x2F;&#x2F;数据首地址
	int capacity; &#x2F;&#x2F;数据容量
	int length; &#x2F;&#x2F;数据长度
&#125;MyArray;


&#x2F;&#x2F;初始化数组
MyArray* Init_MyArray()&#123;

	MyArray* array &#x3D; (MyArray*)malloc(sizeof(MyArray)); &#x2F;&#x2F;给数组结构体分配内存
	array-&gt;ArrayAddr &#x3D; (int*)malloc(sizeof(int)*20); &#x2F;&#x2F;初始化分配内存20个int类型长度
	if (array-&gt;ArrayAddr &#x3D;&#x3D; NULL)&#123;
		printf(&quot;申请内存失败!\n&quot;);
		return NULL;
	&#125;
	memset(array-&gt;ArrayAddr, 0, sizeof(int)* 20); &#x2F;&#x2F;初始化内存空间
	array-&gt;capacity &#x3D; 20; &#x2F;&#x2F;初始化数据容量
	array-&gt;length &#x3D; 0; &#x2F;&#x2F;初始化长度为0

	return array; &#x2F;&#x2F;成功返回数组指针
&#125;

&#x2F;&#x2F;判断数组是否为空 0:false 不为空  1:true 为空
int IsEmpty_MyArray(MyArray* array)&#123;

	if (array &#x3D;&#x3D; NULL)&#123;
		return -1;
	&#125;
	if (array-&gt;length &#x3D;&#x3D; 0)&#123;
		return MYARRAY_TRUE;
	&#125;
	return MYARRAY_FALSE;
&#125;

&#x2F;&#x2F;清空数组
int Clear_MyArray(MyArray* array)&#123;
	
	if (array &#x3D;&#x3D; NULL)&#123;
		return -1;
	&#125;
	if (array-&gt;ArrayAddr !&#x3D; NULL)&#123;
		memset(array-&gt;ArrayAddr, 0, array-&gt;capacity*sizeof(int)); &#x2F;&#x2F;重新初始化内存空间
	&#125;
	array-&gt;length &#x3D; 0;

	return 0;
&#125;

&#x2F;&#x2F;获得指定位置元素
int GetElement_MyArray(MyArray* array,int pos)&#123;

	if (array &#x3D;&#x3D; NULL)&#123;
		return -1;
	&#125;
	if (pos &gt; array-&gt;length-1)&#123;
		printf(&quot;数组访问越界!\n&quot;);
		return -2;
	&#125;

	return array-&gt;ArrayAddr[pos];
&#125;

&#x2F;&#x2F;向指定位置插入元素
int InsertElement_MyArray(MyArray* array, int pos,int val)&#123;

	if (array &#x3D;&#x3D; NULL)&#123;
		return -1;
	&#125;
	&#x2F;&#x2F;判断是否插入越界
	if (pos &gt; array-&gt;length)&#123;
		printf(&quot;元素插入位置不合法!\n&quot;);
		return -2;
	&#125;
	&#x2F;&#x2F;判断当前是否还有容量，没有的话，重新申请内存空间
	if (array-&gt;length &#x3D;&#x3D; array-&gt;capacity)&#123;
		&#x2F;&#x2F;申请新的内存空间
		int* newSpaceAddr &#x3D; (int*)malloc(array-&gt;capacity * 2 * sizeof(int)); 
		&#x2F;&#x2F;将原内存空间数据拷贝到新的空间
		memcpy(newSpaceAddr,array-&gt;ArrayAddr,array-&gt;length*sizeof(int));
		&#x2F;&#x2F;释放旧内存空间的内存
		if (NULL !&#x3D; array-&gt;ArrayAddr)&#123;
			free(array-&gt;ArrayAddr);
		&#125;
		&#x2F;&#x2F;让ArrayAddr重新指向新的内存空间
		array-&gt;ArrayAddr &#x3D; newSpaceAddr;
		&#x2F;&#x2F;更新容量
		array-&gt;capacity &#x3D; array-&gt;capacity * 2;
	&#125;
	&#x2F;&#x2F;插入元素
	&#x2F;&#x2F;第一步 移动元素
	for (int i &#x3D; array-&gt;length-1; i &gt;&#x3D; pos; i--)&#123;
		array-&gt;ArrayAddr[i + 1] &#x3D; array-&gt;ArrayAddr[i];
	&#125;
	&#x2F;&#x2F;第二部 在Pos位置插入元素
	array-&gt;ArrayAddr[pos] &#x3D; val;
	array-&gt;length++;

	return 0;
&#125;

&#x2F;&#x2F;删除指定位置元素
int RemoevElement_MyArray(MyArray* array, int pos)&#123;

	if (array &#x3D;&#x3D; NULL)&#123;
		return -1;
	&#125;
	&#x2F;&#x2F;移动元素
	for (int i &#x3D; pos; i &lt; array-&gt;length; i ++)&#123;
		array-&gt;ArrayAddr[i] &#x3D; array-&gt;ArrayAddr[i + 1];
	&#125;
	array-&gt;length--;

	return 0;
&#125;

&#x2F;&#x2F;获得链表长度
int GetLength_MyArray(MyArray* array)&#123;

	if (array &#x3D;&#x3D; NULL)&#123;
		return -1;
	&#125;
	return array-&gt;length;
&#125;

&#x2F;&#x2F;获得链表容量
int GetCapacity_MyArray(MyArray* array)&#123;

	if (array &#x3D;&#x3D; NULL)&#123;
		return -1;
	&#125;
	return array-&gt;capacity;
&#125;

&#x2F;&#x2F;打印数组内容
void PrintArray_MyArray(MyArray* array)&#123;

	for (int i &#x3D; 0; i &lt; array-&gt;length;i++)&#123;
		printf(&quot;%d &quot;,array-&gt;ArrayAddr[i]);
	&#125;
	printf(&quot;\n&quot;);
&#125;

&#x2F;&#x2F;销毁数组
int DestroyArray_MyArray(MyArray* array)&#123;

	if (array &#x3D;&#x3D; NULL)&#123;
		return -1;
	&#125;
	if (array-&gt;ArrayAddr !&#x3D; NULL)&#123;
		delete array-&gt;ArrayAddr;
		array-&gt;ArrayAddr &#x3D; NULL;
	&#125;
	array-&gt;capacity &#x3D; 0;
	array-&gt;length &#x3D; 0;
	
	&#x2F;&#x2F;销毁数组
	delete array;

	return 0;
&#125;

&#x2F;&#x2F;测试API
void test01()&#123;
	
	MyArray* array &#x3D; Init_MyArray(); &#x2F;&#x2F;初始化数组
	&#x2F;&#x2F;打印数组容量和长度
	printf(&quot;数组初始化长度:%d ,容量:%d\n&quot;,GetLength_MyArray(array),GetCapacity_MyArray(array));
	&#x2F;&#x2F;循环向数组中插入元素
	for (int i &#x3D; 10; i &lt;&#x3D; 300;i++)&#123;
		InsertElement_MyArray(array,0,i);
	&#125;
	printf(&quot;数组插入元素长度:%d ,容量:%d\n&quot;, GetLength_MyArray(array), GetCapacity_MyArray(array));
	&#x2F;&#x2F;打印数组
	PrintArray_MyArray(array);
	&#x2F;&#x2F;删除位置10的元素
	RemoevElement_MyArray(array,10);
	&#x2F;&#x2F;打印数组
	PrintArray_MyArray(array);
	printf(&quot;数组插入元素长度:%d ,容量:%d\n&quot;, GetLength_MyArray(array), GetCapacity_MyArray(array));
	&#x2F;&#x2F;销毁数组
	DestroyArray_MyArray(array);
&#125;

int main()&#123;

	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-3线性表的链式存储"><a href="#2-3线性表的链式存储" class="headerlink" title="2.3线性表的链式存储"></a><strong>2.3线性表的链式存储</strong></h3><h4 id="2-3-1基本概念"><a href="#2-3-1基本概念" class="headerlink" title="2.3.1基本概念"></a><strong>2.3.1基本概念</strong></h4><ul>
<li>链式存储定义</li>
<li>为了表示每个数据元素与其直接后继元素之间的逻辑关系，每个元素除了存储本身的信息外，还需要存储指示其直接后继的信息。</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8CC8.tmp.jpg" alt="img"> </p>
<ul>
<li>单链表<ul>
<li>线性表的链式存储结构中，每个节点中只包含一个指针域，这样的链表叫单链表。</li>
<li>通过每个节点的指针域将线性表的数据元素按其逻辑次序链接在一起（如图）。</li>
</ul>
</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8CC9.tmp.jpg" alt="img"> </p>
<ul>
<li>概念解释：<ul>
<li>表头结点<ul>
<li>链表中的第一个结点，包含指向第一个数据元素的指针以及链表自身的一些信息</li>
</ul>
</li>
<li> 数据结点</li>
<li>链表中代表数据元素的结点，包含指向下一个数据元素的指针和数据元素的信息</li>
<li>尾结点<ul>
<li>链表中的最后一个数据结点，其下一元素指针为空，表示无后继。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8CCA.tmp.jpg" alt="img"> </p>
<h4 id="2-3-2设计与实现"><a href="#2-3-2设计与实现" class="headerlink" title="2.3.2设计与实现"></a><strong>2.3.2设计与实现</strong></h4><p><strong>插入操作</strong></p>
<p><img src="http://qiniu.orangew.cn/img/wps8CCB.tmp.jpg" alt="img"> </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">node-&gt;next &#x3D; current-&gt;next;
current-&gt;next &#x3D; node;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>删除操作</strong></p>
<p><img src="http://qiniu.orangew.cn/img/wps8CDC.tmp.jpg" alt="img"> </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">current-&gt;next &#x3D; ret-&gt;next<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h4 id="2-3-3优点和缺点"><a href="#2-3-3优点和缺点" class="headerlink" title="2.3.3优点和缺点"></a><strong>2.3.3优点和缺点</strong></h4><p><strong>优点：</strong></p>
<ul>
<li>无需一次性定制链表的容量 n 插入和删除操作无需移动数据元素</li>
</ul>
<p> <strong>缺点：</strong></p>
<ul>
<li>数据元素必须保存后继元素的位置信息n 获取指定数据的元素操作需要顺序访问之前的元素</li>
</ul>
<h4 id="2-3-4链表技术领域推演-能力提高"><a href="#2-3-4链表技术领域推演-能力提高" class="headerlink" title="2.3.4链表技术领域推演(能力提高)"></a><strong>2.3.4链表技术领域推演(能力提高)</strong></h4><p><img src="http://qiniu.orangew.cn/img/wps8CDD.tmp.jpg" alt="img"> </p>
<h4 id="2-3-5企业链表-通用链表-单向链表-案例"><a href="#2-3-5企业链表-通用链表-单向链表-案例" class="headerlink" title="2.3.5企业链表/通用链表(单向链表)案例"></a><strong>2.3.5企业链表/通用链表(单向链表)案例</strong></h4><ul>
<li>头文件LinkList.h</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef LINKLIST_H
#define LINKLIST_H

#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;
#define LINK_TRUE 1
#define LINK_FALSE 0

&#x2F;&#x2F;链表结点
typedef struct _ListNode&#123;
	struct _ListNode* next;
&#125;ListNode;

&#x2F;&#x2F;表头结点
typedef struct _LinkList&#123;
	ListNode header; &#x2F;&#x2F;头结点
	int length; &#x2F;&#x2F;链表长度
&#125;LinkList;
&#x2F;&#x2F;打印回调函数
typedef void(*PrintLinkListData)(ListNode*);
&#x2F;&#x2F;初始化链表
LinkList* InitLinkList();
&#x2F;&#x2F;销毁链表
void DestroyLinkList(LinkList* list);
&#x2F;&#x2F;链表中在指定位置插入结点
int InsertLinkList(LinkList* list, int pos, ListNode* node);
&#x2F;&#x2F;删除指定位置结点
int DeleteLinkList(LinkList* list, int pos);
&#x2F;&#x2F;链表是否为空
int IsEmptyLinkList(LinkList* list);
&#x2F;&#x2F;返回链表长度
int GetLengthLinkList(LinkList* list);
&#x2F;&#x2F;清空链表
void ClearLinkList(LinkList* list);
&#x2F;&#x2F;打印链表结点
void PrintLinkList(LinkList* list, PrintLinkListData print);
&#x2F;&#x2F;获得指定位置的结点
ListNode* GetNodeLinkList(LinkList* list, int pos);
#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>C文件LinkList.c</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&quot;LinkList.h&quot;


&#x2F;&#x2F;初始化链表
LinkList* InitLinkList()&#123;

	LinkList* list &#x3D; (LinkList*)malloc(sizeof(LinkList));
	if (list &#x3D;&#x3D; NULL)&#123;
		return NULL;
	&#125;
	list-&gt;header.next &#x3D; NULL;
	list-&gt;length &#x3D; 0;

	return list;

&#125;
&#x2F;&#x2F;销毁链表
void DestroyLinkList(LinkList* list)&#123;
	if (NULL !&#x3D; list)&#123;
		list-&gt;header.next &#x3D; NULL;
		list-&gt;length &#x3D; 0;
		free(list);
	&#125;
&#125;
&#x2F;&#x2F;链表中在指定位置插入结点
int InsertLinkList(LinkList* list, int pos, ListNode* node)&#123;

	ListNode* current &#x3D; &amp;(list-&gt;header);
	&#x2F;&#x2F;如果pos位置超出链表长度，那么就插入到最后一个位置
	if (pos &gt; list-&gt;length) pos &#x3D; list-&gt;length;
	&#x2F;&#x2F;找到插入的位置
	for (int i &#x3D; 0; i &lt; pos; i ++)&#123;
		current &#x3D; current-&gt;next;
	&#125;
	&#x2F;&#x2F;新节点插入到pos位置
	node-&gt;next &#x3D; current-&gt;next;
	current-&gt;next &#x3D; node;

	list-&gt;length++;
	
	return 0;
&#125;
&#x2F;&#x2F;删除指定位置结点
int DeleteLinkList(LinkList* list, int pos)&#123;

	if (pos &gt; list-&gt;length-1)&#123;
		printf(&quot;删除位置%d不合法!\n&quot;,pos);
		return -1;
	&#125;
	ListNode* current &#x3D; &amp;(list-&gt;header);
	&#x2F;&#x2F;找到要删除的位置
	for (int i &#x3D; 0; i &lt; pos; i++)&#123;
		current &#x3D; current-&gt;next;
	&#125;
	&#x2F;&#x2F;要删除的结点
	ListNode* delNode &#x3D; current-&gt;next;
	&#x2F;&#x2F;删除结点
	current-&gt;next &#x3D; delNode-&gt;next;

	list-&gt;length--;

	return 0;
&#125;

&#x2F;&#x2F;链表是否为空
int IsEmptyLinkList(LinkList* list)&#123;
	if (list-&gt;length &#x3D;&#x3D; 0)&#123;
		return LINK_TRUE;
	&#125;
	return LINK_FALSE;
&#125;
&#x2F;&#x2F;返回链表长度
int GetLengthLinkList(LinkList* list)&#123;
	return list-&gt;length;
&#125;
&#x2F;&#x2F;清空链表
void ClearLinkList(LinkList* list)&#123;
	list-&gt;header.next &#x3D; NULL;
	list-&gt;length &#x3D; 0;
&#125;
&#x2F;&#x2F;打印链表结点
void PrintLinkList(LinkList* list, PrintLinkListData print)&#123;
	
	ListNode* current &#x3D; (&amp;(list-&gt;header))-&gt;next;
	while (current !&#x3D; NULL)&#123;
		print(current);
		current &#x3D; current-&gt;next;
	&#125;
	printf(&quot;-----------------------------\n&quot;);

&#125;

&#x2F;&#x2F;获得指定位置的结点
ListNode* GetNodeLinkList(LinkList* list, int pos)&#123;
	
	if (pos &gt; list-&gt;length-1)&#123;
		printf(&quot;位置%d不合法!\n&quot;,pos);
		return NULL;
	&#125;

	ListNode* current &#x3D; &amp;(list-&gt;header);
	for (int i &#x3D; 0; i &lt;&#x3D; pos; i ++)&#123;
		current &#x3D; current-&gt;next;
	&#125;
	return current;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>测试文件</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

#include&quot;LinkList.h&quot;

typedef struct _Teacher&#123;
	ListNode node;
	char name[128];
	int age;
&#125;Teacher;

void PrintTeacher(ListNode* node)&#123;
	Teacher* teacher &#x3D; (Teacher*)node;
	printf(&quot;Name:%s Age:%d\n&quot;, teacher-&gt;name, teacher-&gt;age);
&#125;

&#x2F;&#x2F;测试链表API
void test01()&#123;

	&#x2F;&#x2F;初始化链表
	LinkList* list &#x3D; InitLinkList();

	&#x2F;&#x2F;创建数据
	Teacher t1, t2, t3;
	t1.age &#x3D; 10;
	t2.age &#x3D; 20;
	t3.age &#x3D; 30;
	strcpy(t1.name, &quot;aaa&quot;);
	strcpy(t2.name, &quot;bbb&quot;);
	strcpy(t3.name, &quot;ccc&quot;);

	&#x2F;&#x2F;向链表中插入数据
	InsertLinkList(list, 0, (ListNode*)&amp;t1);
	InsertLinkList(list, 0, (ListNode*)&amp;t2);
	InsertLinkList(list, 0, (ListNode*)&amp;t3);
	&#x2F;&#x2F;打印链表内容
	PrintLinkList(list, PrintTeacher);
	&#x2F;&#x2F;删除位置1的结点
	DeleteLinkList(list,2);
	&#x2F;&#x2F;打印链表内容
	PrintLinkList(list, PrintTeacher);
	&#x2F;&#x2F;获得位置1的结点
	Teacher* node &#x3D; (Teacher*)GetNodeLinkList(list, 1);
	printf(&quot;位置1结点为:\n&quot;);
	printf(&quot;Name:%s Age:%d\n&quot;, node-&gt;name, node-&gt;age);

	&#x2F;&#x2F;销毁链表
	DestroyLinkList(list);
&#125;
int main()&#123;

	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-4循环链表"><a href="#2-4循环链表" class="headerlink" title="2.4循环链表"></a><strong>2.4循环链表</strong></h3><h4 id="2-4-1循环链表基本概念"><a href="#2-4-1循环链表基本概念" class="headerlink" title="2.4.1循环链表基本概念"></a><strong>2.4.1循环链表基本概念</strong></h4><ul>
<li>链表中最后一个结点的指针域指向头结点，整个链表形成一个环。</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8CEE.tmp.jpg" alt="img"> </p>
<h4 id="2-4-2循环链表设计与实现"><a href="#2-4-2循环链表设计与实现" class="headerlink" title="2.4.2循环链表设计与实现"></a><strong>2.4.2循环链表设计与实现</strong></h4><p><strong>插入元素分析</strong></p>
<ul>
<li>普通插入元素（和单链表是一样的）</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8CEF.tmp.jpg" alt="img"> </p>
<ul>
<li>尾插法（和单链表是一样的，单链表的写法支持尾插法</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8CF0.tmp.jpg" alt="img"> </p>
<p><strong>分析：最后一个结点的next指针指向新添加的结点，新结点的next指向第一个结点。</strong></p>
<ul>
<li>头插法</li>
</ul>
<p><strong>分析：</strong></p>
<p><strong>新节点指向当前的第一个结点</strong></p>
<p><strong>尾结点指向新节点</strong></p>
<p><img src="http://qiniu.orangew.cn/img/wps8CF1.tmp.jpg" alt="img"> </p>
<ul>
<li> 第一次插入结点</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8CF2.tmp.jpg" alt="img"> </p>
<p><strong>尾节点指针指向第一个数据节点（即自己指向自己）</strong></p>
<ul>
<li><strong>删除结点分析</strong></li>
</ul>
<ul>
<li>删除普通结点</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8D02.tmp.jpg" alt="img"> </p>
<ul>
<li>删除头结点</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8D03.tmp.jpg" alt="img"> </p>
<p>更新head结点，并且尾结点重新连接新的头结点</p>
<h4 id="2-4-3循环链表案例"><a href="#2-4-3循环链表案例" class="headerlink" title="2.4.3循环链表案例"></a><strong>2.4.3循环链表案例</strong></h4><ul>
<li>头文件CircleLinkList.h</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef CIRCLELINKLIST_H
#define CIRCLELINKLIST_H

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

typedef void(*CIRCLEPRINT)(void*);
#define CIRCLE_TRUE 1
#define CIRCLE_FALSE 0

&#x2F;&#x2F;循环链表结点
typedef struct _CircleLinkNode&#123;

	void* data;
	struct _CircleLinkNode* next;

&#125;CircleLinkNode;

&#x2F;&#x2F;链表
typedef struct _DoubleLinkList&#123;

	CircleLinkNode* head; &#x2F;&#x2F;头结点
	CircleLinkNode* rear; &#x2F;&#x2F;尾节点
	int length;

&#125;CircleLinkList;

&#x2F;&#x2F;循环链表初始化
CircleLinkNode* CircleLinkList_Init();
&#x2F;&#x2F;循环链表插入数据
void CircleLinkList_Insert(CircleLinkList* dlist, int pos, void* data);
&#x2F;&#x2F;循环链表删除数据
void CircleLinkList_Delete(CircleLinkList* dlist, int pos);
&#x2F;&#x2F;销毁链表
void CircleLinkList_Destroy(CircleLinkList* dlist);
&#x2F;&#x2F;打印链表
void CircleLinkList_Print(CircleLinkList* dlist, CIRCLEPRINT print);
&#x2F;&#x2F;获得链表长度
int CircleLinkList_Length(CircleLinkList* dlist);
&#x2F;&#x2F;判断链表是否为空
int CircleLinkList_Length(CircleLinkList* dlist);
&#x2F;&#x2F;清空链表
void CircleLinkList_Clear(CircleLinkList* dlist);

#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>C文件CircleLinkList.c</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&quot;CircleLinkList.h&quot;

&#x2F;&#x2F;循环链表初始化
CircleLinkNode* CircleLinkList_Init()&#123;
	
	&#x2F;&#x2F;链表结构体分配内存
	CircleLinkList* dlist &#x3D; (CircleLinkList*)malloc(sizeof(CircleLinkList));
	if (dlist &#x3D;&#x3D; NULL)&#123;
		return NULL;
	&#125;
	&#x2F;&#x2F;创建头结点 创建头结点 是为了空链表和非空链表处理一致
	CircleLinkNode* head &#x3D; (CircleLinkNode*)malloc(sizeof(CircleLinkNode));
	if (head &#x3D;&#x3D; NULL)&#123;
		if (dlist !&#x3D; NULL)&#123;
			free(dlist);
		&#125;
		return NULL;
	&#125;
	head-&gt;data &#x3D; NULL;
	head-&gt;next &#x3D; NULL;
	&#x2F;&#x2F;初始化链表
	dlist-&gt;head &#x3D; head;
	dlist-&gt;rear &#x3D; head;
	dlist-&gt;length &#x3D; 0;

	return dlist;

&#125;
&#x2F;&#x2F;循环链表插入数据
void CircleLinkList_Insert(CircleLinkList* dlist, int pos, void* data)&#123;

	if (dlist &#x3D;&#x3D; NULL || data &#x3D;&#x3D; NULL || pos &lt; 0)&#123;
		return;
	&#125;

	if (pos &gt; dlist-&gt;length)&#123;
		pos &#x3D; dlist-&gt;length;
	&#125;

	&#x2F;&#x2F;辅助指针
	CircleLinkNode* pCurrent &#x3D; dlist-&gt;head;
	for (int i &#x3D; 0; i &lt; pos;i++)&#123;
		pCurrent &#x3D; pCurrent-&gt;next;
	&#125;

	&#x2F;&#x2F;创建新节点
	CircleLinkNode* newnode &#x3D; (CircleLinkNode*)malloc(sizeof(CircleLinkNode));
	if (newnode &#x3D;&#x3D; NULL)&#123;
		return;
	&#125;
	newnode-&gt;data &#x3D; data;
	newnode-&gt;next &#x3D; NULL;

	&#x2F;&#x2F;将新结点插入到链表中
	newnode-&gt;next &#x3D; pCurrent-&gt;next;
	pCurrent-&gt;next &#x3D; newnode;

	&#x2F;&#x2F;判断是否在尾部插入结点
	if (pCurrent &#x3D;&#x3D; dlist-&gt;rear)&#123;
		dlist-&gt;rear &#x3D; newnode;
		dlist-&gt;rear-&gt;next &#x3D; dlist-&gt;head;
	&#125;
	
	dlist-&gt;length++;
&#125;
&#x2F;&#x2F;循环链表删除数据
void CircleLinkList_Delete(CircleLinkList* dlist, int pos)&#123;

	if (dlist &#x3D;&#x3D; NULL || pos &lt; 0)&#123;
		return;
	&#125;

	if (pos &gt;&#x3D; dlist-&gt;length)&#123;
		return;
	&#125;

	&#x2F;&#x2F;赋值指针
	CircleLinkNode* pCurrent &#x3D; dlist-&gt;head;
	for (int i &#x3D; 0; i &lt; pos;i++)&#123;
		pCurrent &#x3D; pCurrent-&gt;next;
	&#125;
	&#x2F;&#x2F;缓存被删除结点
	CircleLinkNode* pDel &#x3D; pCurrent-&gt;next;
	&#x2F;&#x2F;重新建立前后结点关系
	pCurrent-&gt;next &#x3D; pDel-&gt;next;
	&#x2F;&#x2F;释放被删除结点内存
	free(pDel);

	&#x2F;&#x2F;链表结点数量减1
	dlist-&gt;length--;

&#125;
&#x2F;&#x2F;打印链表
void CircleLinkList_Print(CircleLinkList* dlist, CIRCLEPRINT print)&#123;
	
	CircleLinkNode* pCurrent &#x3D; dlist-&gt;head-&gt;next;
	while (pCurrent !&#x3D; dlist-&gt;head)&#123;
		print(pCurrent-&gt;data);
		pCurrent &#x3D; pCurrent-&gt;next;
	&#125;
&#125;
&#x2F;&#x2F;销毁链表
void CircleLinkList_Destroy(CircleLinkList* dlist)&#123;
	
	CircleLinkNode* pCurrent &#x3D; dlist-&gt;head;
	while (pCurrent!&#x3D;dlist-&gt;head)&#123;
		&#x2F;&#x2F;缓存被删除结点的下一个结点
		CircleLinkNode* pNext &#x3D; pCurrent-&gt;next;
		free(pCurrent);
		pCurrent &#x3D; pNext;
	&#125;

	free(dlist);
&#125;

&#x2F;&#x2F;获得链表长度
int CircleLinkList_Length(CircleLinkList* dlist)&#123;
	if (dlist &#x3D;&#x3D; NULL)&#123;
		return -1;
	&#125;
	return dlist-&gt;length;
&#125;
&#x2F;&#x2F;判断链表是否为空
int CircleLinkList_Length(CircleLinkList* dlist)&#123;
	if (dlist-&gt;length &#x3D;&#x3D; 0)&#123;
		return CIRCLE_TRUE;
	&#125;
	return CIRCLE_FALSE;
&#125;
&#x2F;&#x2F;清空链表
void CircleLinkList_Clear(CircleLinkList* dlist)&#123;

	CircleLinkNode* pCurrent &#x3D; dlist-&gt;head-&gt;next;
	while (pCurrent !&#x3D; dlist-&gt;head)&#123;
		CircleLinkNode* pNext &#x3D; pCurrent-&gt;next;
		free(pCurrent);
		pCurrent &#x3D; pNext;
	&#125;

	dlist-&gt;head-&gt;next &#x3D; NULL;
	dlist-&gt;rear &#x3D; dlist-&gt;head;
	dlist-&gt;length &#x3D; 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>测试文件</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&quot;CircleLinkList.h&quot;

typedef struct _Teacher&#123;
	int age;
	double salary;
&#125;Teacher;

&#x2F;&#x2F;打印回调函数
void ShowLinkList(void* data)&#123;
	Teacher* t &#x3D; (Teacher*)data;
	printf(&quot;age:%d salay:%f \n&quot;, t-&gt;age, t-&gt;salary);
&#125;

void test01()&#123;
	
	&#x2F;&#x2F;创建循环链表
	CircleLinkList* clist &#x3D;  CircleLinkList_Init();
	&#x2F;&#x2F;创建测试数据
	Teacher t1 &#x3D; &#123; 10, 200.0 &#125;;
	Teacher t2 &#x3D; &#123; 20, 300.0 &#125;;
	Teacher t3 &#x3D; &#123; 30, 400.0 &#125;;
	&#x2F;&#x2F;向循环链表中插入数据
	CircleLinkList_Insert(clist, 0, &amp;t1);
	CircleLinkList_Insert(clist, 0, &amp;t2);
	CircleLinkList_Insert(clist, 0, &amp;t3);
	CircleLinkList_Insert(clist, 0, &amp;t2);
	CircleLinkList_Insert(clist, 0, &amp;t3);
	&#x2F;&#x2F;打印链表
	CircleLinkList_Print(clist, ShowLinkList);
	&#x2F;&#x2F;删除链表结点
	CircleLinkList_Delete(clist,3);
	&#x2F;&#x2F;打印链表
	printf(&quot;-------------------\n&quot;);
	CircleLinkList_Print(clist, ShowLinkList);
	&#x2F;&#x2F;销毁链表
	CircleLinkList_Destroy(clist);
&#125;

int main()&#123;

	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="2-4-4循环链表应用-约瑟夫问题"><a href="#2-4-4循环链表应用-约瑟夫问题" class="headerlink" title="2.4.4循环链表应用(约瑟夫问题)"></a><strong>2.4.4循环链表应用(约瑟夫问题)</strong></h4><ul>
<li>约瑟夫问题-循环链表典型应用</li>
</ul>
<p><strong>例题：</strong>n 个人围成一个圆圈，首先第 1 个人从 1 开始一个人一个人顺时针报数，报到第 m 个人，令其出列。然后再从下一 个人开始从 1 顺时针报数，报到第 m 个人，再令其出列，…，如此下去，求出列顺序。</p>
<p><strong>假设：</strong> m = 8，n=3</p>
<p><img src="http://qiniu.orangew.cn/img/wps8D14.tmp.jpg" alt="img"></p>
<p><strong>实现代码(通过我们自己编写的循环链表库):</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&quot;CircleLinkList.h&quot;

typedef struct _Teacher&#123;
	int age;
	double salary;
&#125;Teacher;

&#x2F;&#x2F;打印回调函数
void ShowLinkList(void* data)&#123;
	
	Teacher* t &#x3D; (Teacher*)data;
	printf(&quot;age:%d salay:%f \n&quot;, t-&gt;age, t-&gt;salary);

&#125;

void ShowData(void* data)&#123;
	printf(&quot;%d &quot;,(int)data);
&#125;

&#x2F;&#x2F;约瑟夫问题
void test02()&#123;

	&#x2F;&#x2F;m表示8个人 n表示第几个出列
	int m &#x3D; 8;
	int n &#x3D; 3;
	&#x2F;&#x2F;创建循环链表
	CircleLinkList* clist &#x3D; CircleLinkList_Init();
	for (int i &#x3D; 1; i &lt;&#x3D; m; i ++)&#123;
		CircleLinkList_Insert(clist,i,i);
	&#125;
	&#x2F;&#x2F;打印循环链表
	CircleLinkList_Print(clist, ShowData);
	printf(&quot;\n&quot;);
	CircleLinkNode* pCurrent &#x3D; clist-&gt;head;
	int index &#x3D; 0;
	while (pCurrent)&#123;
		if (index &#x3D;&#x3D; n)&#123;
			index &#x3D; 1;
			printf(&quot;%d &quot;,(int)pCurrent-&gt;data);
			&#x2F;&#x2F;缓存删除结点的下一个结点
			CircleLinkNode* pNext &#x3D; pCurrent-&gt;next;
			if (pNext &#x3D;&#x3D; clist-&gt;head)&#123;
				pNext &#x3D; pNext-&gt;next;
			&#125;
			CircleLinkList_DeleteByValue(clist, pCurrent-&gt;data);
			pCurrent &#x3D; pNext;
			if (CircleLinkList_Length(clist) &#x3D;&#x3D; 1)&#123;
				printf(&quot;%d &quot;, (int)pCurrent-&gt;data);
				break;
			&#125;
		&#125;

		pCurrent &#x3D; pCurrent-&gt;next;
		if (pCurrent &#x3D;&#x3D; clist-&gt;head)&#123;
			pCurrent &#x3D; pCurrent-&gt;next;
		&#125;
		index++;
	&#125;

	&#x2F;&#x2F;销毁链表
	CircleLinkList_Destroy(clist);
&#125;

int main()&#123;

	&#x2F;&#x2F;test01();
	test02();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="2-4-5优缺点分析"><a href="#2-4-5优缺点分析" class="headerlink" title="2.4.5优缺点分析"></a><strong>2.4.5优缺点分析</strong></h4><ul>
<li>优点<ul>
<li>功能增强了（循环链表只是在单链表的基础上做了一个加强）</li>
<li>循环链表可以完全取代单链表的使用</li>
<li>循环链表的Next和Current操作可以高效的遍历链表中的所有元素</li>
</ul>
</li>
<li>缺点<ul>
<li>代码复杂度提高了（成也萧何败萧何）</li>
</ul>
</li>
</ul>
<h3 id="2-5双向链表"><a href="#2-5双向链表" class="headerlink" title="2.5双向链表"></a><strong>2.5双向链表</strong></h3><h4 id="2-5-1双向链表基本概念"><a href="#2-5-1双向链表基本概念" class="headerlink" title="2.5.1双向链表基本概念"></a><strong>2.5.1双向链表基本概念</strong></h4><ul>
<li><p><strong>请思考</strong>： 为什么<strong>需要</strong>双向链表？</p>
<ul>
<li><p>单链表的结点都只有一个指向下一个结点的指针</p>
</li>
<li><p>单链表的数据元素无法直接访问其前驱元素</p>
</li>
<li><p> <strong>逆序访问单链表</strong>中的元素是极其<strong>耗时</strong>的操作！（如图）</p>
</li>
</ul>
</li>
<li><p> 双向链表的定义</p>
</li>
<li><p>在单链表的结点中增加一个指向其前驱的pre指针。</p>
</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8D15.tmp.jpg" alt="img"> </p>
<h4 id="2-5-2双向链表设计与实现"><a href="#2-5-2双向链表设计与实现" class="headerlink" title="2.5.2双向链表设计与实现"></a><strong>2.5.2双向链表设计与实现</strong></h4><ul>
<li> 插入操作</li>
<li>在普通位置插入节点</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8D16.tmp.jpg" alt="img"> </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">current-&gt;next &#x3D; node;
node-&gt;next &#x3D; next;
next-&gt;pre &#x3D; node;
node-&gt;pre &#x3D; current;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li> <strong>在空链表中插入节点</strong></li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8D26.tmp.jpg" alt="img"> </p>
<ul>
<li><p><strong>插入操作异常处理</strong></p>
<ul>
<li><strong>在空链表中插入新的元素</strong></li>
<li><strong>空节点（NULL）没有前驱指针；</strong></li>
<li> <strong>新节点的前驱指针，需要指向NULL；</strong></li>
</ul>
</li>
<li><p>删除操作</p>
</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8D27.tmp.jpg" alt="img"> </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">current-&gt;next &#x3D; next;
next-&gt;pre &#x3D; current;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li> <strong>删除操作异常处理：当双向链表仅有一个节点的时候</strong></li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8D28.tmp.jpg" alt="img"> </p>
<p><strong>如果辅助指针变量pNext == NULL，那么pNext是没有前驱操作的。空指针既没有前驱也没有后继。</strong></p>
<h4 id="2-5-3双向链表案例"><a href="#2-5-3双向链表案例" class="headerlink" title="2.5.3双向链表案例"></a><strong>2.5.3双向链表案例</strong></h4><ul>
<li>DoubleLinkList.h</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">v#ifndef DOUBLELINKLIST_H
#define DOUBLELINKLIST_H

#define DOUBLE_FALSE 0
#define DOUBLE_TRUE 1

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

&#x2F;&#x2F;链表结点
typedef struct _DOUBLELISTNODE&#123;
	void* data;
	struct _DOUBLELISTNODE* next;
	struct _DOUBLELISTNODE* prev;
&#125;DoubleListNode;

&#x2F;&#x2F;头结点
typedef struct _DOUBLELINKLIST&#123;
	DoubleListNode* head; &#x2F;&#x2F;首结点
	DoubleListNode* rear; &#x2F;&#x2F;尾结点
	int length; &#x2F;&#x2F;链表长度
&#125;DoubleLinkList;

&#x2F;&#x2F;打印回调函数
typedef void(*PrintDoubleLinkListNode)(DoubleListNode*);

&#x2F;&#x2F;双向链表初始化
DoubleLinkList* InitDoubleLinkList();
&#x2F;&#x2F;销毁双向链表
void DestroyDoubleLinkList(DoubleLinkList* dlist);
&#x2F;&#x2F;向链表中插入结点
int InsertDoubleLinkList(DoubleLinkList* dlist, int pos, void* data);
&#x2F;&#x2F;打印链表
void PrintDoubleListNode(DoubleLinkList* dlist, PrintDoubleLinkListNode* print,int IsReverse);
&#x2F;&#x2F;获得链表长度
int GetLengthDoubleLinkList(DoubleLinkList* dlist);
&#x2F;&#x2F;判断链表是否为空
int IsEmptyDoubleLinkList(DoubleLinkList* dlist);

#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>DoubleLinkList.c</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&quot;DoubleLinkList.h&quot;


&#x2F;&#x2F;双向链表初始化
DoubleLinkList* InitDoubleLinkList()&#123;

	DoubleLinkList* dlist &#x3D; (DoubleLinkList*)malloc(sizeof(DoubleLinkList));
	if (dlist &#x3D;&#x3D; NULL)&#123;
		return NULL;
	&#125;

	dlist-&gt;head &#x3D; NULL;
	dlist-&gt;rear &#x3D; NULL;
	dlist-&gt;length &#x3D; 0;

	return dlist;
&#125;
&#x2F;&#x2F;销毁双向链表
void DestroyDoubleLinkList(DoubleLinkList* dlist)&#123;

&#125;
&#x2F;&#x2F;向链表中插入结点
int InsertDoubleLinkList(DoubleLinkList* dlist, int pos, void* data)&#123;

	&#x2F;&#x2F;创建新的结点
	DoubleListNode* newnode &#x3D; (DoubleListNode*)malloc(sizeof(DoubleListNode));
	newnode-&gt;data &#x3D; data;
	newnode-&gt;next &#x3D; NULL;
	newnode-&gt;prev &#x3D; NULL;

	&#x2F;&#x2F;第一次插入
	if (dlist-&gt;head &#x3D;&#x3D; NULL &amp;&amp; dlist-&gt;rear &#x3D;&#x3D; NULL)&#123;
		dlist-&gt;head &#x3D; newnode;
		dlist-&gt;rear &#x3D; newnode;

		&#x2F;&#x2F;初始化head结点前驱和后继结点
		dlist-&gt;head-&gt;next &#x3D; NULL;
		dlist-&gt;head-&gt;prev &#x3D; NULL;
		&#x2F;&#x2F;初始化rear结点的前驱和后继结点
		dlist-&gt;rear-&gt;next &#x3D; NULL;
		dlist-&gt;rear-&gt;prev &#x3D; NULL;

		dlist-&gt;length++;
		return 0;
	&#125;

	&#x2F;&#x2F;头插法
	if (pos &#x3D;&#x3D; 0)&#123;
		newnode-&gt;prev &#x3D; NULL;
		newnode-&gt;next &#x3D; dlist-&gt;head;

		dlist-&gt;head-&gt;prev &#x3D; newnode;
		dlist-&gt;head &#x3D; newnode;

		dlist-&gt;length++;
		return 0;
	&#125;

	&#x2F;&#x2F;尾差法
	if (pos &gt;&#x3D; dlist-&gt;length)&#123;
		
		dlist-&gt;rear-&gt;next &#x3D; newnode;
		newnode-&gt;prev &#x3D; dlist-&gt;rear;
		newnode-&gt;next &#x3D; NULL;
		dlist-&gt;rear &#x3D; newnode;
		dlist-&gt;length++;
		return 0;
	&#125;
	
	&#x2F;&#x2F;其他插入
	DoubleListNode* pPrev &#x3D; dlist-&gt;head;
	DoubleListNode* pCurrent &#x3D; pPrev-&gt;next;
	for (int i &#x3D; 1; i &lt; pos;i++)&#123;
		pPrev &#x3D; pCurrent;
		pCurrent &#x3D; pPrev-&gt;next;
	&#125;

	newnode-&gt;next &#x3D; pCurrent;
	pCurrent-&gt;prev &#x3D; newnode;

	pPrev-&gt;next &#x3D; newnode;
	newnode-&gt;prev &#x3D; pPrev;

	dlist-&gt;length++;

	return 0;
&#125;
&#x2F;&#x2F;打印链表
void PrintDoubleListNode(DoubleLinkList* dlist, PrintDoubleLinkListNode print, int IsReverse)&#123;

	DoubleListNode* pCurrent &#x3D; NULL;
	&#x2F;&#x2F;true表示 逆序遍历
	if (IsReverse &#x3D;&#x3D; DOUBLE_TRUE)&#123;
		pCurrent &#x3D; dlist-&gt;rear;
		while (pCurrent !&#x3D; NULL)&#123;
			print(pCurrent);
			pCurrent &#x3D; pCurrent-&gt;prev;
		&#125;
	&#125;
	else&#123;
		pCurrent &#x3D; dlist-&gt;head;
		while (pCurrent !&#x3D; NULL)&#123;
			print(pCurrent);
			pCurrent &#x3D; pCurrent-&gt;next;
		&#125;
	&#125;
	printf(&quot;----------------------------\n&quot;);
&#125;
&#x2F;&#x2F;获得链表长度
int GetLengthDoubleLinkList(DoubleLinkList* dlist)&#123;
	return dlist-&gt;length;
&#125;
&#x2F;&#x2F;判断链表是否为空
int IsEmptyDoubleLinkList(DoubleLinkList* dlist)&#123;
	return DOUBLE_TRUE;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>测试文件</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&quot;DoubleLinkList.h&quot;


typedef struct _TEAHCER&#123;
	char name[64];
	int age;
&#125;Teacher;

void PrintNode(DoubleListNode* node)&#123;
	Teacher* teacher &#x3D; (Teacher*)(node-&gt;data);
	printf(&quot;Name:%s Age:%d\n&quot;,teacher-&gt;name,teacher-&gt;age);
&#125;

&#x2F;&#x2F;测试双向链表函数
void test01()&#123;

	&#x2F;&#x2F;创建双向链表
	DoubleLinkList* dlist &#x3D; InitDoubleLinkList();
	&#x2F;&#x2F;创建数据
	Teacher t1, t2, t3;
	t1.age &#x3D; 10;
	t2.age &#x3D; 20;
	t3.age &#x3D; 30;
	strcpy(t1.name, &quot;aaa&quot;);
	strcpy(t2.name, &quot;bbb&quot;);
	strcpy(t3.name, &quot;ccc&quot;);
	&#x2F;&#x2F;插入数据
	InsertDoubleLinkList(dlist, 0, &amp;t1);
	InsertDoubleLinkList(dlist, 10, &amp;t2);
	InsertDoubleLinkList(dlist, 0, &amp;t3);
	&#x2F;&#x2F;打印数据
	printf(&quot;----------正向遍历----------\n&quot;);
	PrintDoubleListNode(dlist, PrintNode, DOUBLE_FALSE);
	printf(&quot;----------逆序遍历----------\n&quot;);
	PrintDoubleListNode(dlist, PrintNode,DOUBLE_TRUE);

&#125;

int main()&#123;
	test01();
	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="2-5-4优点和缺点"><a href="#2-5-4优点和缺点" class="headerlink" title="2.5.4优点和缺点"></a><strong>2.5.4优点和缺点</strong></h4><ul>
<li><p>优点：</p>
</li>
<li><p>双向链表在单链表的基础上增加了指向前驱的指针</p>
</li>
<li><p>功能上双向链表可以完全取代单链表的使用</p>
</li>
<li><p>双向链表的Next，Pre和Current操作可以高效的遍历链表中的所有元素</p>
</li>
<li><p>缺点:</p>
</li>
<li><p>代码复杂</p>
</li>
</ul>
<h3 id="3-受限线性表"><a href="#3-受限线性表" class="headerlink" title="3.受限线性表"></a><strong>3.受限线性表</strong></h3><h3 id="3-1栈-Stack"><a href="#3-1栈-Stack" class="headerlink" title="3.1栈(Stack)"></a><strong>3.1栈(Stack)</strong></h3><h4 id="3-1-1栈的基本概念"><a href="#3-1-1栈的基本概念" class="headerlink" title="3.1.1栈的基本概念"></a><strong>3.1.1栈的基本概念</strong></h4><ul>
<li>概念：</li>
</ul>
<ul>
<li>首先它是一个线性表，也就是说，栈元素具有线性关系，即前驱后继关系。只不过<strong>它是一种特殊的线性表</strong>而已。定义中说是在线性表的表尾进行插入和删除操作，这里表尾是指栈顶，而不是栈底。</li>
</ul>
<ul>
<li>特性</li>
</ul>
<ul>
<li><p><strong>它的特殊之处在于限制了这个线性表的插入和删除的位置，它始终只在栈顶进行。这也就使得：栈底是固定的，最先进栈的只能在栈底。</strong></p>
</li>
<li><p>操作</p>
</li>
</ul>
<ul>
<li>栈的插入操作，叫做进栈，也成压栈。类似子弹入弹夹（如下图所示）</li>
</ul>
<ul>
<li>栈的删除操作，叫做出栈，也有的叫做弾栈，退栈。如同弹夹中的子弹出夹（如下图所示）</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8D39.tmp.jpg" alt="img"> </p>
<ul>
<li>创建栈</li>
<li>销毁栈</li>
<li>清空栈</li>
<li>进栈</li>
<li>出栈</li>
<li>获取栈顶元素</li>
<li>获取栈的大小 </li>
</ul>
<p>栈的抽象数据类型</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ADT 栈（stack）
Data
	通线性表。元素具有相同的类型，相邻的元素具有前驱和后继关系。
Operation
	&#x2F;&#x2F; 初始化，建立一个空栈S
	InitStack(*S);
	&#x2F;&#x2F; 若栈存在，则销毁它
	DestroyStack(*S);
	&#x2F;&#x2F; 将栈清空
	ClearStack(*S);
	&#x2F;&#x2F; 若栈为空则返回true，否则返回false
	StackEmpty(S);
	&#x2F;&#x2F; 若栈存在且非空，用e返回S的栈顶元素
	GetTop(S，*e);
	&#x2F;&#x2F; 若栈S存在，插入新元素e到栈S中并成为其栈顶元素
	Push(*S，e);
	&#x2F;&#x2F; 删除栈S中的栈顶元素，并用e返回其值
	Pop（*S, *e）;
	&#x2F;&#x2F; 返回栈S的元素个数
	StackLength(S);
endADT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="http://qiniu.orangew.cn/img/wps8D4A.tmp.jpg" alt="img"> </p>
<h4 id="3-1-2栈的顺序存储"><a href="#3-1-2栈的顺序存储" class="headerlink" title="3.1.2栈的顺序存储"></a><strong>3.1.2栈的顺序存储</strong></h4><p> <strong>基本概念</strong></p>
<ul>
<li>栈的顺序存储结构简称顺序栈，它是运算受限制的顺序表。顺序栈的存储结构是：<strong>利用一组地址连续的的存储单元依次存放自栈底到栈顶的数据元素</strong>，同时附设指针top只是栈顶元素在顺序表中的位置。</li>
</ul>
<p> <strong>设计与实现</strong></p>
<ul>
<li><p><strong>因为栈是一种特殊的线性表，所以栈的顺序存储可以通过顺序线性表来实现。</strong></p>
</li>
<li><p>SqStack.h</p>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef SQSTACK_H
#define SQSTACK_H

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

#define STACK_FALSE 0
#define STACK_TRUE 1

#define MAX 256
&#x2F;&#x2F;栈结构体
typedef struct _SQSTACK&#123;
	void* data[MAX];
	int length;
&#125;SqStack;

&#x2F;&#x2F;初始化顺序栈
SqStack* InitSqStack();
&#x2F;&#x2F;销毁栈
void DestroySqStack(SqStack* stack);
&#x2F;&#x2F;弹出栈顶元素
void PopSqStack(SqStack* stack);
&#x2F;&#x2F;获得栈顶元素
void* TopSqStack(SqStack* stack);
&#x2F;&#x2F;获得栈中元素个数
int GetLengthSqStack(SqStack* stack);
&#x2F;&#x2F;栈中是否为空
int IsEmptySqStack(SqStack* stack);
&#x2F;&#x2F;向栈中添加元素
int PushSqStack(SqStack* stack,void* data);

#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>SqStack.c</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&quot;SqStack.h&quot;

&#x2F;&#x2F;初始化顺序栈
SqStack* InitSqStack()&#123;
	SqStack* stack &#x3D; (SqStack*)malloc(sizeof(SqStack));
	if (stack &#x3D;&#x3D; NULL)&#123;
		return NULL;
	&#125;
	&#x2F;&#x2F;初始化
	for (int i &#x3D; 0; i &lt; MAX; i++)&#123;
		stack-&gt;data[i] &#x3D; 0;
	&#125;
	stack-&gt;length &#x3D; 0;

	return stack;
&#125;
&#x2F;&#x2F;销毁栈
void DestroySqStack(SqStack* stack)&#123;
	if (NULL !&#x3D; stack)&#123;
		free(stack);
		stack &#x3D; NULL;
	&#125;
&#125;
&#x2F;&#x2F;弹出栈顶元素
void PopSqStack(SqStack* stack)&#123;
	stack-&gt;data[stack-&gt;length - 1] &#x3D; 0;
	stack-&gt;length--;
&#125;
&#x2F;&#x2F;获得栈顶元素
void* TopSqStack(SqStack* stack)&#123;
	return stack-&gt;data[stack-&gt;length - 1];
&#125;
&#x2F;&#x2F;获得栈中元素个数
int GetLengthSqStack(SqStack* stack)&#123;
	return stack-&gt;length;
&#125;
&#x2F;&#x2F;栈中是否为空
int IsEmptySqStack(SqStack* stack)&#123;
	if (stack-&gt;length &#x3D;&#x3D; 0)&#123;
		return STACK_TRUE;
	&#125;
	return STACK_FALSE;
&#125;
&#x2F;&#x2F;向栈中添加元素
int PushSqStack(SqStack* stack, void* data)&#123;

	if (stack-&gt;length &gt; MAX)&#123;
		return -1;
	&#125;
	stack-&gt;data[stack-&gt;length] &#x3D; data;
	stack-&gt;length++;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>测试文件</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&quot;SqStack.h&quot;

typedef struct _TEAHCER&#123;
	char name[64];
	int age;
&#125;Teacher;

void test01()&#123;

	&#x2F;&#x2F;创建空栈
	SqStack* stack &#x3D; InitSqStack();
	&#x2F;&#x2F;创建数据
	Teacher t1, t2, t3;
	t1.age &#x3D; 10;
	t2.age &#x3D; 20;
	t3.age &#x3D; 30;
	strcpy(t1.name, &quot;aaa&quot;);
	strcpy(t2.name, &quot;bbb&quot;);
	strcpy(t3.name, &quot;ccc&quot;);
	&#x2F;&#x2F;向栈中添加元素
	PushSqStack(stack, &amp;t1);
	PushSqStack(stack, &amp;t3);
	PushSqStack(stack, &amp;t2);
	&#x2F;&#x2F;打印栈中元素个数
	printf(&quot;栈元素个数:%d\n&quot;, GetLengthSqStack(stack));
	&#x2F;&#x2F;遍历栈中元素
	while (GetLengthSqStack(stack) &gt; 0)&#123;
		Teacher* teacher &#x3D;  (Teacher*)TopSqStack(stack);
		printf(&quot;Name:%s Age:%d\n&quot;,teacher-&gt;name,teacher-&gt;age);
		PopSqStack(stack);
	&#125;
	&#x2F;&#x2F;打印栈中元素个数
	printf(&quot;栈元素个数:%d\n&quot;,GetLengthSqStack(stack));
	&#x2F;&#x2F;销毁栈
	DestroySqStack(stack);

&#125;

int main()&#123;

	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="3-1-3栈的链式存储"><a href="#3-1-3栈的链式存储" class="headerlink" title="3.1.3栈的链式存储"></a><strong>3.1.3栈的链式存储</strong></h4><p> <strong>基本概念</strong></p>
<ul>
<li>栈的链式存储结构简称链栈。</li>
</ul>
<p><strong>思考如下问题</strong>：</p>
<ul>
<li>栈只是栈顶来做插入和删除操作，栈顶放在链表的头部还是尾部呢？</li>
</ul>
<ul>
<li>由于单链表有头指针，而栈顶指针也是必须的，那干嘛不让他俩合二为一呢，所以比较好的办法就是把栈顶放在单链表的头部。另外都已经有了栈顶在头部了，单链表中比较常用的头结点也就失去了意义，通常对于链栈来说，是不需要头结点的。</li>
</ul>
<p> <strong>设计与实现</strong></p>
<ul>
<li>链栈是一种特殊的线性表，链栈可以通过链式线性表来实现。</li>
</ul>
<ul>
<li>LinkStack.h</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef LINKSTACK_H
#define LINKSTACK_H

#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;

#define STACK_FALSE 0
#define STACK_TRUE 1

&#x2F;&#x2F;链栈结点
typedef struct _LINKNODE&#123;
	void* data;
	struct _LINKNODE* next;
&#125;LinkNode;
&#x2F;&#x2F;头结点
typedef struct _LINKSTACK&#123;
	LinkNode* head;
	int length;
&#125;LinkStack;

&#x2F;&#x2F;初始化链栈
LinkStack* InitLinkStack();
&#x2F;&#x2F;销毁链栈
void DestroyLinkStack(LinkStack* lstack);
&#x2F;&#x2F;获得栈顶元素
void* TopLinkStack(LinkStack* lstack);
&#x2F;&#x2F;弹出栈顶元素
void PopLinkStack(LinkStack* lstack);
&#x2F;&#x2F;获得栈元素个数
int GetLengthLinkStack(LinkStack* lstack);
&#x2F;&#x2F;向栈中加入元素
int PushLinkStack(LinkStack* lstack,void* data);
&#x2F;&#x2F;判断栈是否为空
int IsEmptyLinkStack(LinkStack* lstack);

#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>LinkStack.c</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&quot;LinkStack.h&quot;

&#x2F;&#x2F;初始化链栈
LinkStack* InitLinkStack()&#123;

	LinkStack* lstack &#x3D; (LinkStack*)malloc(sizeof(LinkStack));
	if (lstack &#x3D;&#x3D; NULL)&#123;
		return NULL;
	&#125;
	&#x2F;&#x2F;初始化
	lstack-&gt;head &#x3D; NULL;
	lstack-&gt;length &#x3D; 0;

	return lstack;
&#125;
&#x2F;&#x2F;销毁链栈
void DestroyLinkStack(LinkStack* lstack)&#123;
	
	while (!IsEmptyLinkStack(lstack))&#123;
		PopLinkStack(lstack);
	&#125;
	free(lstack);
&#125;
&#x2F;&#x2F;获得栈顶元素
void* TopLinkStack(LinkStack* lstack)&#123;
	return lstack-&gt;head-&gt;data;
&#125;
&#x2F;&#x2F;弹出栈顶元素
void PopLinkStack(LinkStack* lstack)&#123;
	if (lstack-&gt;length &#x3D;&#x3D; 0)&#123;
		return;
	&#125;
	&#x2F;&#x2F;缓存要删除的结点
	LinkNode* pDel &#x3D;  lstack-&gt;head;
	&#x2F;&#x2F;将被删除结点的下一个结点作为head结点
	lstack-&gt;head &#x3D; pDel-&gt;next;
	&#x2F;&#x2F;释放被删除结点内存
	free(pDel);
	&#x2F;&#x2F;结点数量减1
	lstack-&gt;length--;
&#125;
&#x2F;&#x2F;获得栈元素个数
int GetLengthLinkStack(LinkStack* lstack)&#123;
	return lstack-&gt;length;
&#125;
&#x2F;&#x2F;向栈中加入元素
int PushLinkStack(LinkStack* lstack, void* data)&#123;

	&#x2F;&#x2F;创建结点
	LinkNode* newnode &#x3D; (LinkNode*)malloc(sizeof(LinkNode));
	newnode-&gt;data &#x3D; data;
	newnode-&gt;next &#x3D; NULL;

	&#x2F;&#x2F;是否第一次插入元素
	if (lstack-&gt;head &#x3D;&#x3D; NULL)&#123;
		lstack-&gt;head &#x3D; newnode;
		lstack-&gt;length++;
		return 0;
	&#125;

	&#x2F;&#x2F;其他插入情况
	newnode-&gt;next &#x3D; lstack-&gt;head;
	lstack-&gt;head &#x3D; newnode;
	lstack-&gt;length++;

	return 0;
&#125;
&#x2F;&#x2F;判断栈是否为空
int IsEmptyLinkStack(LinkStack* lstack)&#123;
	if (lstack-&gt;length &#x3D;&#x3D; 0)&#123;
		return STACK_TRUE;
	&#125;
	return STACK_FALSE;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>测试文件</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&quot;LinkStack.h&quot;

typedef struct _TEAHCER&#123;
	char name[64];
	int age;
&#125;Teacher;

void test01()&#123;
	
	&#x2F;&#x2F;创建链栈
	LinkStack* lstack &#x3D; InitLinkStack();
	&#x2F;&#x2F;创建数据
	Teacher t1, t2, t3;
	t1.age &#x3D; 10;
	t2.age &#x3D; 20;
	t3.age &#x3D; 30;
	strcpy(t1.name, &quot;aaa&quot;);
	strcpy(t2.name, &quot;bbb&quot;);
	strcpy(t3.name, &quot;ccc&quot;);
	&#x2F;&#x2F;向栈中添加元素
	PushLinkStack(lstack, &amp;t1);
	PushLinkStack(lstack, &amp;t3);
	PushLinkStack(lstack, &amp;t2);
	&#x2F;&#x2F;打印链栈数据
	while (!IsEmptyLinkStack(lstack))&#123;
		Teacher* teacher &#x3D; (Teacher*)TopLinkStack(lstack);
		printf(&quot;Name:%s Age:%d\n&quot;,teacher-&gt;name,teacher-&gt;age);
		PopLinkStack(lstack);
	&#125;	
	&#x2F;&#x2F;销毁链表
	DestroyLinkStack(lstack);
&#125;

int main()&#123;

	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="3-1-4栈的应用-案例"><a href="#3-1-4栈的应用-案例" class="headerlink" title="3.1.4栈的应用(案例)"></a><strong>3.1.4栈的应用(案例)</strong></h4><p><strong>案例1: 就近匹配</strong></p>
<ul>
<li>几乎所有的编译器都具有检测括号是否匹配的能力，那么如何实现编译器中的符号成对检测？如下字符串: </li>
</ul>
<ul>
<li><p>#include &lt;stdio.h&gt; int main() { int a[4] [4]; int (*p)[4]; p = a[0]; return 0;}</p>
</li>
<li><p>算法思路</p>
</li>
<li><p>从第一个字符开始扫描</p>
</li>
<li><p>当遇见普通字符时忽略，</p>
</li>
<li><p>当遇见左符号时压入栈中</p>
</li>
<li><p>当遇见右符号时从栈中弹出栈顶符号，并进行匹配</p>
</li>
<li><p>匹配成功：继续读入下一个字符</p>
</li>
<li><p>匹配失败：立即停止，并报错</p>
</li>
<li><p>结束：</p>
</li>
<li><p>成功: 所有字符扫描完毕，且栈为空</p>
</li>
<li><p>失败：匹配失败或所有字符扫描完毕但栈非空</p>
</li>
<li><p>总结</p>
</li>
</ul>
<p> <strong>当需要检测成对出现但又互不相邻的事物时可以使用栈“后进先出”的特性</strong></p>
<p> <strong>栈非常适合于需要“就近匹配”的场合</strong></p>
<ul>
<li> 案例代码:</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&quot;LinkStack.h&quot;

&#x2F;&#x2F;案例一 就近匹配
void test02()&#123;

	char* str &#x3D; &quot;#include &lt;stdio.h&gt; int main() &#123; int a[4][4]; int (*p)[4]; p &#x3D; a[0]; return 0;&#125;&quot;;
	&#x2F;&#x2F;初始化栈
	LinkStack* lstack &#x3D; InitLinkStack();
	&#x2F;&#x2F;匹配括号
	char* pCurrent &#x3D; str;
	while (*pCurrent !&#x3D; &#39;\0&#39;)&#123;
		if (*pCurrent &#x3D;&#x3D; &#39;(&#39;)&#123;
			PushLinkStack(lstack, pCurrent);
		&#125;
		else if (*pCurrent &#x3D;&#x3D; &#39;)&#39;)&#123;
			char* p &#x3D; (char*)TopLinkStack(lstack);
			if (*p &#x3D;&#x3D; &#39;(&#39;)&#123;
				PopLinkStack(lstack);
			&#125;
		&#125;
		pCurrent++;
	&#125;
	if (GetLengthLinkStack(lstack) &gt; 0)&#123;
		printf(&quot;匹配失败!\n&quot;);
	&#125;
	&#x2F;&#x2F;销毁栈
	DestroyLinkStack(lstack);
&#125;

int main()&#123;

	test02();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> <strong>案例2：中缀表达式和后缀表达式</strong></p>
<ul>
<li><p>后缀表达式（由波兰科学家在20世纪50年代提出）</p>
</li>
<li><p><strong>将运算符放在数字后面 ===》 符合计算机运算</strong></p>
</li>
<li><p>我们习惯的数学表达式叫做中缀表达式===》符合人类思考习惯</p>
</li>
<li><p>实例</p>
<ul>
<li>5 + 4 =&gt; 5 4 + </li>
<li>1 + 2 * 3 =&gt; 1 2 3 * + </li>
<li>8 + ( 3 – 1 ) * 5 =&gt; 8 3 1 – 5 * +</li>
</ul>
</li>
<li><p>中缀转后缀算法：</p>
</li>
<li><p>遍历中缀表达式中的数字和符号：</p>
<ul>
<li><p>对于数字：直接输出</p>
</li>
<li><p>对于符号：</p>
</li>
<li><p>左括号：进栈 </p>
</li>
<li><p>运算符号：与栈顶符号进行优先级比较</p>
</li>
<li><p>若栈顶符号优先级低：此符号进栈 （默认栈顶若是左括号，左括号优先级最低）</p>
</li>
<li><p>若栈顶符号优先级不低：将栈顶符号弹出并输出，之后进栈</p>
</li>
<li><p>右括号：将栈顶符号弹出并输出，直到匹配左括号</p>
</li>
<li><p>遍历结束：将栈中的所有符号弹出并输出</p>
</li>
</ul>
</li>
<li><p>中缀转后缀伪代码 priority</p>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">transform(exp)
&#123;
	创建栈S；
	i&#x3D; 0；
	while(exp[i] !&#x3D; ‘\0’)
&#123;
		if(exp[i] 为数字)
		&#123;
			Output（exp[i]）;
		&#125;
		else if(exp[i] 为符号)
		&#123;
			while(exp[i]优先级 &lt;&#x3D; 栈顶符号优先级)
			&#123;
				output（栈顶符号）；
				Pop（S）;
			&#125;
			Push(S, exp[i]);
		&#125;
		else if(exp[i] 为左括号)
		&#123;
			Push(S, exp[i]);
		&#125;
		else if(exp[i] 为右括号)
		&#123;
			while(栈顶符号不为左括号)
			&#123;
				output（栈顶符号）；
				Pop（S）;
			&#125;
			从S中弹出左括号；
		&#125;
		else
		&#123;
			报错，停止循环；
		&#125;
		i++;
&#125;
while(size(S) &gt; 0 &amp;&amp; exp[i] &#x3D;&#x3D; ‘\0’)
&#123;
		output(栈顶符号)；
		Pop（S）;
&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>动手练习</li>
</ul>
<ul>
<li>将我们喜欢的读的中缀表达式转换成计算机喜欢的后缀表达式</li>
<li>中缀表达式: 8 + ( 3 – 1 ) * 5</li>
<li>后缀表达式: 8 3 1 – 5 * +</li>
</ul>
<p> <strong>案例3：计算机如何基于后缀表达式计算</strong></p>
<ul>
<li>思考 </li>
</ul>
<ul>
<li><p>计算机是如何基于后缀表达式计算的？</p>
</li>
<li><p>例如：8 3 1 – 5 * +</p>
</li>
<li><p>计算规则</p>
</li>
<li><p>遍历后缀表达式中的数字和符号</p>
</li>
<li><p>对于数字：进栈</p>
</li>
<li><p>对于符号：</p>
</li>
<li><p>从栈中弹出右操作数</p>
</li>
<li><p>从栈中弹出左操作数</p>
</li>
<li><p>根据符号进行运算</p>
</li>
<li><p>将运算结果压入栈中</p>
</li>
<li><p>遍历结束：栈中的唯一数字为计算结果</p>
</li>
<li><p>代码实现（伪代码） express</p>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">compute(exp)
&#123;
	创建栈；
	int i &#x3D; 0;
	while( exp[i] !&#x3D; ‘\0’)
	&#123;
		if（exp[i]为数字）
		&#123;
			Push（S, exp[i]）;
		&#125;
		else if(exp[i]为符号)
		&#123;
1. 从栈顶弹出右操作数；
2. 从栈中弹出左操作数；
3. 根据符号进行运算；
4. Push（stack， 结果）；
		&#125;
		else
		&#123;
			报错，停止循环；
		&#125;
		i++;
	&#125;
	if( Size(s) &#x3D;&#x3D; 1 &amp;&amp; exp[i] &#x3D;&#x3D; ‘\0’)
	&#123;
		栈中唯一的数字为运算结果；
	&#125;
	返回结果；
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="3-2队列-Queue"><a href="#3-2队列-Queue" class="headerlink" title="3.2队列(Queue)"></a><strong>3.2队列(Queue)</strong></h3><h4 id="3-2-1队列基本概念"><a href="#3-2-1队列基本概念" class="headerlink" title="3.2.1队列基本概念"></a><strong>3.2.1队列基本概念</strong></h4><ul>
<li>队列是一种特殊的受限制的线性表。 </li>
</ul>
<ul>
<li><p><strong>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</strong></p>
</li>
<li><p>队列是一种先进先出的（First In First Out）的线性表，简称FIFO。允许插入的一端为队尾，允许删除的一端为队头。队列不允许在中间部位进行操作！假设队列是q=（a1，a2，……，an），那么a1就是队头元素，而an是队尾元素。这样我们就可以删除时，总是从a1开始，而插入时，总是在队列最后。这也比较符合我们通常生活中的习惯，排在第一个的优先出列，最后来的当然排在队伍最后。如下图：</p>
</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8D4B.tmp.jpg" alt="img"> </p>
<h4 id="3-2-2队列常用操作"><a href="#3-2-2队列常用操作" class="headerlink" title="3.2.2队列常用操作"></a><strong>3.2.2队列常用操作</strong></h4><ul>
<li>创建队列</li>
<li>销毁队列</li>
<li>清空队列</li>
<li>进队列</li>
<li>出队列</li>
<li>获取队头元素</li>
<li>获取队列的长度</li>
</ul>
<p><strong>ADT</strong> 队列（Queue）</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ADT 队列（Queue）
Data
	通线性表。元素具有相同的类型，相邻元素具有前驱后继关系。
Operation
	&#x2F;&#x2F; 初始化操作，建立一个空队列Q
	InitQueue（*Q）；
	&#x2F;&#x2F; 若队列Q存储，则销毁它。
	DestroyQueue(*Q);
	&#x2F;&#x2F; 将队列Q清空
	ClearQueue(*Q);
	&#x2F;&#x2F; 若队列为空则返回true，否则返回false
	QueueEmpty(Q);
	&#x2F;&#x2F; 若队列Q存在且非空，用e返回队列Q的队头元素
	GetHead(Q, *e);
	&#x2F;&#x2F; 若队列Q存在，插入新元素e到队列Q中并成为队尾元素。
	EnQueue(*Q, e);
	&#x2F;&#x2F; 删除队列Q中的队头元素，并用e返回其值
	DeQueue(*Q, *e);
	&#x2F;&#x2F; 返回队列Q的元素个数
	QueueLength(Q);
endADT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="http://qiniu.orangew.cn/img/wps8D5B.tmp.jpg" alt="img"> </p>
<h4 id="3-2-3队列的顺序存储"><a href="#3-2-3队列的顺序存储" class="headerlink" title="3.2.3队列的顺序存储"></a><strong>3.2.3队列的顺序存储</strong></h4><ul>
<li> 基本概念</li>
</ul>
<ul>
<li>​    <strong>队列也是一种特殊的线性表；可以用线性表顺序存储来模拟队列。</strong></li>
</ul>
<ul>
<li>SqQueue.h</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef SQQUEUE_H
#define SQQUEUE_H

#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;

#define MAX 256
#define QUEUE_FALSE 0
#define QUEUE_TRUE 1

&#x2F;&#x2F;队列头结点
typedef struct _SQQUEUE&#123;
	void* data[MAX];
	int length;
&#125;SqQueue;

&#x2F;&#x2F;初始化空队列
SqQueue* InitSqQueue();
&#x2F;&#x2F;销毁队列
void DestroySqQueue(SqQueue* queue);
&#x2F;&#x2F;向队列中插入元素
int PushSqQueue(SqQueue* queue, void* data);
&#x2F;&#x2F;获得队列长度
int GetLengthSqQueue(SqQueue* queue);
&#x2F;&#x2F;获得对头元素
void* FrontSqQueue(SqQueue* queue);
&#x2F;&#x2F;从对头弹出元素
void PopSqQueue(SqQueue* queue);
&#x2F;&#x2F;判断队列是否为空
int IsEmptySqQueue(SqQueue* queue);

#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>SqQueue.c</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&quot;SqQueue.h&quot;


&#x2F;&#x2F;初始化空队列
SqQueue* InitSqQueue()&#123;

	SqQueue* queue &#x3D; (SqQueue*)malloc(sizeof(SqQueue));
	if (queue &#x3D;&#x3D; NULL)&#123;
		return NULL;
	&#125;
	&#x2F;&#x2F;初始化
	for (int i &#x3D; 0; i &lt; MAX;i++)&#123;
		queue-&gt;data[i] &#x3D; 0;
	&#125;
	queue-&gt;length &#x3D; 0;

	return queue;
&#125;
&#x2F;&#x2F;销毁队列
void DestroySqQueue(SqQueue* queue)&#123;
	if (queue !&#x3D; NULL)&#123;
		free(queue);
	&#125;
&#125;
&#x2F;&#x2F;向队列中插入元素
int PushSqQueue(SqQueue* queue, void* data)&#123;
	if (queue-&gt;length &gt;&#x3D; MAX)&#123;
		return -1;
	&#125;
	queue-&gt;data[queue-&gt;length] &#x3D; data;
	queue-&gt;length++;
&#125;
&#x2F;&#x2F;获得队列长度
int GetLengthSqQueue(SqQueue* queue)&#123;
	return queue-&gt;length;
&#125;
&#x2F;&#x2F;获得对头元素
void* FrontSqQueue(SqQueue* queue)&#123;
	return queue-&gt;data[0];
&#125;
&#x2F;&#x2F;从对头弹出元素
void PopSqQueue(SqQueue* queue)&#123;
	for (int i &#x3D; 0; i &lt; queue-&gt;length;i++)&#123;
		queue-&gt;data[i] &#x3D; queue-&gt;data[i + 1];
	&#125;
	queue-&gt;length--;
&#125;
&#x2F;&#x2F;判断队列是否为空
int IsEmptySqQueue(SqQueue* queue)&#123;
	if (queue-&gt;length &#x3D;&#x3D; 0)&#123;
		return QUEUE_TRUE;
	&#125;
	return QUEUE_FALSE;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>测试文件</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&quot;SqQueue.h&quot;

typedef struct _TEAHCER&#123;
	char name[64];
	int age;
&#125;Teacher;

void test01()&#123;
	
	&#x2F;&#x2F;创建队列
	SqQueue* queue &#x3D; InitSqQueue();
	&#x2F;&#x2F;创建数据
	Teacher t1, t2, t3;
	t1.age &#x3D; 10;
	t2.age &#x3D; 20;
	t3.age &#x3D; 30;
	strcpy(t1.name, &quot;aaa&quot;);
	strcpy(t2.name, &quot;bbb&quot;);
	strcpy(t3.name, &quot;ccc&quot;);
	&#x2F;&#x2F;队列中插入数据
	PushSqQueue(queue, &amp;t3);
	PushSqQueue(queue, &amp;t1);
	PushSqQueue(queue, &amp;t2);
	&#x2F;&#x2F;打印队列数据
	while (!IsEmptySqQueue(queue))&#123;
		Teacher* teacher &#x3D; (Teacher*)FrontSqQueue(queue);
		printf(&quot;Name:%s Age:%d\n&quot;,teacher-&gt;name,teacher-&gt;age);
		PopSqQueue(queue);
	&#125;
	&#x2F;&#x2F;销毁队列
	DestroySqQueue(queue);
&#125;

int main()&#123;

	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="3-2-4队列的链式存储"><a href="#3-2-4队列的链式存储" class="headerlink" title="3.2.4队列的链式存储"></a><strong>3.2.4队列的链式存储</strong></h4><p> <strong>基本概念</strong></p>
<p><strong>队列也是一种特殊的线性表；可以用线性表链式存储来模拟队列的链式存储。</strong> </p>
<p> <strong>LinkQueue.h</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef LINKQUEUE_H
#define LINKQUEUE_H

#define QUEUE_FALSE 0
#define QUEUE_TRUE 1

#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;

&#x2F;&#x2F;链表队列结点
typedef struct _LINKNODE&#123;
	void* data;
	struct _LINKNODE* next;
&#125;LinkNode;

&#x2F;&#x2F;链式队列头结点
typedef struct _LINKQUEUE&#123;
	LinkNode* head;
	int length;
&#125;LinkQueue;

&#x2F;&#x2F;初始化链式队列
LinkQueue* InitLinkQueue();
&#x2F;&#x2F;销毁链式队列
void DestroyLinkQueue(LinkQueue* lqueue);
&#x2F;&#x2F;向队尾插入结点
int PushLinkQueue(LinkQueue* lqueue,void* data);
&#x2F;&#x2F;返回对头数据
void* FrontLinkQueue(LinkQueue* lqueue);
&#x2F;&#x2F;弹出对头结点
void PopLinkQueue(LinkQueue* lqueue);
&#x2F;&#x2F;返回队列长度
int GetLengthLinkQueue(LinkQueue* lqueue);
&#x2F;&#x2F;判断队列是否为空
int IsEmptyLinkQueue(LinkQueue* lqueue);

#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li> <strong>LinkQueue.c</strong></li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&quot;LinkQueue.h&quot;

&#x2F;&#x2F;初始化链式队列
LinkQueue* InitLinkQueue()&#123;

	LinkQueue* lqueue &#x3D; (LinkQueue*)malloc(sizeof(LinkQueue));
	if (lqueue &#x3D;&#x3D; NULL)&#123;
		return NULL;
	&#125;

	lqueue-&gt;head &#x3D; NULL;
	lqueue-&gt;length &#x3D; 0;

	return lqueue;
&#125;
&#x2F;&#x2F;销毁链式队列
void DestroyLinkQueue(LinkQueue* lqueue)&#123;

	while (!IsEmptyLinkQueue(lqueue))&#123;
		PopLinkQueue(lqueue);
	&#125;
	free(lqueue);
&#125;
&#x2F;&#x2F;向队尾插入结点
int PushLinkQueue(LinkQueue* lqueue, void* data)&#123;

	&#x2F;&#x2F;创建新结点
	LinkNode* newnode &#x3D; (LinkNode*)malloc(sizeof(LinkNode));
	newnode-&gt;data &#x3D; data;
	newnode-&gt;next &#x3D; NULL;

	&#x2F;&#x2F;第一次插入
	if (lqueue-&gt;head &#x3D;&#x3D; NULL)&#123;
		lqueue-&gt;head &#x3D; newnode;
		lqueue-&gt;length++;
		return 0;
	&#125;

	&#x2F;&#x2F;其他插入
	newnode-&gt;next &#x3D; lqueue-&gt;head;
	lqueue-&gt;head &#x3D; newnode;
	lqueue-&gt;length++;

	return 0;
&#125;
&#x2F;&#x2F;返回对头数据
void* FrontLinkQueue(LinkQueue* lqueue)&#123;
	LinkNode* pCurrent &#x3D; lqueue-&gt;head;
	while (pCurrent-&gt;next !&#x3D; NULL)&#123;
		pCurrent &#x3D; pCurrent-&gt;next;
	&#125;
	return pCurrent-&gt;data;
&#125;
&#x2F;&#x2F;弹出对头结点
void PopLinkQueue(LinkQueue* lqueue)&#123;

	&#x2F;&#x2F;如果只有一个结点
	if (lqueue-&gt;length &#x3D;&#x3D; 1)&#123;
		free(lqueue-&gt;head);
		lqueue-&gt;head &#x3D; NULL;
		lqueue-&gt;length--;
		return;
	&#125;
	&#x2F;&#x2F;多于一个结点
	LinkNode* pPrev &#x3D; lqueue-&gt;head;
	LinkNode* pCurrent &#x3D; pPrev-&gt;next;
	while (pCurrent-&gt;next !&#x3D; NULL)&#123;
		pPrev &#x3D; pCurrent;
		pCurrent &#x3D; pPrev-&gt;next;
	&#125;
	free(pCurrent);
	pPrev-&gt;next &#x3D; NULL;
	lqueue-&gt;length--;
&#125;
&#x2F;&#x2F;返回队列长度
int GetLengthLinkQueue(LinkQueue* lqueue)&#123;
	return lqueue-&gt;length;
&#125;
&#x2F;&#x2F;判断队列是否为空
int IsEmptyLinkQueue(LinkQueue* lqueue)&#123;
	if (lqueue-&gt;length &#x3D;&#x3D; 0)&#123;
		return QUEUE_TRUE;
	&#125;
	return QUEUE_FALSE;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>测试文件</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&quot;LinkQueue.h&quot;


typedef struct _TEAHCER&#123;
	char name[64];
	int age;
&#125;Teacher;

void test01()&#123;
	
	&#x2F;&#x2F;创建链式队列
	LinkQueue* queue &#x3D; InitLinkQueue();
	&#x2F;&#x2F;创建数据
	Teacher t1, t2, t3;
	t1.age &#x3D; 10;
	t2.age &#x3D; 20;
	t3.age &#x3D; 30;
	strcpy(t1.name, &quot;aaa&quot;);
	strcpy(t2.name, &quot;bbb&quot;);
	strcpy(t3.name, &quot;ccc&quot;);
	&#x2F;&#x2F;链式队列插入数据
	PushLinkQueue(queue, &amp;t1);
	PushLinkQueue(queue, &amp;t3);
	PushLinkQueue(queue, &amp;t2);
	&#x2F;&#x2F;打印链式队列
	printf(&quot;链式队列长度:%d\n&quot;,GetLengthLinkQueue(queue));
	while (!IsEmptyLinkQueue(queue))&#123;
		Teacher* teacher &#x3D; (Teacher*)FrontLinkQueue(queue);
		printf(&quot;Name:%s Age:%d\n&quot;,teacher-&gt;name,teacher-&gt;age);
		PopLinkQueue(queue);
	&#125;
	printf(&quot;链式队列长度:%d\n&quot;, GetLengthLinkQueue(queue));
	&#x2F;&#x2F;销毁链式队列
	DestroyLinkQueue(queue);

&#125;

int main()&#123;
	
	test01();
	
	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="4-树和二叉树"><a href="#4-树和二叉树" class="headerlink" title="4.树和二叉树"></a><strong>4.树和二叉树</strong></h2><h3 id="4-1树的基本概念"><a href="#4-1树的基本概念" class="headerlink" title="4.1树的基本概念"></a><strong>4.1树的基本概念</strong></h3><p><img src="http://qiniu.orangew.cn/img/wps8D6C.tmp.jpg" alt="img"> </p>
<ul>
<li>树的定义：</li>
</ul>
<ul>
<li>由一个或多个(n≥0)结点组成的有限集合T，有且仅有一个结点称为根（root），当n&gt;1时，其余的结点分为<strong>m(m≥0)个互不相交的有限集合</strong>T1,T2，…，Tm。每个集合本身又是棵树，被称作这个根的子树 。</li>
</ul>
<ul>
<li>树的结构特点</li>
<li>非线性结构，有一个直接前驱，但可能有多个直接后继（1:n）</li>
<li>树的定义具有递归性，树中还有树。</li>
<li>树可以为空，即节点个数为0。</li>
<li>若干术语</li>
<li>根-&gt;即根结点(没有前驱)</li>
<li>叶子-&gt;即终端结点(没有后继)</li>
<li>森林-&gt;指m棵不相交的树的集合(例如删除A后的子树个数)</li>
<li>有序树-&gt;结点各子树从左至右有序，不能互换（左为第一）</li>
<li>无序树-&gt;结点各子树可互换位置。</li>
<li>双亲-&gt;即上层的那个结点(直接前驱) parent</li>
<li>孩子-&gt;即下层结点的子树 (直接后继) child</li>
<li>兄弟-&gt;同一双亲下的同层结点（孩子之间互称兄弟）sibling</li>
<li>堂兄弟-&gt;即双亲位于同一层的结点（但并非同一双亲）cousin</li>
<li>祖先-&gt;即从根到该结点所经分支的所有结点</li>
<li>子孙-&gt;即该结点下层子树中的任一结点</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8D6D.tmp.jpg" alt="img"> </p>
<ul>
<li>结点-&gt;即树的数据元素                       </li>
<li>结点的度-&gt;结点挂接的子树数（有几个直接后继就是几度）</li>
<li>结点的层次-&gt;从根到该结点的层数（根结点算第一层） </li>
<li>终端结点-&gt;即度为0的结点，即叶子       </li>
<li>分支结点-&gt;除树根以外的结点（也称为内部结点）</li>
<li>树的度-&gt;所有结点度中的最大值（Max{各结点的度}）    </li>
<li>树的深度(或高度) -&gt;指所有结点中最大的层数（Max{各结点的层次}）</li>
<li>上图中的结点数＝ 13，树的度＝ 3，树的深度＝ 4</li>
</ul>
<h3 id="4-2树的表示法"><a href="#4-2树的表示法" class="headerlink" title="4.2树的表示法"></a><strong>4.2树的表示法</strong></h3><h4 id="4-2-1图形表示法"><a href="#4-2-1图形表示法" class="headerlink" title="4.2.1图形表示法"></a><strong>4.2.1图形表示法</strong></h4><p><strong>事物之间的逻辑关系</strong>可以通过数的形式很直观的表示出来，如下图：</p>
<p><img src="http://qiniu.orangew.cn/img/wps8D6E.tmp.jpg" alt="img"> </p>
<h4 id="4-2-2广义表-表示法"><a href="#4-2-2广义表-表示法" class="headerlink" title="4.2.2广义表 表示法"></a><strong>4.2.2广义表 表示法</strong></h4><p><img src="http://qiniu.orangew.cn/img/wps8D7F.tmp.jpg" alt="img"> </p>
<ul>
<li>用广义表表示法表示上图：</li>
<li>中国（河北（保定，石家庄），广东（广州，东莞），山东（青岛，济南））</li>
<li><strong>根作为由子树森林组成的表的名字写在表的左边。</strong></li>
</ul>
<h4 id="4-2-3左孩子右兄弟表示法"><a href="#4-2-3左孩子右兄弟表示法" class="headerlink" title="4.2.3左孩子右兄弟表示法"></a><strong>4.2.3左孩子右兄弟表示法</strong></h4><p><img src="http://qiniu.orangew.cn/img/wps8D80.tmp.jpg" alt="img"> </p>
<ul>
<li>左孩子右兄弟表示法可以将一颗多叉树转化为一颗二叉树：</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8D81.tmp.jpg" alt="img"> </p>
<p>节点的结构：</p>
<p>​    <img src="http://qiniu.orangew.cn/img/wps8D82.tmp.jpg" alt="img"></p>
<p>节点有两个指针域，其中一个指针指向子节点，另一个指针指向其兄弟节点。</p>
<h3 id="4-3树的结构"><a href="#4-3树的结构" class="headerlink" title="4.3树的结构"></a><strong>4.3树的结构</strong></h3><h4 id="4-3-1树的逻辑结构"><a href="#4-3-1树的逻辑结构" class="headerlink" title="4.3.1树的逻辑结构"></a><strong>4.3.1树的逻辑结构</strong></h4><ul>
<li>树的逻辑结构特点：</li>
</ul>
<ul>
<li>一对多（1:n），有多个直接后继（如家谱树、目录树等等），但只有一个根结点，且子树之间互不相交。</li>
</ul>
<h4 id="4-3-2树的存储结构"><a href="#4-3-2树的存储结构" class="headerlink" title="4.3.2树的存储结构"></a><strong>4.3.2树的存储结构</strong></h4><ul>
<li><p>树的存储仍然有两种方式：</p>
</li>
<li><p> <strong>顺序存储</strong></p>
</li>
<li><p>可规定为：从上至下、从左至右将树的结点依次存入内存。</p>
</li>
</ul>
<ul>
<li><p>重大缺陷：复原<strong>困难</strong>（不能唯一复原就没有实用价值）。</p>
</li>
<li><p> <strong>链式存储</strong></p>
</li>
<li><p>可用多重链表：一个前趋指针，n个后继指针。</p>
</li>
</ul>
<ul>
<li>细节问题：树中结点的结构类型样式该如何设计？</li>
</ul>
<ul>
<li> 即应该设计成“等长”还是“不等长”？</li>
</ul>
<ul>
<li><p>缺点：等长结构太浪费（每个结点的度不一定相同）；</p>
</li>
<li><p>不等长结构太复杂（要定义好多种结构类型）。</p>
</li>
<li><p>以上两种存储方式都存在重大缺陷，应该如何解决呢？</p>
</li>
</ul>
<ul>
<li>计算机实现各种不同进制的运算是通过先研究最简单、最有规律的二进制运算规律，然后设法把各种不同进制的运算转化二进制运算。树的存储也可以通过先研究最简单、最有规律的树，然后设法把一般的树转化为这种简单的树，这种树就是<strong>二叉树</strong>。</li>
</ul>
<h3 id="4-4二叉树概念"><a href="#4-4二叉树概念" class="headerlink" title="4.4二叉树概念"></a><strong>4.4二叉树概念</strong></h3><h4 id="4-4-1二叉树基本概念"><a href="#4-4-1二叉树基本概念" class="headerlink" title="4.4.1二叉树基本概念"></a><strong>4.4.1二叉树基本概念</strong></h4><p> <strong>定义</strong>：</p>
<ul>
<li>n（n≥0）个结点的有限集合，由一个根结点以及两棵互不相交的、分别称为左子树和右子树的二叉树组成 。</li>
</ul>
<p> <strong>逻辑结构</strong>：</p>
<ul>
<li>一对二（1：2） </li>
</ul>
<p> <strong>基本特征:</strong></p>
<ul>
<li>每个结点最多只有两棵子树（<strong>不存在度大于2的结点</strong>）；</li>
</ul>
<ul>
<li>左子树和右子树次序不能颠倒（<strong>有序树</strong>）。</li>
</ul>
<p> <strong>基本形态:</strong></p>
<p><img src="http://qiniu.orangew.cn/img/wps8D83.tmp.jpg" alt="img"> </p>
<p> <strong>问题：</strong></p>
<ul>
<li>具有3个结点的二叉树可能有几种不同形态？普通树呢？</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8D84.tmp.jpg" alt="img"> </p>
<ul>
<li>二叉树可以画出五种形态，但是普通的数只能有两种形态。</li>
</ul>
<p> <strong>二叉树性质</strong></p>
<ul>
<li>性质1: 在二叉树的第i层上至多有2i-1个结点（i&gt;0）</li>
<li>性质2: 深度为k的二叉树至多有2k-1个结点（k&gt;0）</li>
<li>性质3: 对于任何一棵二叉树，若度为2的结点数有n2个，则叶子数（n0）必定为n2＋1 （即n0=n2+1）</li>
</ul>
<p><strong>概念解释</strong>：</p>
<p><strong>满二叉树</strong></p>
<ul>
<li>一棵深度为k 且有2^k -1个结点的二叉树。</li>
</ul>
<p>​    <strong>特点：每层都“充满”了结点</strong></p>
<p>​              <img src="http://qiniu.orangew.cn/img/wps8D95.tmp.jpg" alt="img"></p>
<p> <strong>完全二叉树</strong></p>
<ul>
<li>除最后一层外，每一层上的节点数均达到最大值；在最后一层上只缺少右边的若干结点。</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8D96.tmp.jpg" alt="img"> </p>
<p><strong>理解：k-1层与满二叉树完全相同，第k层结点尽力靠左</strong></p>
<ul>
<li><strong>性质4: 具有n个结点的完全二叉树的深度必为log2n+1的向下取整</strong></li>
<li> <strong>性质5: 对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i/2（i＝1 时为根,除外）</strong></li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8D97.tmp.jpg" alt="img"> </p>
<ul>
<li>使用此性质可以使用完全二叉树实现树的顺序存储。</li>
</ul>
<ul>
<li>如果不是完全二叉树咋整???</li>
</ul>
<ul>
<li>—— 将其转换成完全二叉树即可</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8D98.tmp.jpg" alt="img"> </p>
<ul>
<li><strong>缺点：①浪费空间；②插入、删除不便</strong>   </li>
</ul>
<h4 id="4-4-2二叉树的表示"><a href="#4-4-2二叉树的表示" class="headerlink" title="4.4.2二叉树的表示"></a><strong>4.4.2二叉树的表示</strong></h4><p> <strong>二叉链表示法</strong></p>
<ul>
<li>一般从根结点开始存储。相应地，访问树中结点时也只能从根开始。</li>
</ul>
<p> <strong>存储结构</strong></p>
<p><img src="http://qiniu.orangew.cn/img/wps8D99.tmp.jpg" alt="img"> </p>
<p> <strong>结点数据类型定义：</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct BiTNode
&#123;
	int		data;
	struct BiTNode *lchild, *rchild;
&#125;BiTNode, *BiTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p> <strong>三叉链表表示法</strong></p>
<p> <strong>存储结构</strong></p>
<p><img src="http://qiniu.orangew.cn/img/wps8DAA.tmp.jpg" alt="img"> </p>
<ul>
<li>每个节点有三个指针域，其中两个分别指向子节点（左孩子，右孩子），还有一共指针指向该节点的父节点。</li>
</ul>
<p> <strong>节点数据类型定义</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;三叉链表
typedef struct TriTNode 
&#123;
	int data;
	&#x2F;&#x2F;左右孩子指针
	struct TriTNode *lchild, *rchild;
	struct TriTNode *parent;
&#125;TriTNode, *TriTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="4-4-3二叉树的遍历"><a href="#4-4-3二叉树的遍历" class="headerlink" title="4.4.3二叉树的遍历"></a><strong>4.4.3二叉树的遍历</strong></h4><ul>
<li><p>遍历定义</p>
</li>
<li><p>指按某条搜索路线<strong>遍访每个结点且不重复</strong>（又称周游）。</p>
</li>
<li><p>遍历用途</p>
</li>
<li><p>它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。 </p>
</li>
<li><p>遍历方法</p>
</li>
<li><p>牢记一种约定，<strong>对每个结点的查看都是“先左后右”</strong> 。</p>
</li>
</ul>
<ul>
<li>限定先左后右，树的遍历有三种实现方案：</li>
</ul>
<ul>
<li>   <strong>DLR         LDR        LRD</strong></li>
</ul>
<ul>
<li><p><strong>先</strong> (<strong>根</strong>)序遍历    <strong>中</strong> (<strong>根</strong>)序遍历    <strong>后</strong>(<strong>根</strong>)序遍历 </p>
</li>
<li><p><strong>DLR — 先序遍历，即先根再左再右</strong></p>
</li>
<li><p> <strong>LDR — 中序遍历，即先左再根再右</strong></p>
</li>
</ul>
<ul>
<li> <strong>LRD — 后序遍历，即先左再右再根</strong></li>
</ul>
<ul>
<li><p><strong>注：“先、中、后”的意思是指访问的结点D是先于子树出现还是后于子树出现。</strong></p>
</li>
<li><p><strong>从递归的角度看，这三种算法是完全相同的，或者说这三种遍历算法的访问路径是相同的，只是访问结点的时机不同。</strong></p>
</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8DAB.tmp.jpg" alt="img"> </p>
<ul>
<li>​    从虚线的出发点到终点的路径上，每个结点经过3次。</li>
<li> <strong>第1次经过时访问＝先序遍历</strong></li>
<li> <strong>第2次经过时访问＝中序遍历</strong></li>
<li> <strong>第3次经过时访问＝后序遍历</strong></li>
</ul>
<p><strong>案例：</strong></p>
<p><img src="http://qiniu.orangew.cn/img/wps8DAC.tmp.jpg" alt="img"> </p>
<p><strong>代码:</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

&#x2F;&#x2F;二叉树结点 二叉链表
typedef struct _PTNode&#123;
	char ch;
	struct _PTNode* lchild;
	struct _PTNode* rchild;
&#125;PTNode;

&#x2F;&#x2F;递归遍历
void RecursionBiTree(PTNode* root)&#123;
	if (root &#x3D;&#x3D; NULL)&#123;
		return;
	&#125;
	printf(&quot;%c&quot;, root-&gt;ch); &#x2F;&#x2F;先序遍历
	RecursionBiTree(root-&gt;lchild);
	&#x2F;&#x2F;printf(&quot;%c&quot;, root-&gt;ch); &#x2F;&#x2F;中序遍历
	RecursionBiTree(root-&gt;rchild);
	&#x2F;&#x2F;printf(&quot;%c&quot;, root-&gt;ch); &#x2F;&#x2F;后序遍历
&#125;

&#x2F;&#x2F;测试
void test01()&#123;

	&#x2F;&#x2F;创建结点
	PTNode node1, node2, node3, node4, node5, node6, node7, node8;
	node1.ch &#x3D; &#39;A&#39;; node1.lchild &#x3D; NULL; node1.rchild &#x3D; NULL;
	node2.ch &#x3D; &#39;B&#39;; node2.lchild &#x3D; NULL; node2.rchild &#x3D; NULL;
	node3.ch &#x3D; &#39;C&#39;;	node3.lchild &#x3D; NULL; node3.rchild &#x3D; NULL;
	node4.ch &#x3D; &#39;D&#39;;	node4.lchild &#x3D; NULL; node4.rchild &#x3D; NULL;
	node5.ch &#x3D; &#39;E&#39;;	node5.lchild &#x3D; NULL; node5.rchild &#x3D; NULL;
	node6.ch &#x3D; &#39;F&#39;;	node6.lchild &#x3D; NULL; node6.rchild &#x3D; NULL;
	node7.ch &#x3D; &#39;G&#39;;	node7.lchild &#x3D; NULL; node7.rchild &#x3D; NULL;
	node8.ch &#x3D; &#39;H&#39;;	node8.lchild &#x3D; NULL; node8.rchild &#x3D; NULL;

	&#x2F;&#x2F;建立结点关系
	node1.lchild &#x3D; &amp;node2;
	node1.rchild &#x3D; &amp;node6;

	node2.lchild &#x3D; NULL;
	node2.rchild &#x3D; &amp;node3;

	node3.lchild &#x3D; &amp;node4;
	node3.rchild &#x3D; &amp;node5;

	node6.lchild &#x3D; NULL;
	node6.rchild &#x3D; &amp;node7;

	node7.lchild &#x3D; &amp;node8;
	node7.rchild &#x3D; NULL;

	RecursionBiTree(&amp;node1);
&#125;

int main()&#123;

	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<p><strong>非递归前序遍历：</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&quot;LinkStack.h&quot;

&#x2F;&#x2F;二叉树结点 二叉链表
typedef struct _PTNode&#123;
	char ch;
	struct _PTNode* lchild;
	struct _PTNode* rchild;
&#125;PTNode;

&#x2F;&#x2F;递归遍历
void RecursionBiTree(PTNode* root)&#123;
	if (root &#x3D;&#x3D; NULL)&#123;
		return;
	&#125;
	&#x2F;&#x2F;printf(&quot;%c&quot;, root-&gt;ch); &#x2F;&#x2F;先序遍历
	RecursionBiTree(root-&gt;lchild);
	printf(&quot;%c&quot;, root-&gt;ch); &#x2F;&#x2F;中序遍历
	RecursionBiTree(root-&gt;rchild);
	&#x2F;&#x2F;printf(&quot;%c&quot;, root-&gt;ch); &#x2F;&#x2F;后序遍历
&#125;

&#x2F;&#x2F;非递归的方式遍历二叉树
void NonRecursion01(PTNode* root)&#123;
	
	&#x2F;&#x2F;创建栈
	LinkStack* stack &#x3D;  InitLinkStack();
	
	PTNode* pChild &#x3D; root;
	PushLinkStack(stack,root);
	while (!IsEmptyLinkStack(stack) || pChild )&#123;
		
		while (pChild !&#x3D; NULL)&#123;
			printf(&quot;%c\n&quot;,pChild-&gt;ch);
			if (pChild !&#x3D; root)&#123;
				PushLinkStack(stack, pChild);
			&#125;
			pChild &#x3D; pChild-&gt;lchild;
		&#125;

		if (!IsEmptyLinkStack(stack))&#123;
			pChild &#x3D; (PTNode*)TopLinkStack(stack);
			PopLinkStack(stack);
			pChild &#x3D; pChild-&gt;rchild;
		&#125;
	&#125;
&#125;

&#x2F;&#x2F;测试
void test01()&#123;

	&#x2F;&#x2F;创建结点
	PTNode node1, node2, node3, node4, node5, node6, node7, node8;
	node1.ch &#x3D; &#39;A&#39;; node1.lchild &#x3D; NULL; node1.rchild &#x3D; NULL;
	node2.ch &#x3D; &#39;B&#39;; node2.lchild &#x3D; NULL; node2.rchild &#x3D; NULL;
	node3.ch &#x3D; &#39;C&#39;;	node3.lchild &#x3D; NULL; node3.rchild &#x3D; NULL;
	node4.ch &#x3D; &#39;D&#39;;	node4.lchild &#x3D; NULL; node4.rchild &#x3D; NULL;
	node5.ch &#x3D; &#39;E&#39;;	node5.lchild &#x3D; NULL; node5.rchild &#x3D; NULL;
	node6.ch &#x3D; &#39;F&#39;;	node6.lchild &#x3D; NULL; node6.rchild &#x3D; NULL;
	node7.ch &#x3D; &#39;G&#39;;	node7.lchild &#x3D; NULL; node7.rchild &#x3D; NULL;
	node8.ch &#x3D; &#39;H&#39;;	node8.lchild &#x3D; NULL; node8.rchild &#x3D; NULL;

	&#x2F;&#x2F;建立结点关系
	node1.lchild &#x3D; &amp;node2;
	node1.rchild &#x3D; &amp;node6;

	node2.lchild &#x3D; NULL;
	node2.rchild &#x3D; &amp;node3;

	node3.lchild &#x3D; &amp;node4;
	node3.rchild &#x3D; &amp;node5;

	node6.lchild &#x3D; NULL;
	node6.rchild &#x3D; &amp;node7;

	node7.lchild &#x3D; &amp;node8;
	node7.rchild &#x3D; NULL;

	&#x2F;&#x2F;非递归前序遍历
	printf(&quot;\n非递归前序遍历:\n&quot;);
	NonRecursion01(&amp;node1);
&#125;

int main()&#123;

	test01();
	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="4-4-5二叉树编程实践"><a href="#4-4-5二叉树编程实践" class="headerlink" title="4.4.5二叉树编程实践"></a><strong>4.4.5二叉树编程实践</strong></h4><p><strong>案例1：计算二叉树中叶子结点的数目</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

&#x2F;&#x2F;二叉树结点 二叉链表
typedef struct _PTNode&#123;
	char ch;
	struct _PTNode* lchild;
	struct _PTNode* rchild;
&#125;PTNode;

&#x2F;&#x2F;求叶子结点数量
int leafNum &#x3D; 0;
void RecursionBiTree(PTNode* root)&#123;
	if (root &#x3D;&#x3D; NULL)&#123;
		return;
	&#125;

	if (!root-&gt;lchild &amp;&amp; !root-&gt;rchild)&#123;
		leafNum++;
	&#125;

	RecursionLeafNumTree(root-&gt;lchild);
	RecursionLeafNumTree(root-&gt;rchild);
&#125;

&#x2F;&#x2F;测试
void test01()&#123;

	&#x2F;&#x2F;创建结点
	PTNode node1, node2, node3, node4, node5, node6, node7, node8;
	node1.ch &#x3D; &#39;A&#39;; node1.lchild &#x3D; NULL; node1.rchild &#x3D; NULL;
	node2.ch &#x3D; &#39;B&#39;; node2.lchild &#x3D; NULL; node2.rchild &#x3D; NULL;
	node3.ch &#x3D; &#39;C&#39;;	node3.lchild &#x3D; NULL; node3.rchild &#x3D; NULL;
	node4.ch &#x3D; &#39;D&#39;;	node4.lchild &#x3D; NULL; node4.rchild &#x3D; NULL;
	node5.ch &#x3D; &#39;E&#39;;	node5.lchild &#x3D; NULL; node5.rchild &#x3D; NULL;
	node6.ch &#x3D; &#39;F&#39;;	node6.lchild &#x3D; NULL; node6.rchild &#x3D; NULL;
	node7.ch &#x3D; &#39;G&#39;;	node7.lchild &#x3D; NULL; node7.rchild &#x3D; NULL;
	node8.ch &#x3D; &#39;H&#39;;	node8.lchild &#x3D; NULL; node8.rchild &#x3D; NULL;

	&#x2F;&#x2F;建立结点关系
	node1.lchild &#x3D; &amp;node2;
	node1.rchild &#x3D; &amp;node6;

	node2.lchild &#x3D; NULL;
	node2.rchild &#x3D; &amp;node3;

	node3.lchild &#x3D; &amp;node4;
	node3.rchild &#x3D; &amp;node5;

	node6.lchild &#x3D; NULL;
	node6.rchild &#x3D; &amp;node7;

	node7.lchild &#x3D; &amp;node8;
	node7.rchild &#x3D; NULL;

	RecursionBiTree(&amp;node1); &#x2F;&#x2F;求叶子结点书目
	printf(&quot;叶子结点数量:%d\n&quot;,leafNum);
&#125;

int main()&#123;

	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>思想：</strong>    </p>
<ul>
<li>求根结点左子树的叶子结点个数，累计到sum中，求根结点右子树的叶子结点个数累计到sum中。</li>
<li>若左子树还是树，重复步骤1；若右子树还是树，重复步骤1。</li>
</ul>
<p> <strong>全局变量转成函数参数</strong></p>
<ul>
<li>可以按照先序、中序、后序方式计算叶子结点</li>
</ul>
<p><strong>三种遍历的本质思想强化：访问结点的路径都是一样的，计算结点的时机不同。</strong></p>
<p><strong>案例2：求二叉树的深度</strong></p>
<p><strong>思想：</strong>    </p>
<ul>
<li>求根结点左子树高度，根结点右子树高度，比较的子树最大高度，再+1。</li>
<li>若左子树还是树，重复步骤1；若右子树还是树，重复步骤1。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

&#x2F;&#x2F;二叉树结点 二叉链表
typedef struct _PTNode&#123;
	char ch;
	struct _PTNode* lchild;
	struct _PTNode* rchild;
&#125;PTNode;

&#x2F;&#x2F;求二叉树深度
int RecursionTreeDepth(PTNode* root)&#123;

	int depth &#x3D; 0;
	if (root &#x3D;&#x3D; NULL)&#123;
		return depth;
	&#125;

	int ldepth &#x3D; RecursionTreeDepth(root-&gt;lchild);
	int rdepth &#x3D; RecursionTreeDepth(root-&gt;rchild);
	depth &#x3D; ldepth &gt;&#x3D; rdepth ? ldepth + 1 : rdepth + 1;

	return depth;
&#125;

&#x2F;&#x2F;测试
void test01()&#123;

	&#x2F;&#x2F;创建结点
	PTNode node1, node2, node3, node4, node5, node6, node7, node8;
	node1.ch &#x3D; &#39;A&#39;;   node1.lchild &#x3D; NULL; node1.rchild &#x3D; NULL;
	node2.ch &#x3D; &#39;B&#39;;   node2.lchild &#x3D; NULL; node2.rchild &#x3D; NULL;
	node3.ch &#x3D; &#39;C&#39;;	node3.lchild &#x3D; NULL; node3.rchild &#x3D; NULL;
	node4.ch &#x3D; &#39;D&#39;;	node4.lchild &#x3D; NULL; node4.rchild &#x3D; NULL;
	node5.ch &#x3D; &#39;E&#39;;	node5.lchild &#x3D; NULL; node5.rchild &#x3D; NULL;
	node6.ch &#x3D; &#39;F&#39;;	node6.lchild &#x3D; NULL; node6.rchild &#x3D; NULL;
	node7.ch &#x3D; &#39;G&#39;;	node7.lchild &#x3D; NULL; node7.rchild &#x3D; NULL;
	node8.ch &#x3D; &#39;H&#39;;	node8.lchild &#x3D; NULL; node8.rchild &#x3D; NULL;

	&#x2F;&#x2F;建立结点关系
	node1.lchild &#x3D; &amp;node2;
	node1.rchild &#x3D; &amp;node6;

	node2.lchild &#x3D; NULL;
	node2.rchild &#x3D; &amp;node3;

	node3.lchild &#x3D; &amp;node4;
	node3.rchild &#x3D; &amp;node5;

	node6.lchild &#x3D; NULL;
	node6.rchild &#x3D; &amp;node7;

	node7.lchild &#x3D; &amp;node8;
	node7.rchild &#x3D; NULL;

	int depth &#x3D; RecursionTreeDepth(&amp;node1);
	printf(&quot;树的深度为:%d\n&quot;,depth);
&#125;

int main()&#123;

	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>案例3：Copy二叉树</strong></p>
<p><strong>思想：</strong>    </p>
<ul>
<li>malloc新结点，</li>
<li>拷贝左子树，拷贝右子树，让新结点连接左子树，右子树。</li>
<li>若左子树还是树，重复步骤1、2；若右子树还是树，重复步骤1、2。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

&#x2F;&#x2F;二叉树结点 二叉链表
typedef struct _PTNode&#123;
	char ch;
	struct _PTNode* lchild;
	struct _PTNode* rchild;
&#125;PTNode;

&#x2F;&#x2F;递归遍历
void RecursionBiTree(PTNode* root)&#123;
	if (root &#x3D;&#x3D; NULL)&#123;
		return;
	&#125;
	printf(&quot;%c&quot;, root-&gt;ch); &#x2F;&#x2F;先序遍历
	RecursionBiTree(root-&gt;lchild);
	&#x2F;&#x2F;printf(&quot;%c&quot;, root-&gt;ch); &#x2F;&#x2F;中序遍历
	RecursionBiTree(root-&gt;rchild);
	&#x2F;&#x2F;printf(&quot;%c&quot;, root-&gt;ch); &#x2F;&#x2F;后序遍历
&#125;

&#x2F;&#x2F;拷贝二叉树
PTNode* CopyTree(PTNode* root)&#123;
	if (root &#x3D;&#x3D; NULL)&#123;
		return NULL;
	&#125;

	&#x2F;&#x2F;拷贝左子树
	if (root-&gt;lchild)&#123;
		root-&gt;lchild &#x3D;  CopyTree(root-&gt;lchild);
	&#125;
	else&#123;
		root-&gt;lchild &#x3D; NULL;
	&#125;
	&#x2F;&#x2F;拷贝右子树
	if (root-&gt;rchild)&#123;
		root-&gt;rchild &#x3D; CopyTree(root-&gt;rchild);
	&#125;
	else&#123;
		root-&gt;rchild &#x3D; NULL;
	&#125;

	&#x2F;&#x2F;创建新节点
	PTNode* newnode &#x3D; (PTNode*)malloc(sizeof(PTNode));
	newnode-&gt;ch &#x3D; root-&gt;ch;
	newnode-&gt;lchild &#x3D; root-&gt;lchild;
	newnode-&gt;rchild &#x3D; root-&gt;rchild;

	return newnode;
&#125;

&#x2F;&#x2F;测试
void test01()&#123;

	&#x2F;&#x2F;创建结点
	PTNode node1, node2, node3, node4, node5, node6, node7, node8;
	node1.ch &#x3D; &#39;A&#39;; node1.lchild &#x3D; NULL; node1.rchild &#x3D; NULL;
	node2.ch &#x3D; &#39;B&#39;; node2.lchild &#x3D; NULL; node2.rchild &#x3D; NULL;
	node3.ch &#x3D; &#39;C&#39;;	node3.lchild &#x3D; NULL; node3.rchild &#x3D; NULL;
	node4.ch &#x3D; &#39;D&#39;;	node4.lchild &#x3D; NULL; node4.rchild &#x3D; NULL;
	node5.ch &#x3D; &#39;E&#39;;	node5.lchild &#x3D; NULL; node5.rchild &#x3D; NULL;
	node6.ch &#x3D; &#39;F&#39;;	node6.lchild &#x3D; NULL; node6.rchild &#x3D; NULL;
	node7.ch &#x3D; &#39;G&#39;;	node7.lchild &#x3D; NULL; node7.rchild &#x3D; NULL;
	node8.ch &#x3D; &#39;H&#39;;	node8.lchild &#x3D; NULL; node8.rchild &#x3D; NULL;

	&#x2F;&#x2F;建立结点关系
	node1.lchild &#x3D; &amp;node2;
	node1.rchild &#x3D; &amp;node6;

	node2.lchild &#x3D; NULL;
	node2.rchild &#x3D; &amp;node3;

	node3.lchild &#x3D; &amp;node4;
	node3.rchild &#x3D; &amp;node5;

	node6.lchild &#x3D; NULL;
	node6.rchild &#x3D; &amp;node7;

	node7.lchild &#x3D; &amp;node8;
	node7.rchild &#x3D; NULL;

	printf(&quot;打印拷贝二叉树:\n&quot;);
	PTNode* root &#x3D; CopyTree(&amp;node1);
	RecursionBiTree(root); &#x2F;&#x2F;打印结点
&#125;

int main()&#123;

	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="4-6二叉树的创建"><a href="#4-6二叉树的创建" class="headerlink" title="4.6二叉树的创建"></a><strong>4.6二叉树的创建</strong></h3><h4 id="4-6-1中序和先序创建树"><a href="#4-6-1中序和先序创建树" class="headerlink" title="4.6.1中序和先序创建树"></a><strong>4.6.1中序和先序创建树</strong></h4><p>1、根据中序遍历的结果能确定一棵树吗？</p>
<p>中序遍历：结果为：“12345”，这个“12345”能确定一棵树吗？</p>
<p>请思考，会有多少种形状。<strong>树的形状能唯一确定吗？？？</strong></p>
<p><img src="http://qiniu.orangew.cn/img/wps8DBC.tmp.jpg" alt="img"> </p>
<p>2、如何才能确定一棵树？</p>
<p>结论：    </p>
<p><strong>通过中序遍历和先序遍历可以确定一个树</strong></p>
<p>通过中序遍历和后续遍历可以确定一个树</p>
<p>通过先序遍历和后序遍历确定不了一个树。</p>
<p><strong>单独先序遍历：能求解根，但不能求解左子树什么时候结束、右子树什么时候开始。</strong></p>
<p>3、根据先序和中序结果画树</p>
<p>算法</p>
<ul>
<li>通过先序遍历找到根结点A，再通过A在中序遍历的位置找出左子树，右子树</li>
<li>在A的左子树中，找左子树的根结点（在先序中找），转步骤1</li>
<li>在A的右子树中，找右子树的根结点（在先序中找），转步骤1</li>
</ul>
<p>练习1</p>
<p>先序遍历结果：A D E B C F</p>
<p>中序遍历结果：D E A C F B</p>
<p><img src="http://qiniu.orangew.cn/img/wps8DBD.tmp.jpg" alt="img"> </p>
<p>练习2</p>
<p>先序遍历结果：A B D H K E C F I G J</p>
<p>中序遍历结果：H K D B E A I F C G J</p>
<p><img src="http://qiniu.orangew.cn/img/wps8DBE.tmp.jpg" alt="img"> </p>
<h4 id="4-6-2-号法创建树"><a href="#4-6-2-号法创建树" class="headerlink" title="4.6.2#号法创建树"></a><strong>4.6.2#号法创建树</strong></h4><p>1、什么是#号法创建树</p>
<p>#创建树，让树的每一个节点都变成度数为2的树</p>
<p>先序遍历结果: 124###3##</p>
<p><img src="http://qiniu.orangew.cn/img/wps8DCF.tmp.jpg" alt="img"> </p>
<p>​    先序遍历：124###3##可以唯一确定一棵树吗，为什么？</p>
<p><img src="http://qiniu.orangew.cn/img/wps8DD0.tmp.jpg" alt="img"> </p>
<p>确定出来的树模型: 上图即是。</p>
<p>2 #创建树练习 ABDH#K###E##CFI###G#J##</p>
<p>先序遍历：ABDH#K###E##CFI###G#J## , 请画出树的形状：</p>
<p><img src="http://qiniu.orangew.cn/img/wps8DD1.tmp.jpg" alt="img"> </p>
<p>3、#号法编程实践</p>
<p> <strong>利用前序遍历来建树</strong>（结点值陆续从键盘输入，用DLR为宜）</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Bintree createBTpre( )
&#123;      Bintree T; char ch;
        scanf(“%c”,&amp;ch);
        if(ch&#x3D;&#x3D;’#’) T&#x3D;NULL; 
        else
        &#123;   T&#x3D;( Bintree )malloc(sizeof(BinTNode));
            T-&gt;data&#x3D;ch;
            T-&gt;lchild&#x3D;createBTpre(); 
            T-&gt;rchild&#x3D;createBTpre();
        &#125;        
        return T;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>使用后序遍历的方式销毁一棵树， 先释放叶子节点，在释放根节点</strong></p>
<p><strong>//销毁树</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void  BiTree_Free(BiTNode* T)
&#123;	
	BiTNode *tmp &#x3D; NULL;
	if (T!&#x3D; NULL)
	&#123;
		if (T-&gt;rchild !&#x3D; NULL) BiTree_Free(T-&gt;rchild);
		if (T-&gt;lchild !&#x3D; NULL) BiTree_Free(T-&gt;lchild);
		if (T !&#x3D; NULL)
		&#123;
			free(T); 
			T &#x3D; NULL;
		&#125;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="4-7霍夫曼树"><a href="#4-7霍夫曼树" class="headerlink" title="4.7霍夫曼树"></a><strong>4.7霍夫曼树</strong></h3><h4 id="4-7-1概念"><a href="#4-7-1概念" class="headerlink" title="4.7.1概念"></a><strong>4.7.1概念</strong></h4><ul>
<li>组建一个网络，耗费最小 WPL(树的带权路径长度)最小；这个方法是霍夫曼想出来的，称为霍夫曼树。</li>
</ul>
<ul>
<li>霍夫曼大叔说，从树中一个节点到另一个节点之间的分支构成两个节点之间的路径，路径上的分支数目称作路径长度。如下图的二叉树a中，根节点到节点D的路径长度为4，二叉树b中根节点到节点D的路径长度为2.树的路径长度就是从树根到每一节点的路径长度之和。二叉树a的树路径长度就为1+1+2+2+3+3+4+4=20。二叉树b的树路径长度为1+2+3+3+2+1+2+2=16。</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8DD2.tmp.jpg" alt="img"> </p>
<h4 id="4-7-2霍夫曼树的构造"><a href="#4-7-2霍夫曼树的构造" class="headerlink" title="4.7.2霍夫曼树的构造"></a><strong>4.7.2霍夫曼树的构造</strong></h4><p>对于文本”BADCADFEED”的传输而言，因为重复出现的只有“ABCDEF”这6个字符，因此可以用下面的方式编码：</p>
<table>
<thead>
<tr>
<th><strong>A</strong></th>
<th><strong>B</strong></th>
<th><strong>C</strong></th>
<th><strong>D</strong></th>
<th><strong>E</strong></th>
<th><strong>F</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>000</strong></td>
<td><strong>001</strong></td>
<td><strong>010</strong></td>
<td><strong>011</strong></td>
<td><strong>100</strong></td>
<td><strong>101</strong></td>
</tr>
</tbody></table>
<p><strong>B A D C A D F E E D</strong> <strong>à</strong> <strong>001 000 011 010 000 011 101 100 100 011</strong></p>
<p>接收方可以根据每3个bit进行一次字符解码的方式还原文本信息。这样的编码方式需要30个bit位才能表示10个字符那么当传输一篇500个字符的情报时，需要15000个bit位，在战争年代，这种编码方式对于情报的发送和接受是很低效且容易出错的。如何提高收发效率？</p>
<p><strong>要提高效率，必然要从编码方式的改进入手，要避免每个字符都占用相同的bit位.</strong></p>
<table>
<thead>
<tr>
<th><strong>A</strong></th>
<th><strong>B</strong></th>
<th><strong>C</strong></th>
<th><strong>D</strong></th>
<th><strong>E</strong></th>
<th><strong>F</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>01</strong></td>
<td><strong>1001</strong></td>
<td><strong>101</strong></td>
<td><strong>00</strong></td>
<td><strong>11</strong></td>
<td><strong>1000</strong></td>
</tr>
</tbody></table>
<p><strong>B A D C A D F E E D</strong> <strong>à</strong> <strong>1001 01 00 101 01 00 1000 11 11 00</strong></p>
<p><strong>准则：任一字符的编码都不是另一个字符编码的前缀！</strong></p>
<p><strong>也就是说：每一个字符的编码路径，都不包含另外一个字符的路径。</strong></p>
<ul>
<li><p>霍夫曼树的构建规则: </p>
</li>
<li><p>给定n个数值{ v1, v2, …, vn}。</p>
</li>
<li><p>根据这n个数值构造二叉树集合F = { T1, T2, …, Tn}，Ti的数据域为vi，左右子树为空。</p>
</li>
<li><p>在F中选取两棵根结点的值最小的树作为左右子树构造一棵新的二叉树，这棵二叉树的根结点中的值为左右子树根结点中的值之和</p>
</li>
<li><p>在F中删除这两棵子树，并将构造的新二叉树根节点加入F中</p>
</li>
<li><p>重复3和4，直到F中只剩下一个树为止。</p>
</li>
<li><p>这棵树即霍夫曼树</p>
</li>
</ul>
<p>假设经过统计ABCDEF在需要传输的报文中出现的概率如下：</p>
<table>
<thead>
<tr>
<th><strong>A</strong></th>
<th><strong>B</strong></th>
<th><strong>C</strong></th>
<th><strong>D</strong></th>
<th><strong>E</strong></th>
<th><strong>F</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>27%</strong></td>
<td><strong>8%</strong></td>
<td><strong>15%</strong></td>
<td><strong>15%</strong></td>
<td><strong>30%</strong></td>
<td><strong>5%</strong></td>
</tr>
</tbody></table>
<p><strong>构建出的树模型如下：</strong></p>
<p><img src="http://qiniu.orangew.cn/img/wps8DE3.tmp.jpg" alt="img"></p>
<p> <strong>特点：</strong></p>
<p><strong>所用的字符都作为叶子节点出现。</strong></p>
<p><strong>根到每个字符的路径都不重复，也不存在重叠的现象。</strong></p>
<p><strong>总结：</strong></p>
<ul>
<li>霍夫曼树<strong>是一种特殊的二叉树</strong>。</li>
<li>霍夫曼树应用于<strong>信息编码</strong>和<strong>数据压缩领域</strong>。 </li>
<li><strong>霍夫曼树是现代压缩算法的基础。</strong></li>
</ul>
<h2 id="5-排序"><a href="#5-排序" class="headerlink" title="5.排序"></a><strong>5.排序</strong></h2><h3 id="5-1排序基本概念"><a href="#5-1排序基本概念" class="headerlink" title="5.1排序基本概念"></a><strong>5.1排序基本概念</strong></h3><ul>
<li>现实生活中排序很重要，例如：淘宝按条件搜索的结果展示等。</li>
</ul>
<ul>
<li><p>概念</p>
</li>
<li><p>排序是计算机内经常进行的一种操作，其目的是将一组“无序”的数据元素调整为“有序”的数据元素。</p>
</li>
<li><p>排序数学定义：</p>
</li>
<li><p>假设含n个数据元素的序列为{ R1, R2, …, Rn}，其相应的关键字序列为{ K1, K2, …, Kn}这些关键字相互之间可以进行比较，即在它们之间存在着这样一个关系 ：</p>
</li>
<li><p>Kp1≤Kp2≤…≤Kpn</p>
</li>
<li><p>按此固有关系将上式记录序列重新排列为{ Rp1, Rp2, …，Rpn}的操作称作排序</p>
</li>
<li><p>排序的稳定性</p>
</li>
<li><p>如果在序列中有两个数据元素r[i]和r[j]，它们的关键字k[i] == k [j]，且在排序之前，对象r[i]排在r[j]前面。如果在排序之后，对象r[i]仍在r[j]前面，则称这个排序方法是稳定的，否则称这个排序方法是不稳定的。</p>
</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8DE4.tmp.jpg" alt="img"> </p>
<ul>
<li><p><strong>多关键字排序</strong></p>
</li>
<li><p>排序时需要比较的关键字多于一个，排序结果首先按关键字1进行排序，当关键字1相同时按关键字2进行排序，当关键字n-1相同时按关键字n进行排序，对于多关键字排序，只需要在比较操作时同时考虑多个关键字即可！</p>
</li>
<li><p><strong>排序中的关键操作</strong></p>
</li>
<li><p>比较：任意两个数据元素通过比较操作确定先后次序。</p>
</li>
<li><p>交换：数据元素之间需要交换才能得到预期结果。</p>
</li>
<li><p>内排序和外排序</p>
</li>
<li><p>内排序：在排序过程中，待排序的所有记录全部都放置在内存中，排序分为：内排序和外排序。</p>
</li>
<li><p>外排序：由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外存之间多次交换数据才能进行。</p>
</li>
<li><p><strong>排序的审判</strong></p>
</li>
<li><p>时间性能：关键性能差异体现在比较和交换的数量</p>
</li>
<li><p>辅助存储空间：为完成排序操作需要的额外的存储空间，必要时可以“空间换时间”</p>
</li>
<li><p>算法的实现复杂性：过于复杂的排序法会影响代码的可读性和可维护性，也可能影响排序的性能</p>
</li>
<li><p><strong>总结</strong></p>
</li>
<li><p>排序是数据元素从无序到有序的过程</p>
</li>
<li><p>排序具有稳定性，是选择排序算法的因素之一</p>
</li>
<li><p>比较和交换是排序的基本操作</p>
</li>
<li><p>多关键字排序与单关键字排序无本质区别</p>
</li>
<li><p>排序的时间性能是区分排序算法好坏的主要因素</p>
</li>
</ul>
<h3 id="5-2冒泡排序"><a href="#5-2冒泡排序" class="headerlink" title="5.2冒泡排序"></a><strong>5.2冒泡排序</strong></h3><p><img src="http://qiniu.orangew.cn/img/wps8DF4.tmp.png" alt="img"></p>
<h4 id="5-2-1冒泡排序实现案例"><a href="#5-2-1冒泡排序实现案例" class="headerlink" title="5.2.1冒泡排序实现案例"></a><strong>5.2.1冒泡排序实现案例</strong></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

&#x2F;&#x2F;打印数组
void PrintArray(int* arr,int length)&#123;
	for (int i &#x3D; 0; i &lt; length;i++)&#123;
		printf(&quot;%d &quot;,arr[i]);
	&#125;
	printf(&quot;\n&quot;);
&#125;

&#x2F;&#x2F;交换函数
void swap(int* arr,int pos1,int pos2)&#123;

	int temp &#x3D; arr[pos1];
	arr[pos1] &#x3D; arr[pos2];
	arr[pos2] &#x3D; temp;

&#125;

&#x2F;&#x2F;冒泡排序
void BubbleSort(int* arr, int length)&#123;

	int i,j;
	for (i &#x3D; 0; i &lt; length; i ++)&#123;

		for (j &#x3D; length - 1; j &gt; i;j --)&#123;
			
			if (arr[j-1] &lt; arr[j])&#123;
				swap(arr,i,j);
			&#125;
		&#125;
	&#125;
&#125;

void test01()&#123;

	int array[] &#x3D; &#123;23,12,89,6,45,77,67&#125;;
	int length &#x3D; sizeof(array) &#x2F; sizeof(int);
	&#x2F;&#x2F;打印排序前的数组
	printf(&quot;打印冒泡排序前的数组:\n&quot;);
	PrintArray(array, length);
	&#x2F;&#x2F;对数组进行冒泡排序
	BubbleSort(array,length);
	printf(&quot;打印冒泡排序后的数组:\n&quot;);
	PrintArray(array, length);
&#125;

int main()&#123;

	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="5-2-2冒泡排序-改进版-实现案例"><a href="#5-2-2冒泡排序-改进版-实现案例" class="headerlink" title="5.2.2冒泡排序(改进版)实现案例"></a><strong>5.2.2冒泡排序(改进版)实现案例</strong></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

#define BUBBLE_TRUE 1
#define BUBBLE_FALSE 0

&#x2F;&#x2F;打印数组
void PrintArray(int* arr,int length)&#123;
	for (int i &#x3D; 0; i &lt; length;i++)&#123;
		printf(&quot;%d &quot;,arr[i]);
	&#125;
	printf(&quot;\n&quot;);
&#125;

&#x2F;&#x2F;交换函数
void swap(int* arr,int pos1,int pos2)&#123;
	int temp &#x3D; arr[pos1];
	arr[pos1] &#x3D; arr[pos2];
	arr[pos2] &#x3D; temp;
&#125;

&#x2F;&#x2F;冒泡排序
void BubbleSort(int* arr, int length)&#123;

	int i,j;
	int flag &#x3D; BUBBLE_TRUE; &#x2F;&#x2F;是否排序完成 BUBBLE_TRUE表示没有排序完成，BUBBLE_FALSE表示排序完成
	for (i &#x3D; 0; i &lt; length &amp;&amp; flag &#x3D;&#x3D; BUBBLE_TRUE; i++)&#123;
		flag &#x3D; BUBBLE_FALSE;
		for (j &#x3D; length - 1; j &gt; i;j --)&#123;
			
			if (arr[j-1] &lt; arr[j])&#123;
				flag &#x3D; BUBBLE_TRUE;
				swap(arr,i,j);
			&#125;
		&#125;
	&#125;
&#125;

void test01()&#123;

	int array[] &#x3D; &#123;23,12,89,6,45,77,67&#125;;
	int length &#x3D; sizeof(array) &#x2F; sizeof(int);
	&#x2F;&#x2F;打印排序前的数组
	printf(&quot;打印冒泡排序前的数组:\n&quot;);
	PrintArray(array, length);
	&#x2F;&#x2F;对数组进行冒泡排序
	BubbleSort(array,length);
	printf(&quot;打印冒泡排序后的数组:\n&quot;);
	PrintArray(array, length);
&#125;

int main()&#123;

	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="5-2-3冒泡排序总结"><a href="#5-2-3冒泡排序总结" class="headerlink" title="5.2.3冒泡排序总结"></a><strong>5.2.3冒泡排序总结</strong></h4><ul>
<li>冒泡总结：</li>
<li>冒泡排序是一种效率低下的排序方法，在数据规模很小时，可以采用。数据规模比较大时，最好用其它排序方法。</li>
<li>上述例子总对冒泡做了优化，添加了flag作为标记，记录序列是否已经有序，减少循环次数。</li>
<li>稳定性</li>
<li> <strong>冒泡排序是一种稳定的排序算法</strong></li>
<li> <strong>冒泡排序的效率：O（n²）</strong></li>
</ul>
<h3 id="5-3选择排序"><a href="#5-3选择排序" class="headerlink" title="5.3选择排序"></a><strong>5.3选择排序</strong></h3><p><img src="http://qiniu.orangew.cn/img/wps8DF5.tmp.png" alt="img"></p>
<h3 id="5-3-1选择排序实现案例"><a href="#5-3-1选择排序实现案例" class="headerlink" title="5.3.1选择排序实现案例"></a><strong>5.3.1选择排序实现案例</strong></h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

&#x2F;&#x2F;打印数组
void PrintArray(int* arr, int length)&#123;
	for (int i &#x3D; 0; i &lt; length; i++)&#123;
		printf(&quot;%d &quot;, arr[i]);
	&#125;
	printf(&quot;\n&quot;);
&#125;

&#x2F;&#x2F;交换函数
void swap(int* arr, int pos1, int pos2)&#123;

	int temp &#x3D; arr[pos1];
	arr[pos1] &#x3D; arr[pos2];
	arr[pos2] &#x3D; temp;

&#125;

&#x2F;&#x2F;选择排序
void SelectSort(int* arr,int length)&#123;

	int i, j;
	int min;

	for (i &#x3D; 0; i &lt; length; i++)&#123;

		min &#x3D; i;
		for (j &#x3D; i + 1; j &lt; length;j++)&#123;
			
			if (arr[min] &gt; arr[j])&#123;
				min &#x3D; j;
			&#125;
		&#125;

		if (i !&#x3D; min)&#123;
			swap(arr,min,i);
		&#125;
	&#125;
&#125;

void test01()&#123;

	int array[] &#x3D; &#123; 23, 12, 89, 6, 45, 77, 67 &#125;;
	int length &#x3D; sizeof(array) &#x2F; sizeof(int);
	&#x2F;&#x2F;打印选择排序前的数组
	printf(&quot;打印选择排序前的数组:\n&quot;);
	PrintArray(array,length);
	&#x2F;&#x2F;对数组进行选择排序
	SelectSort(array, length);
	&#x2F;&#x2F;打印选择排序前的数组
	printf(&quot;打印选择排序后的数组:\n&quot;);
	PrintArray(array, length);
&#125;

int main()&#123;

	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="5-3-2选择排序总结"><a href="#5-3-2选择排序总结" class="headerlink" title="5.3.2选择排序总结"></a><strong>5.3.2选择排序总结</strong></h4><ul>
<li>稳定性</li>
<li> <strong>选择排序是不稳定的排序方法</strong></li>
<li> <strong>选择排序效率：O（n²）</strong></li>
</ul>
<h3 id="5-4插入排序"><a href="#5-4插入排序" class="headerlink" title="5.4插入排序"></a><strong>5.4插入排序</strong></h3><p><img src="http://qiniu.orangew.cn/img/wps8E06.tmp.jpg" alt="img"> </p>
<h4 id="5-4-1插入排序实现案例"><a href="#5-4-1插入排序实现案例" class="headerlink" title="5.4.1插入排序实现案例"></a><strong>5.4.1插入排序实现案例</strong></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;


&#x2F;&#x2F;打印数组
void PrintArray(int* arr, int length)&#123;
	for (int i &#x3D; 0; i &lt; length; i++)&#123;
		printf(&quot;%d &quot;, arr[i]);
	&#125;
	printf(&quot;\n&quot;);
&#125;

&#x2F;&#x2F;插入排序
void InsertSort(int* arr, int length)&#123;
	
	int i, j;
	for (i &#x3D; 1; i &lt; length; i++)&#123;
		
		if (arr[i] &lt; arr[i-1])&#123;
			
			int temp &#x3D; arr[i];
			for (j &#x3D; i - 1; j &gt;&#x3D; 0 &amp;&amp; arr[j] &gt; temp; j--)&#123;
				arr[j + 1] &#x3D; arr[j];
			&#125;
			arr[j+1] &#x3D; temp;
		&#125;
	&#125;
&#125;

void test01()&#123;

	int array[] &#x3D; &#123; 23, 12, 89, 6, 45, 77, 67 &#125;;
	int length &#x3D; sizeof(array) &#x2F; sizeof(int);
	&#x2F;&#x2F;打印插入排序前的数组
	printf(&quot;打印插入排序前的数组:\n&quot;);
	PrintArray(array, length);
	&#x2F;&#x2F;对数组进行插入排序
	InsertSort(array, length);
	printf(&quot;打印插入排序后的数组:\n&quot;);
	PrintArray(array, length);
&#125;

int main()&#123;

	test01();


	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="5-4-2插入排序总结"><a href="#5-4-2插入排序总结" class="headerlink" title="5.4.2插入排序总结"></a><strong>5.4.2插入排序总结</strong></h4><ul>
<li>稳定性</li>
<li> <strong>插入排序是稳定的排序算法</strong></li>
<li><strong>插入排序效率：O（n²）</strong></li>
</ul>
<h3 id="5-5希尔排序"><a href="#5-5希尔排序" class="headerlink" title="5.5希尔排序"></a><strong>5.5希尔排序</strong></h3><ul>
<li>算法介绍</li>
<li><strong>希尔排序的实质就是分组插入排序</strong>，该方法又称缩小增量排序，因DL．Shell于1959年提出而得名。</li>
<li>基本思想</li>
</ul>
<p><strong>先将整个待排元素序列分割成若干个子序列（由相隔某个“增量”的元素组成的）分别进行直接插入排序，然后依次缩减增量再进行排序，待整个序列中的元素基本有序（增量足够小）时，再对全体元素进行一次直接插入排序。因为直接插入排序在元素基本有序的情况下（接近最好情况），效率是很高的，因此希尔排序在时间效率上比前三种方法有较大提高。</strong></p>
<h3 id="5-5-1希尔排序实现案例"><a href="#5-5-1希尔排序实现案例" class="headerlink" title="5.5.1希尔排序实现案例"></a><strong>5.5.1希尔排序实现案例</strong></h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

&#x2F;&#x2F;打印数组
void PrintArray(int* arr, int length)&#123;
	for (int i &#x3D; 0; i &lt; length; i++)&#123;
		printf(&quot;%d &quot;, arr[i]);
	&#125;
	printf(&quot;\n&quot;);
&#125;

&#x2F;&#x2F;希尔排序
void ShellSort(int* arr, int length)&#123;

	int i, j, k;
	int increament &#x3D; length;  &#x2F;&#x2F;初始增量

	while (increament &gt; 1)&#123;

		increament &#x3D; increament &#x2F; 3 + 1;
		&#x2F;&#x2F;分组
		for (i &#x3D; 0; i &lt; increament; i ++)&#123;
			&#x2F;&#x2F;遍历每一个分组，并对每一组的元素进行插入排序
			for (j &#x3D; i + increament; j &lt; length; j+&#x3D;increament)&#123;
				int temp &#x3D; arr[j];
				if (arr[j-increament] &gt; arr[j])&#123;
					for (k &#x3D; j - increament; k &gt;&#x3D; 0 &amp;&amp; temp &lt; arr[k]; k -&#x3D; increament)&#123;
						arr[k + increament] &#x3D; arr[k];
					&#125;
					arr[k + increament] &#x3D; temp;
				&#125;
			&#125;
		&#125;
	&#125;
&#125;

void test01()&#123;

	int array[] &#x3D; &#123; 23, 12, 89, 6, 45, 77, 67 &#125;;
	int length &#x3D; sizeof(array) &#x2F; sizeof(int);
	&#x2F;&#x2F;打印希尔排序前的数组
	printf(&quot;打印希尔排序前的数组:\n&quot;);
	PrintArray(array, length);
	&#x2F;&#x2F;对数组进行希尔排序
	ShellSort(array, length);
	printf(&quot;打印希尔排序后的数组:\n&quot;);
	PrintArray(array, length);

&#125;

int main()&#123;

	test01();
	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="5-6快速排序"><a href="#5-6快速排序" class="headerlink" title="5.6快速排序"></a><strong>5.6快速排序</strong></h2><ul>
<li>算法介绍</li>
<li>快速排序是C.R.A.Hoare于1962年提出的<strong>一种划分交换排序</strong>。它<strong>采用了一种分治的策略</strong>，通常称其为分治法(Divide-and-ConquerMethod)。</li>
<li>分治法基本思想</li>
<li>先从数列中取出一个数作为基准数（枢轴）。</li>
<li> <strong>分区过程将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。(升序)</strong></li>
<li>再对左右区间重复第二步，直到各区间只有一个数。</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8E07.tmp.jpg" alt="img"></p>
<h4 id="5-6-1快速排序实现案例"><a href="#5-6-1快速排序实现案例" class="headerlink" title="5.6.1快速排序实现案例"></a><strong>5.6.1快速排序实现案例</strong></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;

&#x2F;&#x2F;打印数组
void PrintArray(int* arr, int length)&#123;
	for (int i &#x3D; 0; i &lt; length; i++)&#123;
		printf(&quot;%d &quot;, arr[i]);
	&#125;
	printf(&quot;\n&quot;);
&#125;

&#x2F;&#x2F;快速排序
void QuickSort(int* arr,int low,int height)&#123;

	int left &#x3D; low;
	int right &#x3D; height;
	&#x2F;&#x2F;取出基准数
	int target &#x3D; arr[left];
	
	if (left &lt; right)&#123;

		while (left &lt; right)&#123;
			
			&#x2F;&#x2F;因为在左边挖坑，从右面开始　找比基准数小的
			while (left &lt; right &amp;&amp; arr[right] &gt; target)&#123;
				right--;
			&#125;
			if (left &lt; right)&#123;
				arr[left] &#x3D; arr[right];
				left++;
			&#125;

			&#x2F;&#x2F;从左向右找比基准数大的
			while (left &lt; right &amp;&amp; arr[left] &lt; target)&#123;
				left++;
			&#125;
			if (left &lt; right)&#123;
				arr[right] &#x3D; arr[left];
				right--;
			&#125;

		&#125;
		&#x2F;&#x2F;这个时候left和right同时指向的位置，将基准数插入这个位置
		arr[left] &#x3D; target;

		QuickSort(arr, low, left - 1);
		QuickSort(arr, left + 1, height);

	&#125;
&#125;

void test01()&#123;
	
	int array[] &#x3D; &#123; 23, 12, 89, 6, 45, 77, 67 &#125;;
	int length &#x3D; sizeof(array) &#x2F; sizeof(int);
	&#x2F;&#x2F;打印快速排序前的数组
	printf(&quot;打印快速排序前的数组:\n&quot;);
	PrintArray(array, length);
	&#x2F;&#x2F;对数组进行快速排序
	QuickSort(array, 0,length-1);
	printf(&quot;打印快速排序后的数组:\n&quot;);
	PrintArray(array, length);

&#125;

int main()&#123;
	test01();
	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="5-7归并排序"><a href="#5-7归并排序" class="headerlink" title="5.7归并排序"></a><strong>5.7归并排序</strong></h3><ul>
<li><p>算法介绍</p>
</li>
<li><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p>
</li>
<li><p>基本思想</p>
</li>
<li><p><strong>基本思路就是将数组分成二组A，B，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序</strong>。如何让这二组组内数据有序了？</p>
</li>
<li><p><strong>可以将A，B组各自再分成二组。依次类推,当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数列，再合并数列就完成了归并排序。</strong></p>
</li>
<li><p><strong>归并的定义</strong>                </p>
</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8E18.tmp.jpg" alt="img"> </p>
<p><img src="E:\Computer\myblog\hexo\source_posts\数据结构讲义\wps8E19.tmp.jpg" alt="img"> </p>
<ul>
<li> <strong>如何合并连个有序序列？？？</strong></li>
</ul>
<ul>
<li>只要从比较二个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。</li>
</ul>
<h4 id="5-7-1归并排序实现案例"><a href="#5-7-1归并排序实现案例" class="headerlink" title="5.7.1归并排序实现案例"></a><strong>5.7.1归并排序实现案例</strong></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;



&#x2F;&#x2F;打印数组
void PrintArray(int* arr, int length)&#123;
	for (int i &#x3D; 0; i &lt; length; i++)&#123;
		printf(&quot;%d &quot;, arr[i]);
	&#125;
	printf(&quot;\n&quot;);
&#125;

void Merge(int arr[],int first,int last,int mid,int temp[])&#123;
		
	int i &#x3D; first; &#x2F;&#x2F;第一个有序序列开始的下标
	int j &#x3D; mid + 1; &#x2F;&#x2F;第二个有序序列开始的下标
	int length &#x3D; 0;

	&#x2F;&#x2F;开始合并两个有序序列
	while (i &lt;&#x3D; mid &amp;&amp; j &lt;&#x3D; last)&#123;
		
		&#x2F;&#x2F;找当前两个数中最小的数
		if (arr[i] &lt; arr[j])&#123;
			&#x2F;&#x2F;将最小数放到temp中
			temp[length] &#x3D; arr[i];
			i++;
		&#125;
		else&#123;
			temp[length] &#x3D; arr[j];
			j++;
		&#125;

		length++;
	&#125;

	&#x2F;&#x2F;两个序列中肯定有一个还剩下数据，但是这里我不知道那个还剩下数据,所以我写两个while循环
	while (i &lt;&#x3D; mid)&#123;
		temp[length] &#x3D; arr[i];
		i++;
		length++;
	&#125;

	while (j &lt;&#x3D; last)&#123;
		temp[length] &#x3D; arr[j];
		j++;
		length++;
	&#125;

	&#x2F;&#x2F;覆盖原来位置的无序序列
	for (int i &#x3D; 0; i &lt; length; i++)&#123;
		&#x2F;&#x2F;printf(&quot;%d &quot;,temp[i]);
		arr[first + i] &#x3D; temp[i];
	&#125;
	&#x2F;&#x2F;printf(&quot;\n&quot;);

&#125;

&#x2F;&#x2F;归并排序
void MergeSort(int arr[], int first, int last, int temp[])&#123;

	if (first &#x3D;&#x3D; last)&#123;
		return;
	&#125;
	&#x2F;&#x2F;从哪里拆分？我们这里从中间拆分
	int mid &#x3D; (first + last) &#x2F; 2;
	&#x2F;&#x2F;对左半部分进行拆分
	MergeSort(arr, first, mid, temp);
	&#x2F;&#x2F;对右半部分拆分
	MergeSort(arr, mid + 1, last, temp);
	&#x2F;&#x2F;拆分完了，然后合并
	Merge(arr, first, last, mid, temp);
&#125;

void test01()&#123;
	
	int array[] &#x3D; &#123; 23, 12, 89, 6, 45, 77, 67&#125;;
	int length &#x3D; sizeof(array) &#x2F; sizeof(int);
	&#x2F;&#x2F;打印归并排序前的数组
	printf(&quot;打印归并排序前的数组:\n&quot;);
	PrintArray(array, length);
	&#x2F;&#x2F;对数组进行归并排序
	int* temp &#x3D; (int*)malloc(sizeof(int)* length);
	MergeSort(array, 0, length - 1, temp);
	free(temp);
	printf(&quot;打印归并排序后的数组:\n&quot;);
	PrintArray(array, length);

&#125;

int main()&#123;
	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="5-8排序总结"><a href="#5-8排序总结" class="headerlink" title="5.8排序总结"></a><strong>5.8排序总结</strong></h2><table>
<thead>
<tr>
<th><strong>排序算法</strong></th>
<th><strong>平均时间复杂度</strong></th>
<th><strong>最坏时间复杂度</strong></th>
<th><strong>平均空间复杂度</strong></th>
<th><strong>稳定性</strong></th>
</tr>
</thead>
<tbody><tr>
<td>选择排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>冒泡排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>直接插入排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(nlogn)</td>
<td>O(n^2)</td>
<td>O(log2n)</td>
<td>不稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlogn)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
</tbody></table>
<h2 id="6-C-模板类与数据结构基础"><a href="#6-C-模板类与数据结构基础" class="headerlink" title="6.C++模板类与数据结构基础"></a><strong>6.C++模板类与数据结构基础</strong></h2><h3 id="6-1前言"><a href="#6-1前言" class="headerlink" title="6.1前言"></a><strong>6.1前言</strong></h3><ul>
<li>C++模板是容器的概念。</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wps8E1A.tmp.jpg" alt="img"> </p>
<ul>
<li><p><strong>理论提高：</strong>所有容器提供的都是值（value）语意，而非引用（reference）语意。<strong>容器执行插入元素的操作时，内部实施拷贝动作。</strong>所以STL容器内存储的元素必须<strong>能够被拷贝</strong>（必须提供拷贝构造函数）。</p>
</li>
<li><p>加入到容器中的元素，应该可以被加入才行。</p>
</li>
</ul>
<h2 id="6-2模板类设计与实现"><a href="#6-2模板类设计与实现" class="headerlink" title="6.2模板类设计与实现"></a><strong>6.2模板类设计与实现</strong></h2><h4 id="6-2-1链表类-链式存储设计与实现"><a href="#6-2-1链表类-链式存储设计与实现" class="headerlink" title="6.2.1链表类_链式存储设计与实现"></a><strong>6.2.1链表类_链式存储设计与实现</strong></h4><ul>
<li>LinkList.hpp</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef LINKLIST_HPP
#define LINKLIST_HPP
#include&lt;string&gt;

&#x2F;&#x2F;c++模板完成单向链表

&#x2F;&#x2F;结点结构
template&lt;class T&gt;
class ListNode&#123;
public:
	T data;  &#x2F;&#x2F;数据域
	ListNode* next; &#x2F;&#x2F;指针域
&#125;;

&#x2F;&#x2F;定义链表类
template&lt;class T&gt;
class LinkList&#123;
public:

	&#x2F;&#x2F;构造函数
	LinkList():length(0),head(NULL)&#123;&#125;

	&#x2F;&#x2F;链表操作相关API
	&#x2F;&#x2F;设置链表长度
	void setLength(int length)&#123;
		if (length &lt; 0)&#123;
			return;
		&#125;
		this-&gt;length &#x3D; length;
	&#125;
	&#x2F;&#x2F;获得链表长度
	int getLength()&#123;
		return this-&gt;length;
	&#125;
	&#x2F;&#x2F;设置链表头结点
	void setHead(ListNode&lt;T&gt;* head)&#123;
		this-&gt;head &#x3D; head;
	&#125;
	&#x2F;&#x2F;获得链表的头结点
	ListNode&lt;T&gt;* getHead()&#123;
		return this-&gt;head;
	&#125;
	&#x2F;&#x2F;插入元素
	int Insert(int pos, T value)&#123;
		
		&#x2F;&#x2F;创建结点
		ListNode&lt;T&gt;* newnode &#x3D; new ListNode&lt;T&gt;();
		newnode-&gt;next &#x3D; NULL;
		newnode-&gt;data &#x3D; value;

		&#x2F;&#x2F;第一次插入
		if (this-&gt;head &#x3D;&#x3D; NULL)&#123;
			this-&gt;head &#x3D; newnode;
			this-&gt;length++;
			return 0;
		&#125;

		&#x2F;&#x2F;头插法
		ListNode&lt;T&gt;* pCurrent &#x3D; head;
		if(pos &#x3D;&#x3D; 0)&#123;
			newnode-&gt;next &#x3D; pCurrent;
			this-&gt;head &#x3D; newnode;
			this-&gt;length++;
			return 0;
		&#125;

		&#x2F;&#x2F;找到插入位置
		&#x2F;&#x2F;ListNode&lt;T&gt;* pCurrent &#x3D; head;
		for (int i &#x3D; 1; i &lt; pos;i++)&#123;
			if (pCurrent-&gt;next &#x3D;&#x3D; NULL)&#123;
				break;
			&#125;
			pCurrent &#x3D; pCurrent-&gt;next;
		&#125;
		&#x2F;&#x2F;插入新的结点
		newnode-&gt;next &#x3D; pCurrent-&gt;next;
		pCurrent-&gt;next &#x3D; newnode;
		this-&gt;length++;
	&#125;

	&#x2F;&#x2F;删除某个位置的结点
	int Delete(int pos)&#123;
		
		if (this-&gt;length &#x3D;&#x3D; 0)&#123;
			return -1;
		&#125;
		if(pos &gt; this-&gt;length || pos &lt; 0)&#123;
			return -2;
		&#125;

		&#x2F;&#x2F;头删法
		if (pos &#x3D;&#x3D; 0)&#123;
			ListNode&lt;T&gt;* pDel &#x3D; this-&gt;head;
			this-&gt;head &#x3D; pDel-&gt;next;
			this-&gt;length--;
			delete pDel;
			return 0;
		&#125;

		&#x2F;&#x2F;找删除的位置
		ListNode&lt;T&gt;* pCurrent &#x3D; head;
		for (int i &#x3D; 1; i &lt; pos;i++)&#123;
			pCurrent &#x3D; pCurrent-&gt;next;
		&#125;

		ListNode&lt;T&gt;* pDel &#x3D; pCurrent-&gt;next;
		&#x2F;&#x2F;重新连接结点
		pCurrent-&gt;next &#x3D; pDel-&gt;next;
		&#x2F;&#x2F;删除结点
		delete pDel;
		this-&gt;length--;
	&#125;

	&#x2F;&#x2F;判断链表是否为空
	bool IsEmpty()&#123;
		if (this-&gt;length &#x3D;&#x3D; 0)&#123;
			return true;
		&#125;
		return false;
	&#125;
	~LinkList()&#123;
		while (this-&gt;length)&#123;
			Delete(0);
		&#125;
	&#125;
private:
	int length; &#x2F;&#x2F;保存结点数量
	ListNode&lt;T&gt;* head;
&#125;;

#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>LinkListTest.cpp</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include&quot;LinkList.hpp&quot;
using namespace std;

&#x2F;&#x2F;测试单向链表容器
void test01()&#123;

	&#x2F;&#x2F;创建容器
	LinkList&lt;int&gt; list;
	&#x2F;&#x2F;向容器中插入数据
	for (int i &#x3D; 0; i &lt; 10; i++)&#123;
		list.Insert(list.getLength(), i);
	&#125;
	&#x2F;&#x2F;遍历打印链表
	ListNode&lt;int&gt;* pCurrent &#x3D; list.getHead();
	while (pCurrent !&#x3D; NULL)&#123;
		cout &lt;&lt; pCurrent-&gt;data &lt;&lt; &quot; &quot;;
		pCurrent &#x3D; pCurrent-&gt;next;
	&#125;
	cout &lt;&lt; endl;


	&#x2F;&#x2F;删除结点
	list.Delete(0);
	list.Delete(1);

	&#x2F;&#x2F;遍历打印链表
	pCurrent &#x3D; list.getHead();
	while (pCurrent !&#x3D; NULL)&#123;
		cout &lt;&lt; pCurrent-&gt;data &lt;&lt; &quot; &quot;;
		pCurrent &#x3D; pCurrent-&gt;next;
	&#125;
	cout &lt;&lt; endl;
&#125;


&#x2F;&#x2F;Teacher类
class Teacher&#123;
public:
	Teacher()&#123;&#125;
	Teacher(string name, int age)&#123;
		this-&gt;m_name &#x3D; name;
		this-&gt;m_age &#x3D; age;
	&#125;
	&#x2F;&#x2F;拷贝构造
	Teacher(const Teacher&amp; t)&#123;
		this-&gt;m_name &#x3D; t.m_name;
		this-&gt;m_age &#x3D; t.m_age;
	&#125;
	&#x2F;&#x2F;重载&#x3D;操作符
	Teacher operator&#x3D;(Teacher&amp; t)&#123;
		this-&gt;m_name &#x3D; t.m_name;
		this-&gt;m_age &#x3D; t.m_age;
		return *this;
	&#125;
public:
	string m_name;
	int m_age;
&#125;;

&#x2F;&#x2F;容器中存储对象 重点：容器元素都是值寓意，而非引用寓意
void test02()&#123;

	&#x2F;&#x2F;创建两个Teacher类的实例
	Teacher t1(&quot;aaa&quot;, 10), t2(&quot;bbb&quot;, 20);
	&#x2F;&#x2F;创建容器
	LinkList&lt;Teacher&gt; list;
	&#x2F;&#x2F;向list中插入元素
	list.Insert(0, t1);
	list.Insert(0, t2);
	&#x2F;&#x2F;打印容器中的元素的值
	ListNode&lt;Teacher&gt;* pCurrent &#x3D; list.getHead();
	while (pCurrent !&#x3D; NULL)&#123;
		cout &lt;&lt; &quot;Name:&quot; &lt;&lt; pCurrent-&gt;data.m_name &lt;&lt; &quot; Age:&quot; &lt;&lt; pCurrent-&gt;data.m_age &lt;&lt; endl;
		pCurrent &#x3D; pCurrent-&gt;next;
	&#125;
	list.Delete(1);
	&#x2F;&#x2F;打印容器中的元素的值
	pCurrent &#x3D; list.getHead();
	while (pCurrent !&#x3D; NULL)&#123;
		cout &lt;&lt; &quot;Name:&quot; &lt;&lt; pCurrent-&gt;data.m_name &lt;&lt; &quot; Age:&quot; &lt;&lt; pCurrent-&gt;data.m_age &lt;&lt; endl;
		pCurrent &#x3D; pCurrent-&gt;next;
	&#125;

&#125;

&#x2F;&#x2F;容器中存储指针
void test03()&#123;

	&#x2F;&#x2F;创建两个Teacher类的实例
	Teacher t1(&quot;aaa&quot;, 10), t2(&quot;bbb&quot;, 20);
	&#x2F;&#x2F;创建容器
	LinkList&lt;Teacher*&gt; list;
	&#x2F;&#x2F;插入元素
	list.Insert(0, &amp;t1);
	list.Insert(0, &amp;t2);

	&#x2F;&#x2F;打印容器中的元素的值
	ListNode&lt;Teacher*&gt;* pCurrent &#x3D; list.getHead();
	while (pCurrent !&#x3D; NULL)&#123;
		cout &lt;&lt; &quot;Name:&quot; &lt;&lt; pCurrent-&gt;data-&gt;m_name &lt;&lt; &quot; Age:&quot; &lt;&lt; pCurrent-&gt;data-&gt;m_age &lt;&lt; endl;
		pCurrent &#x3D; pCurrent-&gt;next;
	&#125;
&#125;

int main()&#123;

	&#x2F;&#x2F;test01();
	&#x2F;&#x2F;test02();
	test03();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="6-2-2栈类-链式存储设计与实现"><a href="#6-2-2栈类-链式存储设计与实现" class="headerlink" title="6.2.2栈类_链式存储设计与实现"></a><strong>6.2.2栈类_链式存储设计与实现</strong></h4><ul>
<li>LinkStack.hpp</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">#ifndef LINKQUEUE_HPP
#define LINKQUEUE_HPP

&#x2F;&#x2F;结点结构
template&lt;class T&gt;
class LinkNode&#123;
public:
	T data;
	LinkNode* next;
&#125;;

&#x2F;&#x2F;队列类
template&lt;class T&gt;
class LinkQueue&#123;
public:
	&#x2F;&#x2F;初始化链式队列
	LinkQueue()&#123;
		pFront &#x3D; NULL;
		pBack &#x3D; NULL;
		mLength &#x3D; 0;
	&#125;
	&#x2F;&#x2F;获得队列长度
	int getLength()&#123;
		return this-&gt;mLength;
	&#125;
	&#x2F;&#x2F;队列加入元素
	void Push(T data)&#123;
		
		&#x2F;&#x2F;创建新的结点
		LinkNode&lt;T&gt;* newnode &#x3D; new LinkNode&lt;T&gt;();
		newnode-&gt;data &#x3D; data;
		newnode-&gt;next &#x3D; NULL;

		&#x2F;&#x2F;判断是不是第一次插入
		if (pFront &#x3D;&#x3D; NULL &amp;&amp; pBack &#x3D;&#x3D; NULL)&#123;
			pFront &#x3D; newnode;
			pBack &#x3D; newnode;
			this-&gt;mLength++;
			return;
		&#125;

		&#x2F;&#x2F;其他情况
		this-&gt;pBack-&gt;next &#x3D; newnode;
		this-&gt;pBack &#x3D; newnode;
		this-&gt;mLength++;

		return;
	&#125;

	T&amp; Front()&#123;
		return this-&gt;pFront-&gt;data;
	&#125;

	void Pop()&#123;

		if (this-&gt;mLength &#x3D;&#x3D; 0)&#123;
			return;
		&#125;

		&#x2F;&#x2F;当队列中只有一个元素的时候
		if (this-&gt;mLength &#x3D;&#x3D; 1)&#123;
			delete this-&gt;pFront;
			this-&gt;pFront &#x3D; NULL;
			this-&gt;pBack &#x3D; NULL;
			this-&gt;mLength--;
			return;
		&#125;

		&#x2F;&#x2F;其他情况
		LinkNode&lt;T&gt;* pDel &#x3D; this-&gt;pFront;
		this-&gt;pFront &#x3D; pDel-&gt;next;
		delete pDel;
		this-&gt;mLength--;
		return;
	&#125;
	~LinkQueue()&#123;
		while (this-&gt;mLength &gt; 0)&#123;
			Pop();
		&#125;
	&#125;
private:
	LinkNode&lt;T&gt;* pFront; &#x2F;&#x2F;队头
	LinkNode&lt;T&gt;* pBack; &#x2F;&#x2F;队尾
	int mLength; &#x2F;&#x2F;队列长度
&#125;;
#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>LinkStackTest.cpp</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&quot;LinkStack.hpp&quot;
using namespace std;

&#x2F;&#x2F;栈容器存储基础数据类型
void test01()&#123;
	
	&#x2F;&#x2F;创建栈容器
	LinkStack&lt;int&gt; lstack;
	&#x2F;&#x2F;向栈中加入元素
	for (int i &#x3D; 10; i &lt; 20;i++)&#123;
		lstack.Push(i);
	&#125;
	&#x2F;&#x2F;打印栈中元素
	while (lstack.getLength() &gt; 0)&#123;
		int val &#x3D; lstack.Top();
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
		lstack.Pop();
	&#125;
	cout &lt;&lt; endl;
&#125;

&#x2F;&#x2F;栈容器存储对象

&#x2F;&#x2F;Teacher类
class Teacher&#123;
public:
	Teacher()&#123;&#125;
	Teacher(string name, int age)&#123;
		this-&gt;m_name &#x3D; name;
		this-&gt;m_age &#x3D; age;
	&#125;
	&#x2F;&#x2F;拷贝构造
	Teacher(const Teacher&amp; t)&#123;
		this-&gt;m_name &#x3D; t.m_name;
		this-&gt;m_age &#x3D; t.m_age;
	&#125;
	&#x2F;&#x2F;重载&#x3D;操作符
	Teacher operator&#x3D;(Teacher&amp; t)&#123;
		this-&gt;m_name &#x3D; t.m_name;
		this-&gt;m_age &#x3D; t.m_age;
		return *this;
	&#125;
public:
	string m_name;
	int m_age;
&#125;;

void test02()&#123;

	&#x2F;&#x2F;创建栈
	LinkStack&lt;Teacher&gt; lstack;
	&#x2F;&#x2F;插入数据
	Teacher t1(&quot;aaa&quot;, 10), t2(&quot;bbb&quot;, 20),t3(&quot;ccc&quot;,30);
	lstack.Push(t1);
	lstack.Push(t2);
	lstack.Push(t3);
	&#x2F;&#x2F;遍历打印
	while (lstack.getLength() &gt; 0)&#123;
		Teacher teahcer &#x3D; lstack.Top();
		cout &lt;&lt; &quot;Name:&quot; &lt;&lt; teahcer.m_name &lt;&lt; &quot; Age:&quot; &lt;&lt; teahcer.m_age &lt;&lt; endl;;
		lstack.Pop();
	&#125;

&#125;

&#x2F;&#x2F;容器存储对象指针
void test03()&#123;
	
	&#x2F;&#x2F;创建栈
	LinkStack&lt;Teacher*&gt; lstack;
	&#x2F;&#x2F;插入数据
	Teacher t1(&quot;aaa&quot;, 10), t2(&quot;bbb&quot;, 20), t3(&quot;ccc&quot;, 30);
	lstack.Push(&amp;t1);
	lstack.Push(&amp;t2);
	lstack.Push(&amp;t3);
	&#x2F;&#x2F;遍历打印
	while (lstack.getLength() &gt; 0)&#123;
		Teacher* teahcer &#x3D; lstack.Top();
		cout &lt;&lt; &quot;Name:&quot; &lt;&lt; teahcer-&gt;m_name &lt;&lt; &quot; Age:&quot; &lt;&lt; teahcer-&gt;m_age &lt;&lt; endl;;
		lstack.Pop();
	&#125;

&#125;

int main()&#123;

	&#x2F;&#x2F;test01();
	&#x2F;&#x2F;test02();
	test03();
	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="6-2-3队列类-链式存储设计与实现"><a href="#6-2-3队列类-链式存储设计与实现" class="headerlink" title="6.2.3队列类_链式存储设计与实现"></a><strong>6.2.3队列类_链式存储设计与实现</strong></h4><ul>
<li>LinkQueue.hpp</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef LINKQUEUE_HPP
#define LINKQUEUE_HPP

&#x2F;&#x2F;结点结构
template&lt;class T&gt;
class LinkNode&#123;
public:
	T data;
	LinkNode* next;
&#125;;

&#x2F;&#x2F;队列类
template&lt;class T&gt;
class LinkQueue&#123;
public:
	&#x2F;&#x2F;初始化链式队列
	LinkQueue()&#123;
		pFront &#x3D; NULL;
		pBack &#x3D; NULL;
		mLength &#x3D; 0;
	&#125;
	&#x2F;&#x2F;获得队列长度
	int getLength()&#123;
		return this-&gt;mLength;
	&#125;
	&#x2F;&#x2F;队列加入元素
	void Push(T data)&#123;
		
		&#x2F;&#x2F;创建新的结点
		LinkNode&lt;T&gt;* newnode &#x3D; new LinkNode&lt;T&gt;();
		newnode-&gt;data &#x3D; data;
		newnode-&gt;next &#x3D; NULL;

		&#x2F;&#x2F;判断是不是第一次插入
		if (pFront &#x3D;&#x3D; NULL &amp;&amp; pBack &#x3D;&#x3D; NULL)&#123;
			pFront &#x3D; newnode;
			pBack &#x3D; newnode;
			this-&gt;mLength++;
			return;
		&#125;

		&#x2F;&#x2F;其他情况
		this-&gt;pBack-&gt;next &#x3D; newnode;
		this-&gt;pBack &#x3D; newnode;
		this-&gt;mLength++;

		return;
	&#125;

	T&amp; Front()&#123;
		return this-&gt;pFront-&gt;data;
	&#125;

	void Pop()&#123;

		if (this-&gt;mLength &#x3D;&#x3D; 0)&#123;
			return;
		&#125;

		&#x2F;&#x2F;当队列中只有一个元素的时候
		if (this-&gt;mLength &#x3D;&#x3D; 1)&#123;
			delete this-&gt;pFront;
			this-&gt;pFront &#x3D; NULL;
			this-&gt;pBack &#x3D; NULL;
			this-&gt;mLength--;
			return;
		&#125;

		&#x2F;&#x2F;其他情况
		LinkNode&lt;T&gt;* pDel &#x3D; this-&gt;pFront;
		this-&gt;pFront &#x3D; pDel-&gt;next;
		delete pDel;
		this-&gt;mLength--;
		return;
	&#125;

private:
	LinkNode&lt;T&gt;* pFront; &#x2F;&#x2F;队头
	LinkNode&lt;T&gt;* pBack; &#x2F;&#x2F;队尾
	int mLength; &#x2F;&#x2F;队列长度
&#125;;

#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>LinkQueueTest.cpp</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&quot;LinkQueue.hpp&quot;
using namespace std;

&#x2F;&#x2F;存储基础数据类型
void test01()&#123;

	&#x2F;&#x2F;创建链式队列
	LinkQueue&lt;int&gt; queue;
	&#x2F;&#x2F;添加数据
	for (int i &#x3D; 0; i &lt; 10;i++)&#123;
		queue.Push(i);
	&#125;
	&#x2F;&#x2F;修改队头元素的值
	queue.Front() &#x3D; 100;
	&#x2F;&#x2F;打印队列
	while (queue.getLength() &gt; 0)&#123;
		int val &#x3D; queue.Front();
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
		queue.Pop();
	&#125;
	cout &lt;&lt; endl;
&#125;

int main()&#123;

	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="6-2-4链表类-顺序存储设计与实现"><a href="#6-2-4链表类-顺序存储设计与实现" class="headerlink" title="6.2.4链表类_顺序存储设计与实现"></a><strong>6.2.4链表类_顺序存储设计与实现</strong></h4><ul>
<li>SqList.hpp</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef SQLIST_HPP
#define SQLIST_HPP

&#x2F;&#x2F;链表类
template&lt;class T&gt;
class SqList&#123;
public:
	&#x2F;&#x2F;构造函数，由用户指定容量
	SqList(int capacity)&#123;
		this-&gt;mCapacity &#x3D; capacity;
		this-&gt;mLength &#x3D; 0;
		this-&gt;mArray &#x3D; new T[capacity];
	&#125;
	&#x2F;&#x2F;获得容量
	int getCapacity()&#123;
		return this-&gt;mCapacity;
	&#125;
	&#x2F;&#x2F;获得链表长度
	int getLength()&#123;
		return this-&gt;mLength;
	&#125;
	&#x2F;&#x2F;获得数组
	T* getArray()&#123;
		return this-&gt;mArray;
	&#125;
	&#x2F;&#x2F;获得指定位置元素
	T Get(int pos)&#123;
		if (pos &gt; this-&gt;mLength - 1)&#123;
			return -1;
		&#125;
		return this-&gt;mArray[pos];
	&#125;
	&#x2F;&#x2F;链表中指定位置插入结点
	void Insert(int pos, T data)&#123;
		if (this-&gt;mLength &gt;&#x3D; this-&gt;mCapacity)&#123;
			return;
		&#125;
		if (pos &gt; this-&gt;mLength)&#123;
			pos &#x3D; this-&gt;mLength - 1;
		&#125;

		this-&gt;mArray[pos] &#x3D; data;
		this-&gt;mLength++;
	&#125;
	&#x2F;&#x2F;删除指定位置结点
	void Delete(int pos)&#123;
		
		if (pos &gt; this-&gt;mLength-1)&#123;
			return;
		&#125;

		for (int i &#x3D; pos; i &lt; mLength;i++)&#123;
			this-&gt;mArray[i] &#x3D; this-&gt;mArray[i + 1];
		&#125;
		this-&gt;mLength--;
	&#125;

	~SqList()&#123;
		if (mArray !&#x3D; NULL)&#123;
			delete mArray;
		&#125;
	&#125;
private:
	int mCapacity;&#x2F;&#x2F;容量
	int mLength;&#x2F;&#x2F;长度
	T* mArray;
&#125;;

#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>SqListTest.cpp</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include&quot;SqList.hpp&quot;
using namespace std;

void test01()&#123;
	
	&#x2F;&#x2F;创建栈
	SqList&lt;int&gt; list(20);
	&#x2F;&#x2F;插入数据
	for (int i &#x3D; 0; i &lt; 20;i++)&#123;
		list.Insert(i,i+1);
	&#125;
	&#x2F;&#x2F;打印数据
	for (int i &#x3D; 0; i &lt; 20;i++)&#123;
		cout &lt;&lt; list.Get(i) &lt;&lt; &quot; &quot;;
	&#125;
	cout &lt;&lt; endl;
&#125;

int main()&#123;
	test01();
	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="6-2-5栈类-顺序存储设计与实现"><a href="#6-2-5栈类-顺序存储设计与实现" class="headerlink" title="6.2.5栈类_顺序存储设计与实现"></a><strong>6.2.5栈类_顺序存储设计与实现</strong></h4><ul>
<li>SqStack.hpp</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef SQSTACK_HPP
#define SQSTACK_HPP

&#x2F;&#x2F;栈的顺序存储
template&lt;class T&gt;
class SqStack&#123;
public:
	&#x2F;&#x2F;构造函数
	SqStack(int capacity)&#123;
		this-&gt;mCapacity &#x3D; capacity;
		this-&gt;mLength &#x3D; 0;
		this-&gt;mArray &#x3D; new T[capacity];
	&#125;
	int getLength()&#123;
		return this-&gt;mLength;
	&#125;
	&#x2F;&#x2F;压栈
	void Push(T data)&#123;
		
		if (this-&gt;mLength &gt;&#x3D; this-&gt;mCapacity)&#123;
			return;
		&#125;

		this-&gt;mArray[this-&gt;mLength] &#x3D; data;
		this-&gt;mLength++;

	&#125;

	&#x2F;&#x2F;出栈
	T Top()&#123;
		return this-&gt;mArray[this-&gt;mLength - 1];
	&#125;

	&#x2F;&#x2F;弹出栈顶元素
	void Pop()&#123;
		this-&gt;mLength--;
	&#125;

	~SqStack()&#123;
		if (this-&gt;mArray !&#x3D; NULL)&#123;
			delete this-&gt;mArray;
		&#125;
	&#125;
private:
	T* mArray;
	int mCapacity; &#x2F;&#x2F;容量
	int mLength; &#x2F;&#x2F;长度
&#125;;

#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>SqStackTest.cpp</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include&quot;SqStack.hpp&quot;
using namespace std;

void test01()&#123;
	
	&#x2F;&#x2F;创建栈
	SqStack&lt;int&gt; stack(20);
	&#x2F;&#x2F;压栈
	for (int i &#x3D; 0; i &lt; 20;i++)&#123;
		stack.Push(i);
	&#125;
	&#x2F;&#x2F;遍历
	while (stack.getLength() &gt; 0)&#123;
		cout &lt;&lt; stack.Top() &lt;&lt; &quot; &quot;;
		stack.Pop();
	&#125;
	cout &lt;&lt; endl;

&#125;

int main()&#123;
	test01();
	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="6-2-6队列类-顺序存储设计与实现"><a href="#6-2-6队列类-顺序存储设计与实现" class="headerlink" title="6.2.6队列类_顺序存储设计与实现"></a><strong>6.2.6队列类_顺序存储设计与实现</strong></h4><ul>
<li>SqQueue.hpp</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef SQQUEUE_HPP
#define SQQUEUE_HPP

&#x2F;&#x2F;队列的顺序存储
template&lt;class T&gt;
class SqQueue&#123;
public:
	SqQueue(int capacity)&#123;
		this-&gt;mCapacity &#x3D; capacity;
		this-&gt;mLength &#x3D; 0;
		this-&gt;mArray &#x3D; new T[capacity];
	&#125;
	&#x2F;&#x2F;获得队列长度
	int getLength()&#123;
		return this-&gt;mLength;
	&#125;

	&#x2F;&#x2F;获得容量
	int getCapacity()&#123;
		return this-&gt;mCapacity;
	&#125;

	&#x2F;&#x2F;入队操作
	void Push(T data)&#123;
		if (this-&gt;mLength &gt;&#x3D; this-&gt;mCapacity)&#123;
			return;
		&#125;
		this-&gt;mArray[mLength] &#x3D; data;
		this-&gt;mLength++;
	&#125;

	&#x2F;&#x2F;出队操作
	T Front()&#123;
		return this-&gt;mArray[0];
	&#125;

	&#x2F;&#x2F;队头弹出元素
	void Pop()&#123;
		for (int i &#x3D; 0; i &lt; mLength; i++)&#123;
			mArray[i] &#x3D; mArray[i + 1];
		&#125;
		this-&gt;mLength--;
	&#125;
private:
	int mLength;
	T* mArray;
	int mCapacity;
&#125;;

#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>SqQueueTest.cpp</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include&quot;SqQueue.hpp&quot;
using namespace std;

void test01()&#123;
	
	&#x2F;&#x2F;创建队列
	SqQueue&lt;int&gt; queue(20);
	&#x2F;&#x2F;向队列中插入元素
	for (int i &#x3D; 0; i &lt; 20;i++)&#123;
		queue.Push(i);
	&#125;
	&#x2F;&#x2F;打印队列元素
	while (queue.getLength() &gt; 0)&#123;
		cout &lt;&lt; queue.Front() &lt;&lt; &quot; &quot;;
		queue.Pop();
	&#125;
	cout &lt;&lt; endl;

&#125;

int main()&#123;
	test01();
	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/c/" rel="tag"><i class="fa fa-tag"></i> c++</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag"><i class="fa fa-tag"></i> 数据结构</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/07/UML/" rel="prev" title="UML">
      <i class="fa fa-chevron-left"></i> UML
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/07/08/C-%E4%BB%8E0%E5%88%B01%E5%85%A5%E9%97%A8/" rel="next" title="C++从0到1入门">
      C++从0到1入门 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">1.数据结构概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">1.1数据结构相关概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-1%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1.1为什么要学习数据结构?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.1.2数据结构中的基本概念</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2%E7%AE%97%E6%B3%95"><span class="nav-number">1.2.</span> <span class="nav-text">1.2算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-1%E7%AE%97%E6%B3%95%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1算法的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-2%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8C%BA%E5%88%AB"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2算法和数据结构区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-3%E7%AE%97%E6%B3%95%E7%89%B9%E6%80%A7"><span class="nav-number">1.2.3.</span> <span class="nav-text">1.2.3算法特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-4%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E7%9A%84%E5%BA%A6%E9%87%8F"><span class="nav-number">1.2.4.</span> <span class="nav-text">1.2.4算法效率的度量</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-4-1%E4%BA%8B%E5%90%8E%E7%BB%9F%E8%AE%A1%E6%B3%95"><span class="nav-number">1.2.4.1.</span> <span class="nav-text">1.2.4.1事后统计法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-4-2%E4%BA%8B%E5%89%8D%E5%88%86%E6%9E%90%E4%BC%B0%E7%AE%97"><span class="nav-number">1.2.4.2.</span> <span class="nav-text">1.2.4.2事前分析估算</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-2-4-3%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">1.2.4.3.</span> <span class="nav-text">1.2.4.3大O表示法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-number">2.</span> <span class="nav-text">2.线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%E7%BA%BF%E6%80%A7%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.</span> <span class="nav-text">2.1线性表基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1%E6%95%B0%E5%AD%A6%E5%AE%9A%E4%B9%89"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.1.1数学定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2%E6%80%A7%E8%B4%A8"><span class="nav-number">2.1.3.</span> <span class="nav-text">2.1.2性质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="nav-number">2.1.4.</span> <span class="nav-text">2.1.3线性表的操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="nav-number">2.2.</span> <span class="nav-text">2.2线性表的顺序存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1线性表顺序存储基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2.2线性表顺序存储的设计与实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.2.3优点和缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-4-%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E6%A1%88%E4%BE%8B"><span class="nav-number">2.2.4.</span> <span class="nav-text">2.2.4 线性表顺序存储案例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="nav-number">2.3.</span> <span class="nav-text">2.3线性表的链式存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.3.1基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.3.2设计与实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="nav-number">2.3.3.</span> <span class="nav-text">2.3.3优点和缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-4%E9%93%BE%E8%A1%A8%E6%8A%80%E6%9C%AF%E9%A2%86%E5%9F%9F%E6%8E%A8%E6%BC%94-%E8%83%BD%E5%8A%9B%E6%8F%90%E9%AB%98"><span class="nav-number">2.3.4.</span> <span class="nav-text">2.3.4链表技术领域推演(能力提高)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-5%E4%BC%81%E4%B8%9A%E9%93%BE%E8%A1%A8-%E9%80%9A%E7%94%A8%E9%93%BE%E8%A1%A8-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8-%E6%A1%88%E4%BE%8B"><span class="nav-number">2.3.5.</span> <span class="nav-text">2.3.5企业链表&#x2F;通用链表(单向链表)案例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="nav-number">2.4.</span> <span class="nav-text">2.4循环链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.4.1.</span> <span class="nav-text">2.4.1循环链表基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.4.2.</span> <span class="nav-text">2.4.2循环链表设计与实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-3%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E6%A1%88%E4%BE%8B"><span class="nav-number">2.4.3.</span> <span class="nav-text">2.4.3循环链表案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-4%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%BA%94%E7%94%A8-%E7%BA%A6%E7%91%9F%E5%A4%AB%E9%97%AE%E9%A2%98"><span class="nav-number">2.4.4.</span> <span class="nav-text">2.4.4循环链表应用(约瑟夫问题)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-5%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90"><span class="nav-number">2.4.5.</span> <span class="nav-text">2.4.5优缺点分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">2.5.</span> <span class="nav-text">2.5双向链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-1%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.5.1.</span> <span class="nav-text">2.5.1双向链表基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-2%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.5.2.</span> <span class="nav-text">2.5.2双向链表设计与实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-3%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E6%A1%88%E4%BE%8B"><span class="nav-number">2.5.3.</span> <span class="nav-text">2.5.3双向链表案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-4%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="nav-number">2.5.4.</span> <span class="nav-text">2.5.4优点和缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%8F%97%E9%99%90%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-number">2.6.</span> <span class="nav-text">3.受限线性表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%E6%A0%88-Stack"><span class="nav-number">2.7.</span> <span class="nav-text">3.1栈(Stack)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.7.1.</span> <span class="nav-text">3.1.1栈的基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="nav-number">2.7.2.</span> <span class="nav-text">3.1.2栈的顺序存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="nav-number">2.7.3.</span> <span class="nav-text">3.1.3栈的链式存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-4%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8-%E6%A1%88%E4%BE%8B"><span class="nav-number">2.7.4.</span> <span class="nav-text">3.1.4栈的应用(案例)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2%E9%98%9F%E5%88%97-Queue"><span class="nav-number">2.8.</span> <span class="nav-text">3.2队列(Queue)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1%E9%98%9F%E5%88%97%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">2.8.1.</span> <span class="nav-text">3.2.1队列基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2%E9%98%9F%E5%88%97%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="nav-number">2.8.2.</span> <span class="nav-text">3.2.2队列常用操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="nav-number">2.8.3.</span> <span class="nav-text">3.2.3队列的顺序存储</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="nav-number">2.8.4.</span> <span class="nav-text">3.2.4队列的链式存储</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">3.</span> <span class="nav-text">4.树和二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">3.1.</span> <span class="nav-text">4.1树的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2%E6%A0%91%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">4.2树的表示法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1%E5%9B%BE%E5%BD%A2%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">3.2.1.</span> <span class="nav-text">4.2.1图形表示法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2%E5%B9%BF%E4%B9%89%E8%A1%A8-%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">3.2.2.</span> <span class="nav-text">4.2.2广义表 表示法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3%E5%B7%A6%E5%AD%A9%E5%AD%90%E5%8F%B3%E5%85%84%E5%BC%9F%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="nav-number">3.2.3.</span> <span class="nav-text">4.2.3左孩子右兄弟表示法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3%E6%A0%91%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.</span> <span class="nav-text">4.3树的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1%E6%A0%91%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.1.</span> <span class="nav-text">4.3.1树的逻辑结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.2.</span> <span class="nav-text">4.3.2树的存储结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A6%82%E5%BF%B5"><span class="nav-number">3.4.</span> <span class="nav-text">4.4二叉树概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">3.4.1.</span> <span class="nav-text">4.4.1二叉树基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="nav-number">3.4.2.</span> <span class="nav-text">4.4.2二叉树的表示</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-3%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="nav-number">3.4.3.</span> <span class="nav-text">4.4.3二叉树的遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-5%E4%BA%8C%E5%8F%89%E6%A0%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5"><span class="nav-number">3.4.4.</span> <span class="nav-text">4.4.5二叉树编程实践</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="nav-number">3.5.</span> <span class="nav-text">4.6二叉树的创建</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-1%E4%B8%AD%E5%BA%8F%E5%92%8C%E5%85%88%E5%BA%8F%E5%88%9B%E5%BB%BA%E6%A0%91"><span class="nav-number">3.5.1.</span> <span class="nav-text">4.6.1中序和先序创建树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-2-%E5%8F%B7%E6%B3%95%E5%88%9B%E5%BB%BA%E6%A0%91"><span class="nav-number">3.5.2.</span> <span class="nav-text">4.6.2#号法创建树</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="nav-number">3.6.</span> <span class="nav-text">4.7霍夫曼树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-1%E6%A6%82%E5%BF%B5"><span class="nav-number">3.6.1.</span> <span class="nav-text">4.7.1概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-7-2%E9%9C%8D%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E9%80%A0"><span class="nav-number">3.6.2.</span> <span class="nav-text">4.7.2霍夫曼树的构造</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%8E%92%E5%BA%8F"><span class="nav-number">4.</span> <span class="nav-text">5.排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">4.1.</span> <span class="nav-text">5.1排序基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-number">4.2.</span> <span class="nav-text">5.2冒泡排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E6%A1%88%E4%BE%8B"><span class="nav-number">4.2.1.</span> <span class="nav-text">5.2.1冒泡排序实现案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-%E6%94%B9%E8%BF%9B%E7%89%88-%E5%AE%9E%E7%8E%B0%E6%A1%88%E4%BE%8B"><span class="nav-number">4.2.2.</span> <span class="nav-text">5.2.2冒泡排序(改进版)实现案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-3%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93"><span class="nav-number">4.2.3.</span> <span class="nav-text">5.2.3冒泡排序总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-number">4.3.</span> <span class="nav-text">5.3选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-1%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E6%A1%88%E4%BE%8B"><span class="nav-number">4.4.</span> <span class="nav-text">5.3.1选择排序实现案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-2%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93"><span class="nav-number">4.4.1.</span> <span class="nav-text">5.3.2选择排序总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-number">4.5.</span> <span class="nav-text">5.4插入排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-1%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E6%A1%88%E4%BE%8B"><span class="nav-number">4.5.1.</span> <span class="nav-text">5.4.1插入排序实现案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-2%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93"><span class="nav-number">4.5.2.</span> <span class="nav-text">5.4.2插入排序总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="nav-number">4.6.</span> <span class="nav-text">5.5希尔排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-1%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E6%A1%88%E4%BE%8B"><span class="nav-number">4.7.</span> <span class="nav-text">5.5.1希尔排序实现案例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="nav-number">5.</span> <span class="nav-text">5.6快速排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-6-1%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E6%A1%88%E4%BE%8B"><span class="nav-number">5.0.1.</span> <span class="nav-text">5.6.1快速排序实现案例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-7%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-number">5.1.</span> <span class="nav-text">5.7归并排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-7-1%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E6%A1%88%E4%BE%8B"><span class="nav-number">5.1.1.</span> <span class="nav-text">5.7.1归并排序实现案例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-8%E6%8E%92%E5%BA%8F%E6%80%BB%E7%BB%93"><span class="nav-number">6.</span> <span class="nav-text">5.8排序总结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-C-%E6%A8%A1%E6%9D%BF%E7%B1%BB%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80"><span class="nav-number">7.</span> <span class="nav-text">6.C++模板类与数据结构基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1%E5%89%8D%E8%A8%80"><span class="nav-number">7.1.</span> <span class="nav-text">6.1前言</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2%E6%A8%A1%E6%9D%BF%E7%B1%BB%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.</span> <span class="nav-text">6.2模板类设计与实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-1%E9%93%BE%E8%A1%A8%E7%B1%BB-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.0.1.</span> <span class="nav-text">6.2.1链表类_链式存储设计与实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-2%E6%A0%88%E7%B1%BB-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.0.2.</span> <span class="nav-text">6.2.2栈类_链式存储设计与实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-3%E9%98%9F%E5%88%97%E7%B1%BB-%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.0.3.</span> <span class="nav-text">6.2.3队列类_链式存储设计与实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-4%E9%93%BE%E8%A1%A8%E7%B1%BB-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.0.4.</span> <span class="nav-text">6.2.4链表类_顺序存储设计与实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-5%E6%A0%88%E7%B1%BB-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.0.5.</span> <span class="nav-text">6.2.5栈类_顺序存储设计与实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-6%E9%98%9F%E5%88%97%E7%B1%BB-%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.0.6.</span> <span class="nav-text">6.2.6队列类_顺序存储设计与实现</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="OrangeW"
      src="/images/orange.png">
  <p class="site-author-name" itemprop="name">OrangeW</p>
  <div class="site-description" itemprop="description">demo_study record</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


<!-- CloudCalendar -->
<div class="widget-wrap" style="width: 90%;margin-left: auto;margin-right: auto; opacity: 0.97;">
	<div class="widget" id="CloudCalendar"></div>
</div>
      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OrangeW</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">885k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">26:49</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
<!-- calendar widget -->

    <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-calendar/calendar.min.js"></script>
    <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-calendar/languages.min.js"></script>
    <script>
    $(function() {
        $('#CloudCalendar').aCalendar('zh-CN',
            $.extend(
                '', {
                    single:true,
                    root:'/calendar/'
                }
            )
        );
    });
    </script>


</body>
</html>
