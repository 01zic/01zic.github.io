<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/orange.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/orange.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/orange.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"01zic.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1.设计模式概述">
<meta property="og:type" content="article">
<meta property="og:title" content="设计模式讲义">
<meta property="og:url" content="https://01zic.github.io/2022/07/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AE%B2%E4%B9%89/index.html">
<meta property="og:site_name" content="orangeWBlog">
<meta property="og:description" content="1.设计模式概述">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB07E.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB07F.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB091.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB0A2.tmp.jpg">
<meta property="og:image" content="e:/Computer/myblog/hexo/source_posts/设计模式讲义/wpsB0B2.tmp.jpg">
<meta property="og:image" content="e:/Computer/myblog/hexo/source_posts/设计模式讲义/wpsB0C3.tmp.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB0C4.tmp.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB0D5.tmp.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB0D6.tmp.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB0E6.tmp.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB0F7.tmp.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB107.tmp.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB118.tmp.png">
<meta property="og:image" content="e:/Computer/myblog/hexo/source_posts/设计模式讲义/wpsB129.tmp.jpg">
<meta property="og:image" content="e:/Computer/myblog/hexo/source_posts/设计模式讲义/wpsB12A.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB13A.tmp.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB13B.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB14C.tmp.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB15D.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB16D.tmp.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB16E.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB17F.tmp.jpg">
<meta property="og:image" content="e:/Computer/myblog/hexo/source_posts/设计模式讲义/wpsB180.tmp.jpg">
<meta property="og:image" content="e:/Computer/myblog/hexo/source_posts/设计模式讲义/wpsB181.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB191.tmp.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB192.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB1A3.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB1A4.tmp.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB1B5.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB1B6.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB1B7.tmp.jpg">
<meta property="og:image" content="e:/Computer/myblog/hexo/source_posts/设计模式讲义/wpsB1B8.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB1B9.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB1BA.tmp.jpg">
<meta property="og:image" content="e:/Computer/myblog/hexo/source_posts/设计模式讲义/wpsB1CA.tmp.jpg">
<meta property="og:image" content="e:/Computer/myblog/hexo/source_posts/设计模式讲义/wpsB1CB.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB1CC.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB1CD.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB1CE.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB1CF.tmp.jpg">
<meta property="og:image" content="e:/Computer/myblog/hexo/source_posts/设计模式讲义/wpsB1D0.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB1D1.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB1E2.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB1E3.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB1E4.tmp.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB1F5.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB1F6.tmp.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB206.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB217.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB218.tmp.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB228.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsB239.tmp.png">
<meta property="article:published_time" content="2022-07-07T09:16:22.000Z">
<meta property="article:modified_time" content="2022-07-07T16:00:24.722Z">
<meta property="article:author" content="OrangeW">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="设计模式">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://qiniu.orangew.cn/img/wpsB07E.tmp.jpg">

<link rel="canonical" href="https://01zic.github.io/2022/07/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AE%B2%E4%B9%89/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>设计模式讲义 | orangeWBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">orangeWBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://01zic.github.io/2022/07/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AE%B2%E4%B9%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/orange.png">
      <meta itemprop="name" content="OrangeW">
      <meta itemprop="description" content="demo_study record">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="orangeWBlog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          设计模式讲义
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-07 17:16:22" itemprop="dateCreated datePublished" datetime="2022-07-07T17:16:22+08:00">2022-07-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-08 00:00:24" itemprop="dateModified" datetime="2022-07-08T00:00:24+08:00">2022-07-08</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>65k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:59</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="1-设计模式概述"><a href="#1-设计模式概述" class="headerlink" title="1.设计模式概述"></a><strong>1.设计模式概述</strong></h2><ul>
<li>如果把修习软件开发当做武功修炼的话，那么可以分为招式和内功。</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wpsB07E.tmp.jpg" alt="img"> <img src="http://qiniu.orangew.cn/img/wpsB07F.tmp.jpg" alt="img"> </p>
<ul>
<li><p>招式： Java、C#、C++等编程语言；</p>
</li>
<li><p>Eclipse、Visual Studio等开发工具；</p>
</li>
<li><p>JSP、ASP.net等开发技术；</p>
</li>
<li><p>Struts、Hibernate、JBPM等框架技术；</p>
</li>
<li><p>内功： 数据结构、算法、设计模式、重构、软件工程</p>
</li>
</ul>
<h3 id="1-1设计模式从何而来"><a href="#1-1设计模式从何而来" class="headerlink" title="1.1设计模式从何而来"></a><strong>1.1设计模式从何而来</strong></h3><p>模式之父——</p>
<p>Christopher Alexander（克里斯托弗.亚历山大）———哈佛大学建筑学博士、美国加州大学伯克利分校建筑学教授、加州大学伯克利分校环境结构研究所所长、美国艺术和科学院院士。 </p>
<h3 id="1-2软件设计模式又从何而来"><a href="#1-2软件设计模式又从何而来" class="headerlink" title="1.2软件设计模式又从何而来"></a><strong>1.2软件设计模式又从何而来</strong></h3><p><img src="http://qiniu.orangew.cn/img/wpsB091.tmp.jpg" alt="img"> </p>
<ul>
<li>  四人组（Gang of Four），简称GoF。Ralph Johnson，Richard Helm，Erich Gamma，John Vlissides</li>
</ul>
<ul>
<li><p> GoF将模式的概念引入软件工程领域，这标志着软件模式的诞生。软件模式(Software Patterns)是将模式的一般概念应用于软件开发领域，即软件开发的总体指导思路或参照样板。软件模式并非仅限于设计模式，还包括架构模式、分析模式和过程模式等，实际上，在软件开发生命周期的每一个阶段都存在着一些被认同的模式。</p>
</li>
<li><p>软件模式与具体的应用领域无关，也就是说无论你从事的是移动应用开发、桌面应用开发、Web应用开发还是嵌入式软件的开发，都可以使用软件模式。无论你是使用Java、C#、Objective-C、VB.net、Smalltalk等纯面向对象编程语言，还是使用C++、PHP、Delphi、JavaScript等可支持面向对象编程的语言，你都需要了解软件设计模式！</p>
</li>
<li><p>我们可用一句大白话：“<strong>在一定环境下，用固定套路解决问题。</strong>”</p>
</li>
</ul>
<h3 id="1-3软件设计模式的种类"><a href="#1-3软件设计模式的种类" class="headerlink" title="1.3软件设计模式的种类"></a><strong>1.3软件设计模式的种类</strong></h3><ul>
<li>GoF提出的设计模式有23个，包括：</li>
</ul>
<ul>
<li>创建型(Creational)模式： 如何创建对象；</li>
</ul>
<ul>
<li>结构型(Structural )模式： 如何实现类或对象的组合；</li>
</ul>
<ul>
<li>行为型(Behavioral)模式： 类或对象怎样交互以及怎样分配职责。</li>
<li> 有一个“简单工厂模式”不属于GoF 23种设计模式，但大部分的设计模式书籍都会对它进行专门的介绍。</li>
<li>设计模式目前种类： GoF的23种  + “简单工厂模式” = 24种。</li>
</ul>
<h3 id="1-4软件设计模式有什么用？"><a href="#1-4软件设计模式有什么用？" class="headerlink" title="1.4软件设计模式有什么用？"></a><strong>1.4软件设计模式有什么用？</strong></h3><ul>
<li> 从高端来讲的话，那么作用大了去了，这里我们也体会不到，那么对于初学者来说，<strong>学习设计模式将有助于更加深入地理解面向对象思想</strong>, 让你知道：</li>
</ul>
<p>​    1. 如何将代码分散在几个不同的类中？</p>
<p>​    2. 为什么要有“接口”？</p>
<p>​    3. 何谓针对抽象编程？</p>
<p>​    4. 何时不应该使用继承？</p>
<p>​    5. 如果不修改源代码增加新功能？</p>
<p>​    6. 更好地阅读和理解现有类库与其他系统中的源代码。</p>
<ul>
<li>学习设计模式会让你早点脱离面向对象编程的“菜鸟期”。</li>
</ul>
<h3 id="1-5如何学好设计模式"><a href="#1-5如何学好设计模式" class="headerlink" title="1.5如何学好设计模式"></a><strong>1.5如何学好设计模式</strong></h3><ul>
<li>设计模式的基础是：<strong>多态</strong>。</li>
</ul>
<ul>
<li>初学者： 积累案例， 不要盲目的背类图。</li>
</ul>
<ul>
<li>初级开发人员：多思考，多梳理，归纳总结，尊重事物的认知规律，注意临界点的突破，不要浮躁。</li>
</ul>
<ul>
<li>中级开发人员：合适的开发环境，寻找合适的设计模式来解决问题。多应用， 对经典则组合设计模式的大量，自由的运用。要不断的追求。</li>
</ul>
<h3 id="1-6设计模式总览表"><a href="#1-6设计模式总览表" class="headerlink" title="1.6设计模式总览表"></a><strong>1.6设计模式总览表</strong></h3><table>
<thead>
<tr>
<th>模式名称</th>
<th>模式名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>创建型模式  Creational Pattern（6）</td>
<td>单例模式★★★★☆</td>
<td>是保证一个类仅有一个实例，并提供一个访问它的全局访问点。</td>
</tr>
<tr>
<td>简单工厂模式★★★☆☆</td>
<td>通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</td>
<td></td>
</tr>
<tr>
<td>工厂方法模式★★★★★</td>
<td>定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。</td>
<td></td>
</tr>
<tr>
<td>抽象工厂模式★★★★★</td>
<td>提供一个创建一系列相关或者相互依赖的接口，而无需指定它们具体的类。</td>
<td></td>
</tr>
<tr>
<td>原型模式★★★☆☆</td>
<td>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</td>
<td></td>
</tr>
<tr>
<td>建造者模式★★☆☆☆</td>
<td>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>模式名称</th>
<th>模式名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>结构型模式Structural Pattern（7）</td>
<td>适配器模式★★★★☆</td>
<td>将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</td>
</tr>
<tr>
<td>桥接模式★★★☆☆</td>
<td>将抽象部分与实际部分分离，使它们都可以独立的变化。</td>
<td></td>
</tr>
<tr>
<td>组合模式★★☆☆☆</td>
<td>将对象组合成树形结构以表示“部分–整体”的层次结构。使得用户对单个对象和组合对象的使用具有一致性。</td>
<td></td>
</tr>
<tr>
<td>装饰模式★★★☆☆</td>
<td>动态的给一个对象添加一些额外的职责。就增加功能来说，此模式比生成子类更为灵活。</td>
<td></td>
</tr>
<tr>
<td>外观模式★★★★★</td>
<td>为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</td>
<td></td>
</tr>
<tr>
<td>享元模式★☆☆☆☆</td>
<td>以共享的方式高效的支持大量的细粒度的对象。</td>
<td></td>
</tr>
<tr>
<td>代理模式★★★★☆</td>
<td>为其他对象提供一种代理以控制对这个对象的访问。</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>模式名称</th>
<th>模式名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>行为型模式Behavioral Pattern（11）</td>
<td>职责链模式★★☆☆☆</td>
<td>在该模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。</td>
</tr>
<tr>
<td>命令模式★★★★☆</td>
<td>将一个请求封装为一个对象，从而使你可用不同的请求对客户端进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</td>
<td></td>
</tr>
<tr>
<td>解释器模式★☆☆☆☆</td>
<td>如何为简单的语言定义一个语法，如何在该语言中表示一个句子，以及如何解释这些句子。</td>
<td></td>
</tr>
<tr>
<td>迭代器模式★☆☆☆☆</td>
<td>提供了一种方法顺序来访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。</td>
<td></td>
</tr>
<tr>
<td>中介者模式★★☆☆☆</td>
<td>定义一个中介对象来封装系列对象之间的交互。终结者使各个对象不需要显示的相互调用 ，从而使其耦合性松散，而且可以独立的改变他们之间的交互。</td>
<td></td>
</tr>
<tr>
<td>备忘录模式★★☆☆☆</td>
<td>是在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</td>
<td></td>
</tr>
<tr>
<td>观察者模式★★★★★</td>
<td>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</td>
<td></td>
</tr>
<tr>
<td>状态模式★★☆☆☆</td>
<td>对象的行为，依赖于它所处的状态。</td>
<td></td>
</tr>
<tr>
<td>策略模式★★★★☆</td>
<td>准备一组算法，并将每一个算法封装起来，使得它们可以互换。</td>
<td></td>
</tr>
<tr>
<td>模板方法模式★★★☆☆</td>
<td>得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</td>
<td></td>
</tr>
<tr>
<td>访问者模式★☆☆☆☆</td>
<td>表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</td>
<td></td>
</tr>
</tbody></table>
<h2 id="2-面向对象设计原则"><a href="#2-面向对象设计原则" class="headerlink" title="2.面向对象设计原则"></a><strong>2.面向对象设计原则</strong></h2><ul>
<li>对于面向对象软件系统的设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。在面向对象设计中，可维护性的复用是以设计原则为基础的。每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平。</li>
</ul>
<ul>
<li>面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则。面向对象设计原则也是我们用于评价一个设计模式的使用效果的重要指标之一。</li>
<li>原则的目的： 高内聚，低耦合</li>
</ul>
<h3 id="2-1面向对象设计原创表"><a href="#2-1面向对象设计原创表" class="headerlink" title="2.1面向对象设计原创表"></a><strong>2.1面向对象设计原创表</strong></h3><table>
<thead>
<tr>
<th>名称</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>单一职责原则(Single Responsibility Principle, SRP)★★★★☆</td>
<td>类的职责单一，对外只提供一种功能，而引起类变化的原因都应该只有一个。</td>
</tr>
<tr>
<td>开闭原则(Open-Closed Principle, OCP)★★★★★</td>
<td>类的改动是通过增加代码进行的，而不是修改源代码。</td>
</tr>
<tr>
<td>里氏代换原则(Liskov Substitution Principle, LSP★★★★★</td>
<td>任何抽象类出现的地方都可以用他的实现类进行替换，实际就是虚拟机制，语言级别实现面向对象功能。</td>
</tr>
<tr>
<td>依赖倒转原则(Dependence Inversion Principle, DIP)★★★★★</td>
<td>依赖于抽象(接口)，不要依赖具体的实现(类)，也就是针对接口编程。</td>
</tr>
<tr>
<td>接口隔离原则(Interface Segregation Principle, ISP★★☆☆☆</td>
<td>不应该强迫用户的程序依赖他们不需要的接口方法。一个接口应该只提供一种对外功能，不应该把所有操作都封装到一个接口中去。</td>
</tr>
<tr>
<td>合成复用原则(Composite Reuse Principle, CRP)★★★★☆</td>
<td>如果使用继承，会导致父类的任何变换都可能影响到子类的行为。如果使用对象组合，就降低了这种依赖关系。对于继承和组合，优先使用组合。</td>
</tr>
<tr>
<td>迪米特法则(Law of Demeter, LoD★★★☆☆</td>
<td>一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。例如在一个程序中，各个模块之间相互调用时，通常会提供一个统一的接口来实现。这样其他模块不需要了解另外一个模块的内部实现细节，这样当一个模块内部的实现发生改变时，不会影响其他模块的使用。（黑盒原理）</td>
</tr>
</tbody></table>
<h4 id="2-1-1开闭原则案例"><a href="#2-1-1开闭原则案例" class="headerlink" title="2.1.1开闭原则案例"></a><strong>2.1.1开闭原则案例</strong></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
using namespace std;

&#x2F;&#x2F;计算器类
class Caculaor&#123;
public:
	Caculaor(int a, int b, string moperator)&#123;
		this-&gt;m_a &#x3D; a;
		this-&gt;m_b &#x3D; b;
		this-&gt;m_operator &#x3D; moperator;
	&#125;

	int getResult()&#123;
		
		if (m_operator.compare(&quot;+&quot;) &#x3D;&#x3D; 0)&#123;
			return m_a + m_b;
		&#125;
		else if (m_operator.compare(&quot;-&quot;) &#x3D;&#x3D; 0)&#123;
			return m_a - m_b;
		&#125;
		else if (m_operator.compare(&quot;*&quot;) &#x3D;&#x3D; 0)&#123;
			return m_a * m_b;
		&#125;
		else if (m_operator.compare(&quot;&#x2F;&quot;) &#x3D;&#x3D; 0)&#123;
			return m_a &#x2F; m_b;
		&#125;

	&#125;

private:
	int m_a;
	int m_b;
	string m_operator;
	int m_ret;
&#125;;

&#x2F;*
	缺点： 如果增加取模的运算 需要修改getResult成员方法，如果增加新功能的情况下要修改源代码，那么
	就会有修改出错的可能性。我们应该在增加新的功能时候，不能影响其他已经完成的功能。这就是对修改关闭，
	对扩展开放，叫做开闭原则

*&#x2F;

void test01()&#123;
	Caculaor* caculator &#x3D; new Caculaor(10, 20, &quot;+&quot;);
	cout &lt;&lt; caculator-&gt;getResult() &lt;&lt; endl;
&#125;



&#x2F;* 计算器 开闭原则 start *&#x2F;

&#x2F;&#x2F;计算器的抽象类
class AbstractCaculator&#123;
public:
	AbstractCaculator(int a,int b) :m_a(a), m_b(b)&#123;&#125;
	virtual int getResult() &#x3D; 0;
protected:
	int m_a;
	int m_b;
&#125;;

&#x2F;&#x2F;加法类
class Plus : public AbstractCaculator&#123;
public:
	Plus(int a, int b) :AbstractCaculator(a, b)&#123;&#125;
	virtual int getResult()&#123;
		return m_a + m_b;
	&#125;
&#125;;

&#x2F;&#x2F;减法类
class Minute : public AbstractCaculator&#123;
public:
	Minute(int a, int b) :AbstractCaculator(a, b)&#123;&#125;
	virtual int getResult()&#123;
		return m_a - m_b;
	&#125;
&#125;;


void test02()&#123;
	
	AbstractCaculator* caculator &#x3D; NULL;
	caculator &#x3D; new Plus(10,20);
	cout &lt;&lt; caculator-&gt;getResult() &lt;&lt; endl;

	delete caculator;

	caculator &#x3D; new Minute(10,20);
	cout &lt;&lt; caculator-&gt;getResult() &lt;&lt; endl;

&#125;

&#x2F;* 计算器 开闭原则 end *&#x2F;

int main()&#123;

	&#x2F;&#x2F;test01();
	test02();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="2-1-2迪米特法则案例"><a href="#2-1-2迪米特法则案例" class="headerlink" title="2.1.2迪米特法则案例"></a><strong>2.1.2迪米特法则案例</strong></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;list&gt;
using namespace std;


&#x2F;&#x2F;楼盘基类
class AbstractBuilding&#123;
public:
	AbstractBuilding(string quality) :m_quality(quality)&#123;&#125;
	virtual void sale() &#x3D; 0;
	string getQuality()&#123;
		return m_quality;
	&#125;
protected:
	string m_quality; &#x2F;&#x2F;楼盘品质
&#125;;

&#x2F;&#x2F;A楼盘
class BuildingA : public AbstractBuilding&#123;
public:
	BuildingA(string quality) :AbstractBuilding(quality)&#123;&#125;
	virtual void sale()&#123;
		cout &lt;&lt; &quot;A楼盘售卖&quot; &lt;&lt; m_quality &lt;&lt; &quot;的房子&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;B楼盘
class BuildingB : public AbstractBuilding&#123;
public:
	BuildingB(string quality) :AbstractBuilding(quality)&#123;&#125;
	virtual void sale()&#123;
		cout &lt;&lt; &quot;B楼盘售卖&quot; &lt;&lt; m_quality &lt;&lt; &quot;的房子&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;房屋中介
class BuildingMediator&#123;
public:
	BuildingMediator()&#123;
		
		AbstractBuilding* building &#x3D; NULL;
		building &#x3D; new BuildingA(&quot;低档品质&quot;);
		this-&gt;addNewBuilding(building);

		building &#x3D; new BuildingB(&quot;高档品质&quot;);
		this-&gt;addNewBuilding(building);

	&#125;
	void addNewBuilding(AbstractBuilding* building)&#123;
		m_list.push_back(building);
	&#125;
	AbstractBuilding* findBuilding(string quality)&#123;
		for (list&lt;AbstractBuilding*&gt;::iterator it &#x3D; m_list.begin(); it !&#x3D; m_list.end();it ++)&#123;
			if ((*it)-&gt;getQuality().compare(quality) &#x3D;&#x3D; 0)&#123;
				return *it;
			&#125;
		&#125;

		return NULL;
	&#125;
private:
	list&lt;AbstractBuilding*&gt; m_list;
&#125;;

void test01()&#123;
	
	BuildingMediator* mediator &#x3D; new BuildingMediator;
	AbstractBuilding* building &#x3D;  mediator-&gt;findBuilding(&quot;高档品质&quot;);
	if (building !&#x3D; NULL)&#123;
		building-&gt;sale();
	&#125;
	else&#123;
		cout &lt;&lt; &quot;没有符合要求的楼盘!&quot; &lt;&lt; endl;
	&#125;
	
&#125;



int main()&#123;

	test01();


	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="2-1-3合成复用原则案例"><a href="#2-1-3合成复用原则案例" class="headerlink" title="2.1.3合成复用原则案例"></a><strong>2.1.3合成复用原则案例</strong></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
using namespace std;

class Car &#123;
public:
	virtual void run() &#x3D; 0;
&#125;;

class BWMCar : public Car&#123;
public:
	virtual void run()&#123;
		cout &lt;&lt; &quot;宝马车启动...&quot; &lt;&lt; endl;
	&#125;
&#125;;

class DazhongCar : public Car&#123;
public:
	virtual void run()&#123;
		cout &lt;&lt; &quot;大众车启动...&quot; &lt;&lt; endl;
	&#125;
&#125;;

class PersonA : public BWMCar&#123;
public:
	void drive()&#123;
		run();
	&#125;
&#125;;

void test01()&#123;
	
	PersonA* person &#x3D; new PersonA;
	person-&gt;drive();

&#125;

&#x2F;*
	合成复用原则
	对于继承和组合 优先使用组合
*&#x2F;
class PersonB&#123;
public:
	PersonB(Car* car)&#123;
		pCar &#x3D; car;
	&#125;
	void drive()&#123;
		pCar-&gt;run();
	&#125;
	~PersonB()&#123;
		if (pCar !&#x3D; NULL)&#123;
			delete pCar;
		&#125;
	&#125;
private:
	Car* pCar;
&#125;;

void test02()&#123;

	PersonB* person &#x3D; new PersonB(new BWMCar);
	person-&gt;drive();
	delete person;

	person &#x3D; new PersonB(new DazhongCar);
	person-&gt;drive();
	delete person;
&#125;

int main()&#123;

	&#x2F;&#x2F;test01();
	test02();


	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="2-1-4依赖倒转原则案例"><a href="#2-1-4依赖倒转原则案例" class="headerlink" title="2.1.4依赖倒转原则案例"></a><strong>2.1.4依赖倒转原则案例</strong></h4><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="http://qiniu.orangew.cn/img/wpsB0A2.tmp.jpg" alt="img"></td>
</tr>
</tbody></table>
<p><img src="E:\Computer\myblog\hexo\source_posts\设计模式讲义\wpsB0B2.tmp.jpg" alt="img"> </p>
<ul>
<li>传统的设计模式通常是自顶向下逐级依赖，这样，底层模块，中间层模块和高层模块的耦合度极高，若任意修改其中的一个，很容易导致全面积的修改，非常麻烦，那么依赖倒转原则利用多态的先天特性，对中间抽象层进行依赖，这样，底层和高层之间进行了<strong>解耦合</strong>。</li>
</ul>
<ul>
<li>下面我们继续看一个符合依赖倒转原则的例子:</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
using namespace std;

class BankWorker&#123;
public:
	void payService()&#123;
		cout &lt;&lt; &quot;办理付款业务&quot; &lt;&lt; endl;
	&#125;
	void transferService()&#123;
		cout &lt;&lt; &quot;办理转账业务&quot; &lt;&lt; endl;
	&#125;
	void  saveService()&#123;
		cout &lt;&lt; &quot;办理存款业务&quot; &lt;&lt; endl;
	&#125;
&#125;;

void test01()&#123;
	
	BankWorker* worker &#x3D; new BankWorker;
	worker-&gt;payService();&#x2F;&#x2F;存款业务
	worker-&gt;saveService(); &#x2F;&#x2F;存款业务
	worker-&gt;transferService();&#x2F;&#x2F;转账业务

&#125;

&#x2F;&#x2F;依赖倒转原则
&#x2F;&#x2F;抽象层
class AbstractWorkerBank&#123;
public:
	virtual void doBussiness() &#x3D; 0;
&#125;;

&#x2F;&#x2F;只办理存款业务
class SaveBankWorker : public  AbstractWorkerBank&#123;
public:
	virtual void doBussiness()&#123;
		cout &lt;&lt; &quot;办理存款业务&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;只办理转账业务
class TransferBankWorker : public  AbstractWorkerBank&#123;
public:
	virtual void doBussiness()&#123;
		cout &lt;&lt; &quot;办理存款业务&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;只办理付款业务
class PayBankWorker : public  AbstractWorkerBank&#123;
public:
	virtual void doBussiness()&#123;
		cout &lt;&lt; &quot;办理存款业务&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;高层模块
void DoBankBussiness(AbstractWorkerBank* worker)&#123;
	worker-&gt;doBussiness();
	delete worker;
&#125;

void test02()&#123;
	
	DoBankBussiness(new SaveBankWorker); &#x2F;&#x2F;办理存款业务
	DoBankBussiness(new TransferBankWorker); &#x2F;&#x2F;办理转账业务
	DoBankBussiness(new PayBankWorker); &#x2F;&#x2F;办理付款业务

&#125;
int main()&#123;

	&#x2F;&#x2F;test01();
	test02();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="3-创建型模型"><a href="#3-创建型模型" class="headerlink" title="3.创建型模型"></a><strong>3.创建型模型</strong></h2><h3 id="3-1简单工厂模式"><a href="#3-1简单工厂模式" class="headerlink" title="3.1简单工厂模式"></a><strong>3.1简单工厂模式</strong></h3><ul>
<li>简单工厂模式并不属于GoF的23种设计模式。    </li>
</ul>
<ul>
<li>那么为什么我要用工厂模式呢？请看下面的一段程序。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
using namespace std;

&#x2F;&#x2F;水果类
class Fruit&#123;
public:
	Fruit(string name)&#123;
		m_name &#x3D; name;
	&#125;
	void showFruitName()&#123;
		if (m_name.compare(&quot;apple&quot;) &#x3D;&#x3D; 0)&#123;
			cout &lt;&lt; &quot;我是苹果&quot; &lt;&lt; endl;
		&#125;
		else if (m_name.compare(&quot;banana&quot;)&#x3D;&#x3D;0)&#123;
			cout &lt;&lt; &quot;我是香蕉&quot; &lt;&lt; endl;
		&#125;
		else if (m_name.compare(&quot;pear&quot;) &#x3D;&#x3D; 0)&#123;
			cout &lt;&lt; &quot;我是鸭梨&quot; &lt;&lt; endl;
		&#125;
	&#125;
private:
	string m_name;
&#125;;

int main()&#123;

	Fruit* apple &#x3D; new Fruit(&quot;apple&quot;);
	Fruit* banana &#x3D; new Fruit(&quot;banana&quot;);
	Fruit* pear &#x3D; new Fruit(&quot;pear&quot;);

	apple-&gt;showFruitName();
	banana-&gt;showFruitName();
	pear-&gt;showFruitName();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>不难看出，Fruit类是一个“巨大的”类，在该类的设计中存在如下几个问题：    (1) 在Fruit类中包含很多“if…else…”代码块，整个类的代码相当冗长，代码越长，阅读难度、维护难度和测试难度也越大；而且大量条件语句的存在还将影响系统的性能，程序在执行过程中需要做大量的条件判断。</li>
<li>Fruit类的职责过重，它负责初始化和显示所有的水果对象，将各种水果对象的初始化代码和显示代码集中在一个类中实现，违反了“单一职责原则”，不利于类的重用和维护；  </li>
<li>当需要增加新类型的水果时，必须修改Fruit类的源代码，违反了“开闭原则”。</li>
</ul>
<h4 id="3-1-1模式中的角色和职责"><a href="#3-1-1模式中的角色和职责" class="headerlink" title="3.1.1模式中的角色和职责"></a><strong>3.1.1模式中的角色和职责</strong></h4><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="E:\Computer\myblog\hexo\source_posts\设计模式讲义\wpsB0C3.tmp.png" alt="img"></td>
</tr>
</tbody></table>
<ul>
<li>工厂（Factory）角色：简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。</li>
</ul>
<ul>
<li>抽象产品（AbstractProduct）角色：简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。</li>
</ul>
<ul>
<li>具体产品（Concrete Product）角色：简单工厂模式所创建的具体实例对象。</li>
</ul>
<h4 id="3-1-2简单工厂模式案例"><a href="#3-1-2简单工厂模式案例" class="headerlink" title="3.1.2简单工厂模式案例"></a><strong>3.1.2简单工厂模式案例</strong></h4><p><img src="http://qiniu.orangew.cn/img/wpsB0C4.tmp.png" alt="img"> </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;


&#x2F;&#x2F;抽象水果
class Fruit&#123;
public:
	virtual void shoName() &#x3D; 0;
&#125;;

&#x2F;&#x2F;苹果类
class Apple : public Fruit&#123;
public:
	virtual void shoName()&#123;
		cout &lt;&lt; &quot;我是苹果&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;香蕉类
class Banana : public Fruit&#123;
public:
	virtual void shoName()&#123;
		cout &lt;&lt; &quot;我是香蕉&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;鸭梨类
class Pear : public Fruit&#123;
public:
	virtual void shoName()&#123;
		cout &lt;&lt; &quot;我是鸭梨&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;水果工厂
class FruitFactory&#123;
public:
	static Fruit* CreateFruit(string name)&#123;
		if (name.compare(&quot;apple&quot;) &#x3D;&#x3D; 0)&#123;
			return new Apple;
		&#125;
		else if (name.compare(&quot;banana&quot;) &#x3D;&#x3D; 0)&#123;
			return new Banana;
		&#125;
		else if (name.compare(&quot;pear&quot;) &#x3D;&#x3D; 0)&#123;
			return new Pear;
		&#125;
	&#125;
&#125;;

&#x2F;&#x2F;测试
void test01()&#123;
	
	Fruit* fruit &#x3D; NULL;
	fruit &#x3D; FruitFactory::CreateFruit(&quot;apple&quot;);  &#x2F;&#x2F;工厂生产苹果
	fruit-&gt;shoName();
	delete fruit;

	fruit &#x3D; FruitFactory::CreateFruit(&quot;banana&quot;); &#x2F;&#x2F;工厂生产香蕉
	fruit-&gt;shoName();
	delete fruit;

	fruit &#x3D; FruitFactory::CreateFruit(&quot;pear&quot;); &#x2F;&#x2F;工厂生产鸭梨
	fruit-&gt;shoName();
	delete fruit;

&#125;

int main()&#123;

	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="3-1-3简单工厂模式的优缺点"><a href="#3-1-3简单工厂模式的优缺点" class="headerlink" title="3.1.3简单工厂模式的优缺点"></a><strong>3.1.3简单工厂模式的优缺点</strong></h4><p><strong>优点：</strong> </p>
<p>(1)实现了对象创建和使用的分离。(2)不需要记住具体类名，记住参数即可，减少使用者记忆量。</p>
<p><strong>缺点：</strong> </p>
<p>(1)对工厂类职责过重，一旦不能工作，系统受到影响。(2)增加系统中类的个数，复杂度和理解度增加。(3)违反“开闭原则”，添加新产品需要修改工厂逻辑，工厂越来越复杂。</p>
<h4 id="3-1-4适用场景"><a href="#3-1-4适用场景" class="headerlink" title="3.1.4适用场景"></a><strong>3.1.4适用场景</strong></h4><ol>
<li> 工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。</li>
<li>客户端只知道传入工厂类的参数，对于如何创建对象并不关心。</li>
</ol>
<h3 id="3-2工厂方法模式"><a href="#3-2工厂方法模式" class="headerlink" title="3.2工厂方法模式"></a><strong>3.2工厂方法模式</strong></h3><ul>
<li>工厂方法(Factory Method)模式的意义是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类当中。核心工厂类不再负责产品的创建，这样核心类成为一个抽象工厂角色，仅负责具体工厂子类必须实现的接口，这样进一步抽象化的好处是使得工厂方法模式可以使系统在不修改具体工厂角色的情况下引进新的产品。</li>
<li>工厂方法模式是简单工厂模式的衍生，解决了许多简单工厂模式的问题。首先完全实现‘开－闭 原则’，实现了可扩展。</li>
</ul>
<h4 id="3-2-1-工厂方法模式中的角色与职责"><a href="#3-2-1-工厂方法模式中的角色与职责" class="headerlink" title="3.2.1 工厂方法模式中的角色与职责"></a><strong>3.2.1 工厂方法模式中的角色与职责</strong></h4><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="http://qiniu.orangew.cn/img/wpsB0D5.tmp.png" alt="img"></td>
</tr>
</tbody></table>
<ul>
<li>抽象工厂（Abstract Factory）角色：工厂方法模式的核心，任何工厂类都必须实现这个接口。</li>
</ul>
<ul>
<li>工厂（Concrete Factory）角色：具体工厂类是抽象工厂的一个实现，负责实例化产品对象。</li>
</ul>
<ul>
<li>抽象产品（Abstract Product）角色：工厂方法模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。    </li>
</ul>
<ul>
<li>具体产品（Concrete Product）角色：工厂方法模式所创建的具体实例对象。</li>
</ul>
<ul>
<li>简单工厂模式 + “开闭原则” =  工厂方法模式</li>
</ul>
<h4 id="3-2-2工厂方法模式案例"><a href="#3-2-2工厂方法模式案例" class="headerlink" title="3.2.2工厂方法模式案例"></a><strong>3.2.2工厂方法模式案例</strong></h4><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="http://qiniu.orangew.cn/img/wpsB0D6.tmp.png" alt="img"></td>
</tr>
</tbody></table>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
using namespace std;


&#x2F;&#x2F;抽象水果
class AbstractFruit&#123;
public:
	virtual void showName() &#x3D; 0;
&#125;;

&#x2F;* 具体水果 start  *&#x2F;

&#x2F;&#x2F;苹果
class Apple : public AbstractFruit&#123;
public:
	virtual void showName()&#123;
		cout &lt;&lt; &quot;我是苹果&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;香蕉
class Banana : public AbstractFruit&#123;
public:
	virtual void showName()&#123;
		cout &lt;&lt; &quot;我是香蕉&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;鸭梨
class Pear : public AbstractFruit&#123;
public:
	virtual void showName()&#123;
		cout &lt;&lt; &quot;我是鸭梨&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;* 具体水果 end  *&#x2F;

&#x2F;&#x2F;抽象工厂
class AbstractFactory&#123;
public:
	virtual AbstractFruit* CreateFruit() &#x3D; 0;
&#125;;

&#x2F;* 具体工厂类 start *&#x2F;

&#x2F;&#x2F;苹果工厂
class AppleFactory : public AbstractFactory&#123;
public:
	virtual AbstractFruit* CreateFruit()&#123;
		return new Apple;
	&#125;
&#125;;

&#x2F;&#x2F;香蕉工厂
class BananaFactory : public AbstractFactory&#123;
public:
	virtual AbstractFruit* CreateFruit()&#123;
		return new Banana;
	&#125;
&#125;;

&#x2F;&#x2F;鸭梨工厂
class PearFactory : public AbstractFactory&#123;
public:
	virtual AbstractFruit* CreateFruit()&#123;
		return new Pear;
	&#125;
&#125;;

&#x2F;* 具体工厂类 end *&#x2F;


&#x2F;&#x2F;测试
void test01()&#123;
	
	AbstractFactory* factory &#x3D; NULL;
	AbstractFruit* fruit &#x3D; NULL;

	factory &#x3D; new AppleFactory; &#x2F;&#x2F;创建苹果工厂
	fruit &#x3D; factory-&gt;CreateFruit(); &#x2F;&#x2F;苹果工厂生产苹果
	fruit-&gt;showName();

	factory &#x3D; new BananaFactory; &#x2F;&#x2F;创建香蕉工厂
	fruit &#x3D; factory-&gt;CreateFruit(); &#x2F;&#x2F;香蕉工厂生产苹果
	fruit-&gt;showName();

	factory &#x3D; new PearFactory; &#x2F;&#x2F;创建鸭梨工厂
	fruit &#x3D; factory-&gt;CreateFruit(); &#x2F;&#x2F;鸭梨工厂生产苹果
	fruit-&gt;showName();

&#125;

int main()&#123;

	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="3-1-3工厂方法模式的优缺点"><a href="#3-1-3工厂方法模式的优缺点" class="headerlink" title="3.1.3工厂方法模式的优缺点"></a><strong>3.1.3工厂方法模式的优缺点</strong></h4><p><strong>优点：</strong>    </p>
<p>(1)不需要记住具体类名，甚至连具体参数都不用记忆。</p>
<p>(2)实现了对象创建和使用的分离。</p>
<p>(3)系统的可扩展性也就变得非常好，无需修改接口和原类。</p>
<p><strong>缺点</strong>： </p>
<p>(1)增加系统中类的个数，复杂度和理解度增加。</p>
<p>(2)增加了系统的抽象性和理解难度。</p>
<h4 id="3-1-4适用场景-1"><a href="#3-1-4适用场景-1" class="headerlink" title="3.1.4适用场景"></a><strong>3.1.4适用场景</strong></h4><ol>
<li>客户端不知道它所需要的对象的类。</li>
<li>抽象工厂类通过其子类来指定创建哪个对象。</li>
</ol>
<h3 id="3-3抽象工厂模式"><a href="#3-3抽象工厂模式" class="headerlink" title="3.3抽象工厂模式"></a><strong>3.3抽象工厂模式</strong></h3><ul>
<li>工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个工厂只生产一类产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。此时，我们可以考虑将一些相关的产品组成一个“产品族，由同一个工厂来统一生产，这就是我们本文将要学习的抽象工厂模式的基本思想。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="http://qiniu.orangew.cn/img/wpsB0E6.tmp.png" alt="img"></td>
</tr>
</tbody></table>
<ul>
<li> “工厂方法模式”实现多区域水果类图</li>
</ul>
<p>1.当我们想添加一个新产品的时候，比如葡萄，虽然不用修改代码，但是我们需要添加大量的类，而且还需要添加相对的工厂。（系统开销，维护成本）</p>
<p>2.如果我们使用同一地域的水果（日本，日本，日本），那么我们需要分别创建具体的工厂，如果选择出现失误，将会造成混乱，虽然可以加一些约束，但是代码实现变得复杂。</p>
<h4 id="3-3-1模式中的角色和职责"><a href="#3-3-1模式中的角色和职责" class="headerlink" title="3.3.1模式中的角色和职责"></a><strong>3.3.1模式中的角色和职责</strong></h4><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="http://qiniu.orangew.cn/img/wpsB0F7.tmp.png" alt="img"></td>
</tr>
</tbody></table>
<ul>
<li>抽象工厂（Abstract Factory）角色：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。</li>
</ul>
<ul>
<li>具体工厂（Concrete Factory）角色：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。</li>
</ul>
<ul>
<li>抽象产品（Abstract Product）角色：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。</li>
</ul>
<ul>
<li>具体产品（Concrete Product）角色：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。</li>
</ul>
<h4 id="3-3-2抽象工厂模式案例"><a href="#3-3-2抽象工厂模式案例" class="headerlink" title="3.3.2抽象工厂模式案例"></a><strong>3.3.2抽象工厂模式案例</strong></h4><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="http://qiniu.orangew.cn/img/wpsB107.tmp.png" alt="img"></td>
</tr>
</tbody></table>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
using namespace std;

&#x2F;&#x2F;抽象苹果类
class AbstractApple&#123;
public:
	virtual void showName() &#x3D; 0;
&#125;;

&#x2F;&#x2F;抽象香蕉
class AbstractBanana&#123;
public:
	virtual void showName() &#x3D; 0;
&#125;;

&#x2F;&#x2F;抽象鸭梨
class AbstractPear&#123;
public:
	virtual void showName() &#x3D; 0;
&#125;;

&#x2F;&#x2F;中国苹果
class ChineseApple : public AbstractApple&#123;
public:
	virtual void showName()&#123;
		cout &lt;&lt; &quot;中国苹果&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;美国苹果
class AmericanApple : public AbstractApple&#123;
public:
	virtual void showName()&#123;
		cout &lt;&lt; &quot;美国苹果&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;日本苹果
class JapaneseApple : public AbstractApple&#123;
public:
	virtual void showName()&#123;
		cout &lt;&lt; &quot;日本苹果&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;中国香蕉
class ChineseBanana : public AbstractBanana&#123;
public:
	virtual void showName()&#123;
		cout &lt;&lt; &quot;中国香蕉&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;美国香蕉
class AmericanBanana : public AbstractBanana&#123;
public:
	virtual void showName()&#123;
		cout &lt;&lt; &quot;美国香蕉&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;日本香蕉
class JapaneseBanana : public AbstractBanana&#123;
public:
	virtual void showName()&#123;
		cout &lt;&lt; &quot;日本香蕉&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;中国鸭梨
class ChinesePear : public AbstractPear&#123;
public:
	virtual void showName()&#123;
		cout &lt;&lt; &quot;中国鸭梨&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;美国鸭梨
class AmericanPear : public AbstractPear&#123;
public:
	virtual void showName()&#123;
		cout &lt;&lt; &quot;美国鸭梨&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;日本鸭梨
class JapanesePear : public AbstractPear&#123;
public:
	virtual void showName()&#123;
		cout &lt;&lt; &quot;日本鸭梨&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;抽象工厂
class AbstractFactory&#123;
public:
	virtual AbstractApple* CreateApple() &#x3D; 0;
	virtual AbstractBanana* CreateBanana() &#x3D; 0;
	virtual AbstractPear* CreatePear() &#x3D; 0;
&#125;;

&#x2F;&#x2F;中国工厂
class ChineseFactory : public AbstractFactory&#123;
public:
	virtual AbstractApple* CreateApple()&#123;
		return new ChineseApple;
	&#125;
	virtual AbstractBanana* CreateBanana()&#123;
		return new ChineseBanana;
	&#125;
	virtual AbstractPear* CreatePear()&#123;
		return new ChinesePear;
	&#125;
&#125;;

&#x2F;&#x2F;美国工厂
class AmericanFactory : public AbstractFactory&#123;
public:
	virtual AbstractApple* CreateApple()&#123;
		return new AmericanApple;
	&#125;
	virtual AbstractBanana* CreateBanana()&#123;
		return new AmericanBanana;
	&#125;
	virtual AbstractPear* CreatePear()&#123;
		return new AmericanPear;
	&#125;
&#125;;

&#x2F;&#x2F;美国工厂
class JapaneseFactory : public AbstractFactory&#123;
public:
	virtual AbstractApple* CreateApple()&#123;
		return new JapaneseApple;
	&#125;
	virtual AbstractBanana* CreateBanana()&#123;
		return new JapaneseBanana;
	&#125;
	virtual AbstractPear* CreatePear()&#123;
		return new JapanesePear;
	&#125;
&#125;;


void test01()&#123;
	
	AbstractFactory* factory &#x3D; NULL;
	AbstractApple* apple &#x3D; NULL;
	AbstractBanana* banana &#x3D; NULL;
	AbstractPear* pear &#x3D; NULL;

	factory &#x3D; new ChineseFactory; &#x2F;&#x2F;创建中国工厂
	apple &#x3D; factory-&gt;CreateApple();
	banana &#x3D; factory-&gt;CreateBanana();
	pear &#x3D; factory-&gt;CreatePear();

	apple-&gt;showName();
	banana-&gt;showName();
	pear-&gt;showName();

	delete pear;
	delete banana;
	delete apple;
	delete factory;

	factory &#x3D; new AmericanFactory; &#x2F;&#x2F;创建美国工厂
	apple &#x3D; factory-&gt;CreateApple();
	banana &#x3D; factory-&gt;CreateBanana();
	pear &#x3D; factory-&gt;CreatePear();

	apple-&gt;showName();
	banana-&gt;showName();
	pear-&gt;showName();

	delete pear;
	delete banana;
	delete apple;
	delete factory;

	factory &#x3D; new JapaneseFactory; &#x2F;&#x2F;创建日本工厂
	apple &#x3D; factory-&gt;CreateApple();
	banana &#x3D; factory-&gt;CreateBanana();
	pear &#x3D; factory-&gt;CreatePear();

	apple-&gt;showName();
	banana-&gt;showName();
	pear-&gt;showName();

	delete pear;
	delete banana;
	delete apple;
	delete factory;

&#125;

int main()&#123;

	test01();


	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="3-3-3抽象工厂模式的优缺点"><a href="#3-3-3抽象工厂模式的优缺点" class="headerlink" title="3.3.3抽象工厂模式的优缺点"></a><strong>3.3.3抽象工厂模式的优缺点</strong></h4><p><strong>优点：</strong></p>
<p>(1)拥有工厂方法模式的优点</p>
<p>(2)当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。</p>
<p>(3)增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。 </p>
<p><strong>缺点：</strong></p>
<ul>
<li>  增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。</li>
</ul>
<h4 id="3-3-4适用场景"><a href="#3-3-4适用场景" class="headerlink" title="3.3.4适用场景"></a><strong>3.3.4适用场景</strong></h4><p>(1) 系统中有多于一个的产品族。而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。</p>
<p>(2) 产品等级结构稳定。设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。</p>
<h4 id="3-3-5抽象工厂模式练习题"><a href="#3-3-5抽象工厂模式练习题" class="headerlink" title="3.3.5抽象工厂模式练习题"></a><strong>3.3.5抽象工厂模式练习题</strong></h4><p>​    设计一个电脑主板架构，电脑包括（显卡，内存，CPU）3个固定的插口，显卡具有显示功能（display，功能实现只要打印出意义即可）， 内存具有存储功能（storage），cpu具有计算功能（calculate）。</p>
<p>​    现有Intel厂商，nvidia厂商，Kingston厂商，均会生产以上三种硬件。要求组装两台电脑：</p>
<p>​        1台（Intel的CPU，Intel的显卡，Intel的内存）</p>
<p>​        1台（Intel的CPU， nvidia的显卡，Kingston的内存）</p>
<p>​    用抽象工厂模式实现。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
using namespace std;

&#x2F;&#x2F;抽象显卡
class AbstractGraphics&#123;
public:
	virtual void work() &#x3D; 0;
&#125;;

&#x2F;&#x2F;因特尔显卡
class IntelGraphics : public AbstractGraphics&#123;
public:
	virtual void work()&#123;
		cout &lt;&lt; &quot;因特尔显卡开始工作...&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;英伟达显卡
class NvidiaGraphics : public AbstractGraphics&#123;
public:
	virtual void work()&#123;
		cout &lt;&lt; &quot;英伟达显卡开始工作...&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;金士顿显卡
class KingstonGraphics : public AbstractGraphics&#123;
public:
	virtual void work()&#123;
		cout &lt;&lt; &quot;金士顿显卡开始工作...&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;抽象CPU
class AbstractCPU&#123;
public:
	virtual void work() &#x3D; 0;
&#125;;

&#x2F;&#x2F;因特尔CPU
class IntelCPU : public AbstractCPU&#123;
public:
	virtual void work()&#123;
		cout &lt;&lt; &quot;因特尔CPU开始工作...&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;英伟达CPU
class NvidiaCPU : public AbstractCPU&#123;
public:
	virtual void work()&#123;
		cout &lt;&lt; &quot;英伟达CPU开始工作...&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;金士顿CPU
class KingstonCPU : public AbstractCPU&#123;
public:
	virtual void work()&#123;
		cout &lt;&lt; &quot;金士顿CPU开始工作...&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;抽象内存
class AbstractMemory&#123;
public:
	virtual void work() &#x3D; 0;
&#125;;

&#x2F;&#x2F;因特尔内存
class IntelMemory : public AbstractMemory&#123;
public:
	virtual void work()&#123;
		cout &lt;&lt; &quot;因特尔内存开始工作...&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;英伟达内存
class NvidiaMemory : public AbstractMemory&#123;
public:
	virtual void work()&#123;
		cout &lt;&lt; &quot;英伟达内存开始工作...&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;金士顿内存
class KingstonMemory : public AbstractMemory&#123;
public:
	virtual void work()&#123;
		cout &lt;&lt; &quot;金士顿内存开始工作...&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;计算机
class Computer&#123;
public:	
	Computer()&#123;
		this-&gt;pCPU &#x3D; NULL;
		this-&gt;pGraphics &#x3D; NULL;
		this-&gt;pMemory &#x3D; NULL;
	&#125;
	void setCPU(AbstractCPU* cpu)&#123;
		pCPU &#x3D; cpu;
	&#125;
	void setGraphics(AbstractGraphics* graphics)&#123;
		pGraphics &#x3D; graphics;
	&#125;
	void setMemory(AbstractMemory* memory)&#123;
		pMemory &#x3D; memory;
	&#125;

	&#x2F;&#x2F;启动电脑
	void run()&#123;
		if (NULL !&#x3D; pCPU)&#123;
			this-&gt;pCPU-&gt;work();
		&#125;
		if (NULL !&#x3D; this-&gt;pGraphics)&#123;
			this-&gt;pGraphics-&gt;work();
		&#125;
		if (NULL !&#x3D; this-&gt;pMemory)&#123;
			this-&gt;pMemory-&gt;work();
		&#125;
	&#125;
private:
	AbstractCPU* pCPU;
	AbstractGraphics* pGraphics;
	AbstractMemory* pMemory;
&#125;;


&#x2F;&#x2F;抽象工厂
class AbstractFactory&#123;
public:
	virtual AbstractCPU* CreateCPU() &#x3D; 0;
	virtual AbstractGraphics* CreateGraphics() &#x3D; 0;
	virtual AbstractMemory* CreateMemory() &#x3D; 0;
&#125;;

&#x2F;&#x2F;生产第一种电脑的工厂
class FirstComputerFactory : public AbstractFactory&#123;
public:
	virtual AbstractCPU* CreateCPU()&#123;
		return new IntelCPU;
	&#125;
	virtual AbstractGraphics* CreateGraphics()&#123;
		return new IntelGraphics;
	&#125;
	virtual AbstractMemory* CreateMemory()&#123;
		return new IntelMemory;
	&#125;
&#125;;

&#x2F;&#x2F;生产第二种电脑的工厂
class SecondComputerFactory : public AbstractFactory&#123;
public:
	virtual AbstractCPU* CreateCPU()&#123;
		return new IntelCPU;
	&#125;
	virtual AbstractGraphics* CreateGraphics()&#123;
		return new NvidiaGraphics;
	&#125;
	virtual AbstractMemory* CreateMemory()&#123;
		return new KingstonMemory;
	&#125;
&#125;;

void test01()&#123;
		
	Computer* computer &#x3D; new Computer;
	AbstractFactory* factory &#x3D; NULL;
	AbstractCPU* cpu &#x3D; NULL;
	AbstractGraphics* graphics &#x3D; NULL;
	AbstractMemory* memory &#x3D; NULL;

	
	&#x2F;&#x2F;创建生产零件的工厂
	factory &#x3D; new FirstComputerFactory;
	cpu &#x3D; factory-&gt;CreateCPU();
	graphics &#x3D; factory-&gt;CreateGraphics(); 
	memory &#x3D; factory-&gt;CreateMemory();

	&#x2F;&#x2F;组装第一台电脑
	computer-&gt;setCPU(cpu);  &#x2F;&#x2F;安装CPU
	computer-&gt;setGraphics(graphics); &#x2F;&#x2F;安装显卡
	computer-&gt;setMemory(memory); &#x2F;&#x2F;安装内存
	computer-&gt;run(); &#x2F;&#x2F;启动电脑

	delete memory;
	delete graphics;
	delete cpu;
	delete factory;

	cout &lt;&lt; &quot;-------------------------&quot; &lt;&lt; endl;
	factory &#x3D; new SecondComputerFactory;
	cpu &#x3D; factory-&gt;CreateCPU();
	graphics &#x3D; factory-&gt;CreateGraphics();
	memory &#x3D; factory-&gt;CreateMemory();

	&#x2F;&#x2F;组装第二台电脑
	computer-&gt;setCPU(cpu);  &#x2F;&#x2F;安装CPU
	computer-&gt;setGraphics(graphics); &#x2F;&#x2F;安装显卡
	computer-&gt;setMemory(memory); &#x2F;&#x2F;安装内存
	computer-&gt;run(); &#x2F;&#x2F;启动电脑

	delete memory;
	delete graphics;
	delete cpu;
	delete factory;

	delete computer;

&#125;

int main()&#123;

	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="3-4单例模式"><a href="#3-4单例模式" class="headerlink" title="3.4单例模式"></a><strong>3.4单例模式</strong></h3><ul>
<li>单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。</li>
</ul>
<h4 id="3-4-1单例模式中的角色和职责"><a href="#3-4-1单例模式中的角色和职责" class="headerlink" title="3.4.1单例模式中的角色和职责"></a><strong>3.4.1单例模式中的角色和职责</strong></h4><p><img src="http://qiniu.orangew.cn/img/wpsB118.tmp.png" alt="img"></p>
<ul>
<li>Singleton（单例）：在单例类的内部实现只生成一个实例，同时它提供一个静态的getInstance()工厂方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有；在单例类内部定义了一个Singleton类型的静态对象，作为外部共享的唯一实例。</li>
</ul>
<p><strong>如何构建单例:</strong></p>
<p>一是单例模式的类只提供私有的构造函数，</p>
<p>二是类定义中含有一个该类的静态私有对象，</p>
<p>三是该类提供了一个静态的公有的函数用于创建或获取它本身的静态私有对象。</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
using namespace std;

&#x2F;* 懒汉式 *&#x2F;
class Chairman_lazy&#123;
private:
	Chairman_lazy()&#123;&#125;
public:
	static Chairman_lazy* getInstance()&#123;
		if (s_singleton &#x3D;&#x3D; NULL)&#123;
			s_singleton &#x3D; new Chairman_lazy;
		&#125;
		return s_singleton;
	&#125;
private:
	static Chairman_lazy* s_singleton;
&#125;;

Chairman_lazy* Chairman_lazy::s_singleton &#x3D; NULL;

void test01()&#123;
	
	Chairman_lazy* chairman1 &#x3D; Chairman_lazy::getInstance();
	Chairman_lazy* chairman2 &#x3D; Chairman_lazy::getInstance();
	if (chairman1 &#x3D;&#x3D; chairman2)&#123;
		cout &lt;&lt; &quot;指向同一个对象!&quot; &lt;&lt; endl;
	&#125;
	else&#123;
		cout &lt;&lt; &quot;指向不是同一个对象!&quot; &lt;&lt; endl;
	&#125;

&#125;

&#x2F;* 饿汉式 *&#x2F;
class Chairman_hangry&#123;
private:
	Chairman_hangry()&#123;&#125;
public:
	static Chairman_hangry* getInstance()&#123;
		return s_singleton;
	&#125;
private:
	static Chairman_hangry* s_singleton;
&#125;;

&#x2F;&#x2F;初始化
Chairman_hangry* Chairman_hangry::s_singleton &#x3D; new Chairman_hangry;

void test02()&#123;
	
	Chairman_hangry* chairman1 &#x3D; Chairman_hangry::getInstance();
	Chairman_hangry* chairman2 &#x3D; Chairman_hangry::getInstance();
	if (chairman1 &#x3D;&#x3D; chairman2)&#123;
		cout &lt;&lt; &quot;指向同一个对象!&quot; &lt;&lt; endl;
	&#125;
	else&#123;
		cout &lt;&lt; &quot;指向不是同一个对象!&quot; &lt;&lt; endl;
	&#125;
&#125;

int main()&#123;

	&#x2F;&#x2F;test01();
	test02();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="3-4-2单例碰到多线程"><a href="#3-4-2单例碰到多线程" class="headerlink" title="3.4.2单例碰到多线程"></a><strong>3.4.2单例碰到多线程</strong></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include&lt;Windows.h&gt;
using namespace std;

&#x2F;* 懒汉式 *&#x2F;
class Chairman_lazy&#123;
private:
	Chairman_lazy()&#123;&#125;
public:
	static Chairman_lazy* getInstance()&#123;
		if (s_singleton &#x3D;&#x3D; NULL)&#123;
			&#x2F;&#x2F;Sleep(1000); &#x2F;&#x2F;等到1000秒
			s_singleton &#x3D; new Chairman_lazy;
		&#125;
		return s_singleton;
	&#125;
private:
	static Chairman_lazy* s_singleton;
&#125;;

Chairman_lazy* Chairman_lazy::s_singleton &#x3D; NULL;


&#x2F;* 饿汉式 *&#x2F;
class Chairman_hangry&#123;
private:
	Chairman_hangry()&#123;&#125;
public:
	static Chairman_hangry* getInstance()&#123;
		return s_singleton;
	&#125;
private:
	static Chairman_hangry* s_singleton;
&#125;;

&#x2F;&#x2F;初始化
Chairman_hangry* Chairman_hangry::s_singleton &#x3D; new Chairman_hangry;

DWORD WINAPI MyThread_hangry(LPVOID lpThreadParameter)&#123;
	
	Chairman_hangry* chairman &#x3D; Chairman_hangry::getInstance();
	cout &lt;&lt; &quot;单例对象地址:&quot; &lt;&lt; (int*)chairman &lt;&lt; endl;

	return 0;
&#125;

&#x2F;&#x2F;饿汉式单例碰到多线程测试
void test01()&#123;

	HANDLE handler[10];
	for (int i &#x3D; 0; i &lt; 10;i++)&#123;
		handler[i] &#x3D; CreateThread(NULL, NULL, MyThread_hangry, NULL, NULL, NULL);
	&#125;

&#125;

DWORD WINAPI MyThread_lazy(LPVOID lpThreadParameter)&#123;

	Chairman_lazy* chairman &#x3D; Chairman_lazy::getInstance();
	cout &lt;&lt; &quot;单例对象地址:&quot; &lt;&lt; (int*)chairman &lt;&lt; endl;

	return 0;
&#125;

&#x2F;&#x2F;懒汉式单例碰到多线程
void test02()&#123;

	HANDLE handler[10];
	for (int i &#x3D; 0; i &lt; 10; i++)&#123;
		handler[i] &#x3D; CreateThread(NULL, NULL, MyThread_lazy, NULL, NULL, NULL);
	&#125;

&#125;

int main()&#123;

	&#x2F;&#x2F;test01();
	test02();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>Test01函数执行结果(饿汉式单例模式)：</p>
<p><img src="E:\Computer\myblog\hexo\source_posts\设计模式讲义\wpsB129.tmp.jpg" alt="img"> </p>
<p>Test02函数执行结果(懒汉式单例模式)：</p>
<p><img src="E:\Computer\myblog\hexo\source_posts\设计模式讲义\wpsB12A.tmp.jpg" alt="img"> </p>
<p>练习：用单例模式，模拟公司员工使用打印机场景，打印机可以打印员工要输出的内容，并且可以累积打印机使用次数</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class Printer&#123;
private:
	Printer()&#123;
		mCnt &#x3D; 0;
	&#125;
public:
	static Printer* getInstance()&#123;
		return pPrinter;
	&#125;

	&#x2F;&#x2F;提供打印接口
	void print(string content)&#123;
		cout &lt;&lt; &quot;打印内容为:&quot; &lt;&lt; content &lt;&lt; endl;
		mCnt++;
	&#125;
	int getCnt()&#123;
		return this-&gt;mCnt;
	&#125;
private:
	static Printer* pPrinter;
	int mCnt; &#x2F;&#x2F;统计打印次数
&#125;;

Printer* Printer::pPrinter &#x3D; new Printer;

void test01()&#123;
	
	Printer* printer &#x3D; Printer::getInstance();
	printer-&gt;print(&quot;hello world1!&quot;);
	printer-&gt;print(&quot;hello world2!&quot;);
	printer-&gt;print(&quot;hello world3!&quot;);

	cout &lt;&lt; &quot;打印机打印次数:&quot; &lt;&lt; printer-&gt;getCnt() &lt;&lt; endl;

&#125;

int main(void)&#123;
	test01();
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>思考：当单例模式中的懒汉模式遇见多线程，改怎么办？</p>
<h4 id="3-4-3-单例模式的优缺点"><a href="#3-4-3-单例模式的优缺点" class="headerlink" title="3.4.3 单例模式的优缺点"></a><strong>3.4.3 单例模式的优缺点</strong></h4><p><strong>优点:</strong> </p>
<p>(1)单例模式提供了对唯一实例的受控访问。(2)节约系统资源。由于在系统内存中只存在一个对象。</p>
<p><strong>缺点:</strong> </p>
<p>(1) 扩展略难。单例模式中没有抽象层。</p>
<p>(2) 单例类的职责过重。</p>
<h4 id="3-4-4适用场景"><a href="#3-4-4适用场景" class="headerlink" title="3.4.4适用场景"></a><strong>3.4.4适用场景</strong></h4><p>(1) 系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。</p>
<p>(2) 客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</p>
<h2 id="4-结构型模式"><a href="#4-结构型模式" class="headerlink" title="4.结构型模式"></a><strong>4.结构型模式</strong></h2><ul>
<li><strong>让类和类进行组合，获得更大的结构。</strong></li>
</ul>
<h3 id="4-1代理模式"><a href="#4-1代理模式" class="headerlink" title="4.1代理模式"></a><strong>4.1代理模式</strong></h3><ul>
<li>代理模式的定义：<strong>为其他对象提供一种代理以控制对这个对象的访问</strong>。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。</li>
</ul>
<h4 id="4-1-1模式中的角色和职责"><a href="#4-1-1模式中的角色和职责" class="headerlink" title="4.1.1模式中的角色和职责"></a><strong>4.1.1模式中的角色和职责</strong></h4><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="http://qiniu.orangew.cn/img/wpsB13A.tmp.png" alt="img"></td>
</tr>
</tbody></table>
<ul>
<li>subject（抽象主题角色）：真实主题与代理主题的共同接口。</li>
</ul>
<ul>
<li>RealSubject（真实主题角色）：定义了代理角色所代表的真实对象。 </li>
</ul>
<ul>
<li>Proxy（代理主题角色）：含有对真实主题角色的引用，代理角色通常在将客户端调用传递给真是主题对象之前或者之后执行某些操作，而不是单纯返回真实的对象。</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wpsB13B.tmp.jpg" alt="img"></p>
<h4 id="4-1-2代理模式的案例"><a href="#4-1-2代理模式的案例" class="headerlink" title="4.1.2代理模式的案例"></a><strong>4.1.2代理模式的案例</strong></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

&#x2F;&#x2F;商品类
class Goods&#123;
public:
	Goods(bool IsReal, string GoodsName) :m_IsReal(IsReal), m_GoodsName(GoodsName)&#123;&#125;
	bool getIsReal()&#123;
		return m_IsReal;
	&#125;
	string getGoodsName()&#123;
		return m_GoodsName;
	&#125;
private:
	bool m_IsReal;  &#x2F;&#x2F;商品真假
	string m_GoodsName; &#x2F;&#x2F;商品名称
&#125;;


&#x2F;&#x2F;购物抽象
class AbstractShopping&#123;
public:
	virtual void BuyGoods(Goods*) &#x3D; 0; 
&#125;;

&#x2F;&#x2F;韩国购物
class KoreaShopping : public AbstractShopping&#123;
public:
	virtual void BuyGoods(Goods* goods)&#123;
		cout &lt;&lt; &quot;在韩国购买&quot; &lt;&lt; goods-&gt;getGoodsName() &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;美国购物
class AmericanShopping : public AbstractShopping&#123;
public:
	virtual void BuyGoods(Goods* goods)&#123;
		cout &lt;&lt; &quot;在美国购买&quot; &lt;&lt; goods-&gt;getGoodsName() &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;非洲购物
class AfricanShopping : public AbstractShopping&#123;
public:
	virtual void BuyGoods(Goods* goods)&#123;
		cout &lt;&lt; &quot;在非洲购买&quot; &lt;&lt; goods-&gt;getGoodsName() &lt;&lt; endl;
	&#125;
&#125;;


&#x2F;&#x2F;自己购物
void test01()&#123;
	AbstractShopping* shopping &#x3D; NULL;

	&#x2F;&#x2F;去美国买啤酒
	Goods* bear &#x3D; new Goods(true, &quot;啤酒&quot;);
	shopping &#x3D; new AmericanShopping;
	shopping-&gt;BuyGoods(bear);
	delete bear;
	delete shopping;

	&#x2F;&#x2F;去韩国买化妆品
	Goods* cosmetics &#x3D; new Goods(true, &quot;化妆品&quot;);
	shopping &#x3D; new KoreaShopping;
	shopping-&gt;BuyGoods(cosmetics);
	delete cosmetics;
	delete shopping;


	Goods* ivory &#x3D; new Goods(true, &quot;象牙&quot;);
	shopping &#x3D; new AfricanShopping;
	shopping-&gt;BuyGoods(ivory);
	delete ivory;
	delete shopping;
&#125;

&#x2F;&#x2F;现在我不想自己去购物了  自己需要花费路费 还有自己办理货品海关检查 自己辨别商品真伪
&#x2F;&#x2F;海外代购 帮助检查商品真伪 海关检查 
class OverseasShopping : public AbstractShopping&#123;
public:
	OverseasShopping(AbstractShopping* mode)&#123;
		pShoppingMode &#x3D; mode;  &#x2F;&#x2F;购物模式  去韩国买  还是去美国买 还是去非洲买
	&#125;
	virtual void BuyGoods(Goods* goods)&#123;
		if (GoodsIsReal(goods))&#123; &#x2F;&#x2F;如果产品是真的
			CheckGoods(); &#x2F;&#x2F;海关检查
			pShoppingMode-&gt;BuyGoods(goods);
		&#125;
		else&#123;
			cout &lt;&lt; goods-&gt;getGoodsName() &lt;&lt; &quot;是假商品，放弃购买!&quot; &lt;&lt; endl;
		&#125;

		delete goods;
	&#125;
	&#x2F;&#x2F;辨别商品真伪
	bool GoodsIsReal(Goods* goods)&#123;
		cout &lt;&lt; &quot;海外代理检查 &quot;&lt;&lt; goods-&gt;getGoodsName() &lt;&lt; &quot;货品真伪&quot; &lt;&lt; endl;
		return goods-&gt;getIsReal();
	&#125;
	void CheckGoods()&#123;
		cout &lt;&lt; &quot;海外代理商品海关检查&quot; &lt;&lt; endl;
	&#125;
	~OverseasShopping()&#123;
		if (NULL !&#x3D; pShoppingMode)&#123;
			delete pShoppingMode;
		&#125;
	&#125;
private:
	AbstractShopping* pShoppingMode;
&#125;;

void test02()&#123;
	
	AbstractShopping* proxy &#x3D; NULL;
	&#x2F;&#x2F;创建一个去韩国购物的代理
	proxy &#x3D; new OverseasShopping(new KoreaShopping);
	proxy-&gt;BuyGoods(new Goods(true,&quot;化妆品&quot;));
	delete proxy;

	cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;

	&#x2F;&#x2F;创建一个去美国买啤酒的代理
	proxy &#x3D; new OverseasShopping(new AmericanShopping);
	proxy-&gt;BuyGoods(new Goods(false, &quot;啤酒&quot;));
	delete proxy;

	cout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;

	&#x2F;&#x2F;创建一个去非洲买啤象牙的代理
	proxy &#x3D; new OverseasShopping(new AfricanShopping);
	proxy-&gt;BuyGoods(new Goods(true, &quot;象牙&quot;));
	delete proxy;

&#125;

int main()&#123;

	&#x2F;&#x2F;test01();
	test02();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="4-1-3代理模式的优缺点"><a href="#4-1-3代理模式的优缺点" class="headerlink" title="4.1.3代理模式的优缺点"></a><strong>4.1.3代理模式的优缺点</strong></h4><p><strong>优点：</strong></p>
<p> (1)能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。  </p>
<p> (2)客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性。</p>
<p><strong>缺点</strong>:</p>
<ul>
<li>代理实现较为复杂。</li>
</ul>
<h4 id="4-1-4适用场景"><a href="#4-1-4适用场景" class="headerlink" title="4.1.4适用场景"></a><strong>4.1.4适用场景</strong></h4><ul>
<li>​    为其他对象提供一种代理以控制对这个对象的访问。</li>
</ul>
<h4 id="4-1-5-代理模式练习题"><a href="#4-1-5-代理模式练习题" class="headerlink" title="4.1.5 代理模式练习题"></a><strong>4.1.5 代理模式练习题</strong></h4><p>1 定义真实玩家(李逍遥)</p>
<p>2 定义代理玩家</p>
<p>3 代理玩家代替李逍遥打怪升级</p>
<h3 id="4-2装饰模式"><a href="#4-2装饰模式" class="headerlink" title="4.2装饰模式"></a><strong>4.2装饰模式</strong></h3><ul>
<li>装饰模式又叫包装模式，通过一种对客户端透明的方式来扩展对象功能，是继承关系的一种替代。</li>
</ul>
<ul>
<li>装饰模式就是把要附加的功能分别放在单独的类中，并让这个类包含它要装饰的对象，当需要执行时，客户端就可以有选择的、按顺序的使用装饰功能包装对象。</li>
</ul>
<h4 id="4-2-1装饰模式中的角色和职责"><a href="#4-2-1装饰模式中的角色和职责" class="headerlink" title="4.2.1装饰模式中的角色和职责"></a><strong>4.2.1装饰模式中的角色和职责</strong></h4><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="http://qiniu.orangew.cn/img/wpsB14C.tmp.png" alt="img"></td>
</tr>
</tbody></table>
<ul>
<li>Component（抽象构件）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。</li>
</ul>
<ul>
<li>ConcreteComponent（具体构件）：它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。</li>
</ul>
<ul>
<li>Decorator（抽象装饰类）：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。</li>
</ul>
<ul>
<li>ConcreteDecorator（具体装饰类）：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。</li>
</ul>
<h4 id="4-2-2装饰模式案例"><a href="#4-2-2装饰模式案例" class="headerlink" title="4.2.2装饰模式案例"></a><strong>4.2.2装饰模式案例</strong></h4><p><img src="http://qiniu.orangew.cn/img/wpsB15D.tmp.jpg" alt="img"> </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;


&#x2F;&#x2F;抽象手机类
class AbstractCellphone&#123;
public:
	virtual void showPhone() &#x3D; 0;
&#125;;

&#x2F;&#x2F;小米手机
class XiaomiCellphone : public AbstractCellphone&#123;
public:
	XiaomiCellphone(string model)&#123;
		m_name &#x3D; &quot;小米 &quot; + model + &quot;手机&quot;;
	&#125;
	virtual void showPhone()&#123;
		cout &lt;&lt; m_name &lt;&lt; endl;
	&#125;
private:
	string m_name;
&#125;;

&#x2F;&#x2F;Apple手机
class AppleCellphone : public AbstractCellphone&#123;
public:
	AppleCellphone(string model)&#123;
		m_name &#x3D; &quot;小米 &quot; + model + &quot;手机&quot;;
	&#125;
	virtual void showPhone()&#123;
		cout &lt;&lt; m_name &lt;&lt; endl;
	&#125;
private:
	string m_name;
&#125;;

&#x2F;&#x2F;装饰类
class Decorator : public AbstractCellphone&#123;
public:
	Decorator(AbstractCellphone* cellphone)&#123;
		pCellphone &#x3D; cellphone;
	&#125;
	virtual void showPhone()&#123;
		pCellphone-&gt;showPhone();
	&#125;
protected:
	AbstractCellphone* pCellphone;
&#125;;

&#x2F;&#x2F;给手机贴膜
class CellphoneFilm : public Decorator&#123;
public:
	CellphoneFilm(AbstractCellphone* cellphone) :Decorator(cellphone)&#123;&#125;
	void addCellphoneFilm()&#123;
		cout &lt;&lt; &quot;手机已贴膜!&quot; &lt;&lt; endl;
	&#125;
	virtual void showPhone()&#123;
		addCellphoneFilm();
		pCellphone-&gt;showPhone();
	&#125;
&#125;;

&#x2F;&#x2F;给手机装上手机壳
class CellphoneShell : public Decorator&#123;
public:
	CellphoneShell(AbstractCellphone* cellphone) :Decorator(cellphone)&#123;&#125;
	void addShell()&#123;
		cout &lt;&lt; &quot;手机已装上保护壳!&quot; &lt;&lt; endl;
	&#125;
	virtual void showPhone()&#123;
		addShell();
		pCellphone-&gt;showPhone();
	&#125;
&#125;;

void test01()&#123;
	
	&#x2F;&#x2F;创建小米手机
	AbstractCellphone* cellphone &#x3D; NULL;
	cellphone &#x3D; new XiaomiCellphone(&quot;Note 女神版&quot;);
	cellphone-&gt;showPhone();

	cout &lt;&lt; &quot;-----------------------------&quot; &lt;&lt; endl;

	&#x2F;&#x2F;给小米手机贴膜
	Decorator* cellphoneFilm &#x3D; new CellphoneFilm(cellphone);
	cellphoneFilm-&gt;showPhone();

	cout &lt;&lt; &quot;-----------------------------&quot; &lt;&lt; endl;

	&#x2F;&#x2F;给贴膜的小米手机再装上保护壳
	Decorator* cellphoneShell &#x3D; new CellphoneShell(cellphoneFilm);
	cellphoneShell-&gt;showPhone();

	delete cellphoneShell;
	delete cellphoneFilm;
	delete cellphone;

&#125;

int main()&#123;

	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="4-2-3装饰模式的优缺点"><a href="#4-2-3装饰模式的优缺点" class="headerlink" title="4.2.3装饰模式的优缺点"></a><strong>4.2.3装饰模式的优缺点</strong></h4><p><strong>优点：</strong></p>
<p>(1)对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加。</p>
<p>(2)可以通过一种动态的方式来扩展一个对象的功能，从而实现不同的行为。</p>
<p>(3)可以对一个对象进行多次装饰。</p>
<p>(4)具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合“开闭原则”。 </p>
<p><strong>缺点：</strong></p>
<ul>
<li>  使用装饰模式进行系统设计时将产生很多小对象，大量小对象的产生势必会占用更多的系统资源，影响程序的性能。</li>
</ul>
<h4 id="4-2-4-适用场景"><a href="#4-2-4-适用场景" class="headerlink" title="4.2.4 适用场景"></a><strong>4.2.4 适用场景</strong></h4><p>(1) 动态、透明的方式给单个对象添加职责。</p>
<p>(2) 当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。</p>
<ul>
<li>装饰器模式关注于在一个对象上动态的添加方法，然而代理模式关注于控制对对象的访问。换句话说，用代理模式，代理类（proxy class）可以对它的客户隐藏一个对象的具体信息。因此，当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器。</li>
</ul>
<h3 id="4-3外观模式"><a href="#4-3外观模式" class="headerlink" title="4.3外观模式"></a><strong>4.3外观模式</strong></h3><ul>
<li>根据迪米特法则，如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。</li>
</ul>
<ul>
<li>​    Facade模式也叫外观模式，是由GoF提出的23种设计模式中的一种。Facade模式为一组具有类似功能的类群，比如类库，子系统等等，提供一个一致的简单的界面。这个一致的简单的界面被称作facade。</li>
</ul>
<h4 id="4-3-1外观模式中角色和职责"><a href="#4-3-1外观模式中角色和职责" class="headerlink" title="4.3.1外观模式中角色和职责"></a><strong>4.3.1外观模式中角色和职责</strong></h4><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="http://qiniu.orangew.cn/img/wpsB16D.tmp.png" alt="img"></td>
</tr>
</tbody></table>
<ul>
<li>Façade(外观角色)：为调用方, 定义简单的调用接口。</li>
</ul>
<ul>
<li>SubSystem(子系统角色)：功能提供者。指提供功能的类群（模块或子系统） 。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
using namespace std;

&#x2F;*
外观模式就是将复杂的子类系统抽象到同一个的接口进行管理
，外界只需要通过此接口与子类系统进行交互，而不必要直接与复杂的子类
系统进行交互
*&#x2F;

&#x2F;&#x2F;子系统1
class SubSystem1&#123;
public:
	void run()&#123;
		cout &lt;&lt; &quot;子系统一运行...&quot; &lt;&lt; endl;
	&#125;
&#125;;
&#x2F;&#x2F;子系统2
class SubSystem2&#123;
public:
	void run()&#123;
		cout &lt;&lt; &quot;子系统二运行...&quot; &lt;&lt; endl;
	&#125;
&#125;;
&#x2F;&#x2F;子系统3
class SubSystem3&#123;
public:
	void run()&#123;
		cout &lt;&lt; &quot;子系统三运行...&quot; &lt;&lt; endl;
	&#125;
&#125;;
&#x2F;&#x2F;子系统4
class SubSystem4&#123;
public:
	void run()&#123;
		cout &lt;&lt; &quot;子系统四运行...&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;外观类
class Facede&#123;
public:
	Facede()&#123;
		pSystem1 &#x3D; new SubSystem1;
		pSystem2 &#x3D; new SubSystem2;
		pSystem3 &#x3D; new SubSystem3;
		pSystem4 &#x3D; new SubSystem4;
	&#125;
	void runSystem()&#123;
		pSystem1-&gt;run();
		pSystem2-&gt;run();
		pSystem3-&gt;run();
		pSystem4-&gt;run();
	&#125;

private:
	SubSystem1* pSystem1;
	SubSystem2* pSystem2;
	SubSystem3* pSystem3;
	SubSystem4* pSystem4;
&#125;;

void test01()&#123;
	
	Facede* facede &#x3D; new Facede;
	facede-&gt;runSystem();
&#125;


int main()&#123;
	
	test01();


	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="4-3-2外观模式案例"><a href="#4-3-2外观模式案例" class="headerlink" title="4.3.2外观模式案例"></a><strong>4.3.2外观模式案例</strong></h4><ul>
<li>根据类图，实现家庭影院外观模式应用。</li>
</ul>
<ul>
<li>实现KTV模式：电视打开，灯关掉，音响打开，麦克风打开，dvd打开；</li>
</ul>
<ul>
<li>实现游戏模式：电视打开，音响打开，游戏机打开。</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wpsB16E.tmp.jpg" alt="img"> </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
using namespace std;

&#x2F;&#x2F;电视
class Television&#123;
public:
	void On()&#123;
		cout &lt;&lt; &quot;电视打开!&quot; &lt;&lt; endl;
	&#125;
	void Off()&#123;
		cout &lt;&lt; &quot;电视关闭!&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;灯
class Lamp&#123;
public:
	void On()&#123;
		cout &lt;&lt; &quot;灯打开!&quot; &lt;&lt; endl;
	&#125;
	void Off()&#123;
		cout &lt;&lt; &quot;灯关闭!&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;音响
class Audio&#123;
public:
	void On()&#123;
		cout &lt;&lt; &quot;音响打开!&quot; &lt;&lt; endl;
	&#125;
	void Off()&#123;
		cout &lt;&lt; &quot;音响关闭!&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;麦克风
class Microphone&#123;
public:
	void On()&#123;
		cout &lt;&lt; &quot;麦克风打开!&quot; &lt;&lt; endl;
	&#125;
	void Off()&#123;
		cout &lt;&lt; &quot;麦克风关闭!&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;DVD播放机
class DVDPlayer&#123;
public:
	void On()&#123;
		cout &lt;&lt; &quot;DVDPlayer打开!&quot; &lt;&lt; endl;
	&#125;
	void Off()&#123;
		cout &lt;&lt; &quot;DVDPlayer关闭!&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;游戏机
class GameMachine&#123;
public:
	void On()&#123;
		cout &lt;&lt; &quot;游戏机打开!&quot; &lt;&lt; endl;
	&#125;
	void Off()&#123;
		cout &lt;&lt; &quot;游戏界关闭!&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;外观抽象类
class AbstractFacede&#123;
public:
	virtual void On() &#x3D; 0;
	virtual void Off() &#x3D; 0;
&#125;;

&#x2F;&#x2F;游戏模式
class GameMode : public AbstractFacede&#123;
public:
	GameMode()&#123;
		pTelevision &#x3D; new Television;
		pAudio &#x3D; new Audio;
		pGameMachine &#x3D; new GameMachine;
	&#125;
	virtual void On()&#123;
		pTelevision-&gt;On();
		pAudio-&gt;On();
		pGameMachine-&gt;On();
	&#125;
	virtual void Off()&#123;
		pTelevision-&gt;Off();
		pAudio-&gt;Off();
		pGameMachine-&gt;Off();
	&#125;
private:
	Television* pTelevision;
	Audio* pAudio;
	GameMachine* pGameMachine;
&#125;;

&#x2F;&#x2F;KTV模式
class KTVMode : public AbstractFacede&#123;
public:
	KTVMode()&#123;
		pTelevision &#x3D; new Television;
		pAudio &#x3D; new Audio;
		pDVDPlayer &#x3D; new DVDPlayer;
		pLamp &#x3D; new Lamp;
		pMicrophone &#x3D; new Microphone;
	&#125;
	virtual void On()&#123;
		pTelevision-&gt;On();
		pAudio-&gt;On();
		pDVDPlayer-&gt;On();
		pLamp-&gt;Off();
		pMicrophone-&gt;On();
	&#125;
	virtual void Off()&#123;
		pTelevision-&gt;Off();
		pAudio-&gt;Off();
		pDVDPlayer-&gt;Off();
		pLamp-&gt;On();
		pMicrophone-&gt;Off();
	&#125;
private:
	Television* pTelevision;
	Audio* pAudio;
	DVDPlayer* pDVDPlayer;
	Lamp* pLamp;
	Microphone* pMicrophone;
&#125;;

&#x2F;&#x2F;测试游戏模式和KTV模式
void test01()&#123;
	
	AbstractFacede* facede &#x3D; NULL;
	facede &#x3D; new GameMode;
	facede-&gt;On(); &#x2F;&#x2F;启动游戏模式
	delete facede;

	cout &lt;&lt; &quot;--------------------------&quot; &lt;&lt; endl;

	facede &#x3D; new KTVMode;
	facede-&gt;On(); &#x2F;&#x2F;启动KTV模式
	delete facede;
&#125;

int main()&#123;
	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="4-3-3外观模式的优缺点"><a href="#4-3-3外观模式的优缺点" class="headerlink" title="4.3.3外观模式的优缺点"></a><strong>4.3.3外观模式的优缺点</strong></h4><p><strong>优点：</strong></p>
<p>  (1)它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少。  </p>
<p>(2)它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可。  </p>
<p>(3)一个子系统的修改对其他子系统没有任何影响。</p>
<p><strong>缺点：</strong></p>
<p>  (1)不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性。  </p>
<p>(2)如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。</p>
<h4 id="4-3-4适用场景"><a href="#4-3-4适用场景" class="headerlink" title="4.3.4适用场景"></a><strong>4.3.4适用场景</strong></h4><p>(1) 复杂系统需要简单入口使用。</p>
<p>(2) 客户端程序与多个子系统之间存在很大的依赖性。</p>
<p>(3) 在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</p>
<h3 id="4-4适配器模式"><a href="#4-4适配器模式" class="headerlink" title="4.4适配器模式"></a><strong>4.4适配器模式</strong></h3><p><img src="http://qiniu.orangew.cn/img/wpsB17F.tmp.jpg" alt="img"><img src="E:\Computer\myblog\hexo\source_posts\设计模式讲义\wpsB180.tmp.jpg" alt="img"><img src="E:\Computer\myblog\hexo\source_posts\设计模式讲义\wpsB181.tmp.jpg" alt="img"> </p>
<ul>
<li>​     5V     &lt;————&gt;     适配器       &lt;————&gt;     220V</li>
<li>将一个类的接口转换成客户希望的另外一个接口。使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</li>
</ul>
<h4 id="4-4-1适配器模式中的角色和职责"><a href="#4-4-1适配器模式中的角色和职责" class="headerlink" title="4.4.1适配器模式中的角色和职责"></a><strong>4.4.1适配器模式中的角色和职责</strong></h4><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="http://qiniu.orangew.cn/img/wpsB191.tmp.png" alt="img"></td>
</tr>
</tbody></table>
<ul>
<li> Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。</li>
</ul>
<ul>
<li>Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。</li>
</ul>
<ul>
<li>Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</li>
</ul>
<ul>
<li>根据对象适配器模式结构图，在对象适配器中，客户端需要调用request()方法，而适配者类Adaptee没有该方法，但是它所提供的specificRequest()方法却是客户端所需要的。为了使客户端能够使用适配者类，需要提供一个包装类Adapter，即适配器类。这个包装类包装了一个适配者的实例，从而将客户端与适配者衔接起来，在适配器的request()方法中调用适配者specificRequest()方法。因为适配器类与适配者类是关联关系（也可称之为委派关系），所以这种适配器模式称为对象适配器模式。</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wpsB192.tmp.jpg" alt="img"></p>
<h4 id="4-4-2适配器模式的案例"><a href="#4-4-2适配器模式的案例" class="headerlink" title="4.4.2适配器模式的案例"></a><strong>4.4.2适配器模式的案例</strong></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include&lt;list&gt;
using namespace std;

&#x2F;&#x2F;A需要治疗感冒
class PersonA&#123;
public:
	void treatGanmao()&#123;
		cout &lt;&lt; &quot;A需要治疗感冒!&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;B需要治疗头疼
class PersonB&#123;
public:
	void treatTouteng()&#123;
		cout &lt;&lt; &quot;B需要治疗头疼!&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;C需要治疗痔疮
class PersonC&#123;
public:
	void treatZhichuang()&#123;
		cout &lt;&lt; &quot;C需要治疗痔疮!&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;目标接口
class Target&#123;
public:
	virtual void treat() &#x3D; 0;
&#125;;

&#x2F;&#x2F;将PersonA的treatGanmao接口适配成treat
class AdapterPersonA : public Target&#123;
public:
	AdapterPersonA()&#123;
		pPerson &#x3D; new PersonA;
	&#125;
	virtual void treat()&#123;
		pPerson-&gt;treatGanmao();
	&#125;
private:
	PersonA* pPerson;
&#125;;

&#x2F;&#x2F;将PersonB的treatTouteng接口适配成treat
class AdapterPersonB : public Target&#123;
public:
	AdapterPersonB()&#123;
		pPerson &#x3D; new PersonB;
	&#125;
	virtual void treat()&#123;
		pPerson-&gt;treatTouteng();
	&#125;
private:
	PersonB* pPerson;
&#125;;

&#x2F;&#x2F;将PersonC的treatZhichuang接口适配成treat
class AdapterPersonC : public Target&#123;
public:
	AdapterPersonC()&#123;
		pPerson &#x3D; new PersonC;
	&#125;
	virtual void treat()&#123;
		pPerson-&gt;treatZhichuang();
	&#125;
private:
	PersonC* pPerson;
&#125;;

&#x2F;&#x2F;医生
class Doctor&#123;
public:
	void addPatient(Target* patient)&#123;
		m_list.push_back(patient);
	&#125;
	void startTreat()&#123;
		for (list&lt;Target*&gt;::iterator it &#x3D; m_list.begin(); it !&#x3D; m_list.end();it ++)&#123;
			(*it)-&gt;treat();
		&#125;
	&#125;
private:
	list&lt;Target*&gt; m_list;
&#125;;

&#x2F;&#x2F;测试
void test01()&#123;
	
	&#x2F;&#x2F;创建三个病人
	Target* patient1 &#x3D; new AdapterPersonA;
	Target* patient2 &#x3D; new AdapterPersonB;
	Target* patient3 &#x3D; new AdapterPersonC;

	&#x2F;&#x2F;创建医生
	Doctor* doctor &#x3D; new Doctor;
	doctor-&gt;addPatient(patient1);
	doctor-&gt;addPatient(patient2);
	doctor-&gt;addPatient(patient3);

	&#x2F;&#x2F;医生逐个对病人进行治疗
	doctor-&gt;startTreat();

&#125;

int main()&#123;

	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="4-4-3适配器模式优缺点"><a href="#4-4-3适配器模式优缺点" class="headerlink" title="4.4.3适配器模式优缺点"></a><strong>4.4.3适配器模式优缺点</strong></h4><p><strong>优点：</strong></p>
<p>  (1)将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。 </p>
<p> (2)增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。 </p>
<p> (3)灵活性和扩展性都非常好，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</p>
<p> <strong>缺点:</strong> </p>
<p>  适配器中置换适配者类的某些方法比较麻烦。</p>
<h4 id="4-4-4适应场景"><a href="#4-4-4适应场景" class="headerlink" title="4.4.4适应场景"></a><strong>4.4.4适应场景</strong></h4><p>(1) 系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。</p>
<p>(2) 想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</p>
<h2 id="5-行为型模式"><a href="#5-行为型模式" class="headerlink" title="5.行为型模式"></a><strong>5.行为型模式</strong></h2><ul>
<li>用来对类或对象怎样交互和怎样分配职责进行描述。</li>
</ul>
<h3 id="5-1模板方法模式"><a href="#5-1模板方法模式" class="headerlink" title="5.1模板方法模式"></a><strong>5.1模板方法模式</strong></h3><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="http://qiniu.orangew.cn/img/wpsB1A3.tmp.jpg" alt="img"></td>
</tr>
</tbody></table>
<ul>
<li> 定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</li>
</ul>
<h4 id="5-1-1模板方法模式中的角色和职责"><a href="#5-1-1模板方法模式中的角色和职责" class="headerlink" title="5.1.1模板方法模式中的角色和职责"></a><strong>5.1.1模板方法模式中的角色和职责</strong></h4><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="http://qiniu.orangew.cn/img/wpsB1A4.tmp.png" alt="img"></td>
</tr>
</tbody></table>
<ul>
<li> AbstractClass（抽象类）：在抽象类中定义了一系列基本操作，这些基本操作可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤。同时，在抽象类中实现了一个模板方法(Template Method)，用于定义一个算法的框架，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法。</li>
</ul>
<ul>
<li>ConcreteClass（具体子类）：它是抽象类的子类，用于实现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体基本操作。</li>
</ul>
<h4 id="5-1-2模板方法模式的案例"><a href="#5-1-2模板方法模式的案例" class="headerlink" title="5.1.2模板方法模式的案例"></a><img src="http://qiniu.orangew.cn/img/wpsB1B5.tmp.jpg" alt="img"><strong>5.1.2模板方法模式的案例</strong></h4><h4 id="5-1-3模板方法的优缺点"><a href="#5-1-3模板方法的优缺点" class="headerlink" title="5.1.3模板方法的优缺点"></a><strong>5.1.3模板方法的优缺点</strong></h4><p><strong>优点：</strong></p>
<p>  (1)在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。 </p>
<p> (2)模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用。  </p>
<p>(3)可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。 </p>
<p> (4)在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>  需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象。</li>
</ul>
<h4 id="5-1-4适用场景"><a href="#5-1-4适用场景" class="headerlink" title="5.1.4适用场景"></a><strong>5.1.4适用场景</strong></h4><p>(1)具有统一的操作步骤或操作过程;</p>
<p>(2) 具有不同的操作细节;</p>
<p>(3) 存在多个具有同样操作步骤的应用场景，但某些具体的操作细节却各不相同;</p>
<ul>
<li> 在抽象类中统一操作步骤，并规定好接口；让子类实现接口。这样可以把各个具体的子类和操作步骤解耦合。</li>
</ul>
<h3 id="5-2命令模式"><a href="#5-2命令模式" class="headerlink" title="5.2命令模式"></a><strong>5.2命令模式</strong></h3><ul>
<li>将一个请求封装为一个对象，从而让我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作(Action)模式或事务(Transaction)模式。</li>
</ul>
<ul>
<li>​    命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wpsB1B6.tmp.jpg" alt="img"> </p>
<p><img src="http://qiniu.orangew.cn/img/wpsB1B7.tmp.jpg" alt="img"> </p>
<p><img src="E:\Computer\myblog\hexo\source_posts\设计模式讲义\wpsB1B8.tmp.jpg" alt="img"> </p>
<p>   <strong>亲自找医生看病</strong></p>
<p><img src="http://qiniu.orangew.cn/img/wpsB1B9.tmp.jpg" alt="img">   </p>
<p>​         <strong>填写病单</strong>                   </p>
<p><img src="http://qiniu.orangew.cn/img/wpsB1BA.tmp.jpg" alt="img"><img src="E:\Computer\myblog\hexo\source_posts\设计模式讲义\wpsB1CA.tmp.jpg" alt="img"><img src="E:\Computer\myblog\hexo\source_posts\设计模式讲义\wpsB1CB.tmp.jpg" alt="img"><img src="http://qiniu.orangew.cn/img/wpsB1CC.tmp.jpg" alt="img"> </p>
<p><strong>医生根据病单治病</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
using namespace std;

&#x2F;&#x2F;医生类
class Doctor&#123;
public:
	void TreatEyes()&#123;
		cout &lt;&lt; &quot;医生治疗眼病!&quot; &lt;&lt; endl;
	&#125;
	void TreatHead()&#123;
		cout &lt;&lt; &quot;医生治疗头疼!&quot; &lt;&lt; endl;
	&#125;
	void TreatNose()&#123;
		cout &lt;&lt; &quot;医生治疗鼻子!&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;命令抽象类
class AbstractCommand&#123;
public:
	virtual void Execute() &#x3D; 0;
&#125;;

&#x2F;&#x2F;治疗眼睛指令(命令) 也可理解为病单
class CommandTreatEyes : public AbstractCommand&#123;
public:
	CommandTreatEyes(Doctor* doctor)&#123;
		pDoctor &#x3D; doctor;
	&#125;
	virtual void Execute()&#123;
		pDoctor-&gt;TreatEyes();
	&#125;
private:
	Doctor* pDoctor;
&#125;;

&#x2F;&#x2F;治疗头疼命令
class CommandTreatHead : public AbstractCommand&#123;
public:
	CommandTreatHead(Doctor* doctor)&#123;
		pDoctor &#x3D; doctor;
	&#125;
	virtual void Execute()&#123;
		pDoctor-&gt;TreatHead();
	&#125;
private:
	Doctor* pDoctor;
&#125;;

&#x2F;&#x2F;治疗鼻子命令
class CommandTreatNose : public AbstractCommand&#123;
public:
	CommandTreatNose(Doctor* doctor)&#123;
		pDoctor &#x3D; doctor;
	&#125;
	virtual void Execute()&#123;
		pDoctor-&gt;TreatNose();
	&#125;
private:
	Doctor* pDoctor;
&#125;;

&#x2F;&#x2F;测试
void test01()&#123;
	
	Doctor* doctor &#x3D; new  Doctor;

	&#x2F;&#x2F;创建病单(命令)
	AbstractCommand* commandEyes &#x3D; new CommandTreatEyes(doctor);
	AbstractCommand* commandHead &#x3D; new CommandTreatHead(doctor);
	AbstractCommand* commandNose &#x3D; new CommandTreatNose(doctor);

	commandEyes-&gt;Execute();
	commandHead-&gt;Execute();
	commandNose-&gt;Execute();

&#125;

int main()&#123;

	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>命令模式的本质是对请求进行封装，一个请求对应于一个命令，将发出命令的责任和执行命令的责任分割开。</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wpsB1CD.tmp.jpg" alt="img"><img src="http://qiniu.orangew.cn/img/wpsB1CE.tmp.jpg" alt="img"><img src="http://qiniu.orangew.cn/img/wpsB1CF.tmp.jpg" alt="img">             </p>
<p>   护士统计编写病单</p>
<p>   病情告知护士</p>
<p><img src="E:\Computer\myblog\hexo\source_posts\设计模式讲义\wpsB1D0.tmp.jpg" alt="img"><img src="http://qiniu.orangew.cn/img/wpsB1D1.tmp.jpg" alt="img"><img src="http://qiniu.orangew.cn/img/wpsB1E2.tmp.jpg" alt="img"> </p>
<p><img src="http://qiniu.orangew.cn/img/wpsB1E3.tmp.jpg" alt="img"> </p>
<p>将统计好的病单统一发给医生 </p>
<h4 id="5-2-1命令模式中的角色和职责"><a href="#5-2-1命令模式中的角色和职责" class="headerlink" title="5.2.1命令模式中的角色和职责"></a><strong>5.2.1命令模式中的角色和职责</strong></h4><p><img src="http://qiniu.orangew.cn/img/wpsB1E4.tmp.png" alt="img"></p>
<ul>
<li>Command（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作。</li>
</ul>
<ul>
<li>ConcreteCommand（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。在实现execute()方法时，将调用接收者对象的相关操作(Action)。</li>
</ul>
<ul>
<li>Invoker（调用者）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的execute()方法，从而实现间接调用请求接收者的相关操作。</li>
</ul>
<ul>
<li>Receiver（接收者）：接收者执行与请求相关的操作，它具体实现对请求的业务处理。</li>
</ul>
<h4 id="5-2-2命令模式的案例"><a href="#5-2-2命令模式的案例" class="headerlink" title="5.2.2命令模式的案例"></a><strong>5.2.2命令模式的案例</strong></h4><p><img src="http://qiniu.orangew.cn/img/wpsB1F5.tmp.jpg" alt="img">  </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include&lt;list&gt;
using namespace std;

&#x2F;&#x2F;医生类
class Doctor&#123;
public:
	void TreatEyes()&#123;
		cout &lt;&lt; &quot;医生治疗眼病!&quot; &lt;&lt; endl;
	&#125;
	void TreatHead()&#123;
		cout &lt;&lt; &quot;医生治疗头疼!&quot; &lt;&lt; endl;
	&#125;
	void TreatNose()&#123;
		cout &lt;&lt; &quot;医生治疗鼻子!&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;命令抽象类
class AbstractCommand&#123;
public:
	virtual void Execute() &#x3D; 0;
&#125;;

&#x2F;&#x2F;治疗眼睛指令(命令) 也可理解为病单
class CommandTreatEyes : public AbstractCommand&#123;
public:
	CommandTreatEyes(Doctor* doctor)&#123;
		pDoctor &#x3D; doctor;
	&#125;
	virtual void Execute()&#123;
		pDoctor-&gt;TreatEyes();
	&#125;
private:
	Doctor* pDoctor;
&#125;;

&#x2F;&#x2F;治疗头疼命令
class CommandTreatHead : public AbstractCommand&#123;
public:
	CommandTreatHead(Doctor* doctor)&#123;
		pDoctor &#x3D; doctor;
	&#125;
	virtual void Execute()&#123;
		pDoctor-&gt;TreatHead();
	&#125;
private:
	Doctor* pDoctor;
&#125;;

&#x2F;&#x2F;治疗鼻子命令
class CommandTreatNose : public AbstractCommand&#123;
public:
	CommandTreatNose(Doctor* doctor)&#123;
		pDoctor &#x3D; doctor;
	&#125;
	virtual void Execute()&#123;
		pDoctor-&gt;TreatNose();
	&#125;
private:
	Doctor* pDoctor;
&#125;;

&#x2F;&#x2F;护士类 统一编制病单
class Nurse&#123;
public:
	void addCommand(AbstractCommand* command)&#123;
		m_list.push_back(command);
	&#125;
	&#x2F;&#x2F;护士统一提交病单给医生
	void submitCommands()&#123;
		for (list&lt;AbstractCommand*&gt;::iterator it &#x3D; m_list.begin(); it !&#x3D; m_list.end();it ++)&#123;
			(*it)-&gt;Execute();
		&#125;
	&#125;
	~Nurse()&#123;
		for (list&lt;AbstractCommand*&gt;::iterator it &#x3D; m_list.begin(); it !&#x3D; m_list.end(); it++)&#123;
			if (NULL !&#x3D; *it)&#123;
				delete *it;
			&#125;
		&#125;
	&#125;
private:
	list&lt;AbstractCommand*&gt; m_list;
&#125;;

void test01()&#123;
	
	Doctor* doctor &#x3D; new Doctor; &#x2F;&#x2F;创建医生
	Nurse* nurse &#x3D; new Nurse; &#x2F;&#x2F;创建护士

	AbstractCommand* command &#x3D; NULL;
	command &#x3D; new CommandTreatEyes(doctor);
	nurse-&gt;addCommand(command);
	command &#x3D; new CommandTreatHead(doctor);
	nurse-&gt;addCommand(command);
	command &#x3D; new CommandTreatNose(doctor);
	nurse-&gt;addCommand(command);

	nurse-&gt;submitCommands(); &#x2F;&#x2F;护士统一提交病单给医生

	delete nurse;
	delete doctor;
&#125;

int main()&#123;

	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="5-2-3命令模式练习题"><a href="#5-2-3命令模式练习题" class="headerlink" title="5.2.3命令模式练习题"></a><strong>5.2.3命令模式练习题</strong></h4><ul>
<li>联想路边撸串烧烤场景， 有烤羊肉，烧鸡翅命令，有烤串师傅，和服务员MM。根据命令模式，设计烤串场景。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include&lt;list&gt;
using namespace std;

&#x2F;&#x2F;烤串大师
class SkewerMaster&#123;
public:
	void MakeChickenWings()&#123;
		cout &lt;&lt; &quot;烤鸡翅!&quot; &lt;&lt; endl;
	&#125;
	void MakeMutton()&#123;
		cout &lt;&lt; &quot;烤羊肉!&quot; &lt;&lt; endl;
	&#125;
&#125;;


&#x2F;&#x2F;抽象烤串命令
class AbstractSkewerCommand&#123;
public:
	virtual void Make() &#x3D; 0;
&#125;;

&#x2F;&#x2F;烤鸡翅的命令
class MakeChickenWingsCommand : public AbstractSkewerCommand&#123;
public:
	MakeChickenWingsCommand(SkewerMaster* master)&#123;
		pMaster &#x3D; master;
	&#125;
	virtual void Make()&#123;
		pMaster-&gt;MakeChickenWings();
	&#125;
private:
	SkewerMaster* pMaster;
&#125;;

&#x2F;&#x2F;烤羊肉的命令
class MakeMuttonCommand : public AbstractSkewerCommand&#123;
public:
	MakeMuttonCommand(SkewerMaster* master)&#123;
		pMaster &#x3D; master;
	&#125;
	virtual void Make()&#123;
		pMaster-&gt;MakeMutton();
	&#125;
private:
	SkewerMaster* pMaster;
&#125;;


&#x2F;&#x2F;服务员
class Waiter&#123;
public:
	void addCommand(AbstractSkewerCommand* command)&#123;
		m_list.push_back(command);
	&#125;
	void submitCommand()&#123;
		for (list&lt;AbstractSkewerCommand*&gt;::iterator it &#x3D; m_list.begin(); it !&#x3D; m_list.end(); it ++)&#123;
			(*it)-&gt;Make();
		&#125;
	&#125;
private:
	list&lt;AbstractSkewerCommand*&gt; m_list;
&#125;;

&#x2F;&#x2F;测试
void test01()&#123;
	
	&#x2F;&#x2F;创建烧烤师傅
	SkewerMaster* master &#x3D; new SkewerMaster;
	&#x2F;&#x2F;创建烧烤命令
	AbstractSkewerCommand* command1 &#x3D; new MakeChickenWingsCommand(master);
	AbstractSkewerCommand* command2 &#x3D; new MakeMuttonCommand(master);
	&#x2F;&#x2F;创建服务员
	Waiter* waiter &#x3D; new Waiter;
	waiter-&gt;addCommand(command1);
	waiter-&gt;addCommand(command2);
	&#x2F;&#x2F;服务员批量提交命令
	waiter-&gt;submitCommand();

	delete waiter;
	delete command2;
	delete command1;
	delete master;
&#125;

int main()&#123;

	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>




<h4 id="5-2-4命令模式的优缺点"><a href="#5-2-4命令模式的优缺点" class="headerlink" title="5.2.4命令模式的优缺点"></a><strong>5.2.4命令模式的优缺点</strong></h4><p><strong>优点：</strong></p>
<p>  (1)降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。  </p>
<p>(2)新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求。  </p>
<p>(3)可以比较容易地设计一个命令队列或宏命令（组合命令）。</p>
<p><strong>缺点：</strong></p>
<ul>
<li>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用。</li>
</ul>
<h4 id="5-2-5适用场景"><a href="#5-2-5适用场景" class="headerlink" title="5.2.5适用场景"></a><strong>5.2.5适用场景</strong></h4><p>  (1) 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用。  </p>
<p>(2) 系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期，换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，而无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现。  </p>
<p>(3) 系统需要将一组操作组合在一起形成宏命令。</p>
<h3 id="5-3策略模式"><a href="#5-3策略模式" class="headerlink" title="5.3策略模式"></a><strong>5.3策略模式</strong></h3><ul>
<li>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而独立变化。</li>
</ul>
<h4 id="5-3-1策略模式中的角色和职责"><a href="#5-3-1策略模式中的角色和职责" class="headerlink" title="5.3.1策略模式中的角色和职责"></a><strong>5.3.1策略模式中的角色和职责</strong></h4><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="http://qiniu.orangew.cn/img/wpsB1F6.tmp.png" alt="img"></td>
</tr>
</tbody></table>
<ul>
<li>Context（环境类）：环境类是使用算法的角色，它在解决某个问题（即实现某个方法）时可以采用多种策略。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略。</li>
</ul>
<ul>
<li>Strategy（抽象策略类）：它为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法。</li>
</ul>
<ul>
<li>ConcreteStrategy（具体策略类）：它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理。</li>
</ul>
<h4 id="5-3-2策略模式案例"><a href="#5-3-2策略模式案例" class="headerlink" title="5.3.2策略模式案例"></a><strong>5.3.2策略模式案例</strong></h4><p><img src="http://qiniu.orangew.cn/img/wpsB206.tmp.jpg" alt="img"> </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
using namespace std;

&#x2F;&#x2F;武器策略
class WeaponStrategy&#123;
public:
	virtual void UseWeapon() &#x3D; 0;
&#125;;

&#x2F;&#x2F;匕首策略
class KnifeStrategy : public WeaponStrategy&#123;
public:
	virtual void UseWeapon()&#123;
		cout &lt;&lt; &quot;使用匕首!&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;AK47策略
class AK47Strategy : public WeaponStrategy&#123;
public:
	virtual void UseWeapon()&#123;
		cout &lt;&lt; &quot;使用AK47!&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;* 未使用策略模式的写法 start *&#x2F;

class CharacterUseKnife&#123;
public:
	virtual void UseWeapon()&#123;
		m_knife.UseWeapon();
	&#125;
private:
	KnifeStrategy m_knife;
&#125;;

class CharacterUseAK47&#123;
public:
	virtual void UseWeapon()&#123;
		m_ak47.UseWeapon();
	&#125;
private:
	AK47Strategy m_ak47;
&#125;;

void test01()&#123;

	&#x2F;*
		未使用策略，那么人和武器的耦合度很高
	*&#x2F;
	CharacterUseKnife* chracter1 &#x3D; new CharacterUseKnife;
	chracter1-&gt;UseWeapon();

	CharacterUseAK47* chracter2 &#x3D; new CharacterUseAK47;
	chracter2-&gt;UseWeapon();

&#125;

&#x2F;* 未使用策略模式的写法 end *&#x2F;

&#x2F;* 使用策略模式的写法 start *&#x2F;

class Character&#123;
public:
	&#x2F;&#x2F;设置武器策略
	void setWeaponStrategy(WeaponStrategy* weaponStrategy)&#123;
		pWeaponStrategy &#x3D; weaponStrategy;
	&#125;
	void UseWeapon()&#123;
		pWeaponStrategy-&gt;UseWeapon();
	&#125;
private:
	WeaponStrategy* pWeaponStrategy;
&#125;;

void test02()&#123;
	
	Character* character &#x3D; new Character; &#x2F;&#x2F;创建角色
	WeaponStrategy* strategy &#x3D; NULL; &#x2F;&#x2F;武器策略

	cout &lt;&lt; &quot;---------------使用匕首策略---------------&quot; &lt;&lt; endl;
	strategy &#x3D; new KnifeStrategy; &#x2F;&#x2F;创建匕首策略
	character-&gt;setWeaponStrategy(strategy);  &#x2F;&#x2F;设置武器策略为 匕首策略
	character-&gt;UseWeapon();
	delete strategy;

	cout &lt;&lt; &quot;---------------使用AK47策略---------------&quot; &lt;&lt; endl;
	strategy &#x3D; new AK47Strategy;
	character-&gt;setWeaponStrategy(strategy);
	character-&gt;UseWeapon();
	delete strategy;

	delete character;

&#125;

&#x2F;* 使用策略模式的写法 end *&#x2F;
int main()&#123;

	&#x2F;&#x2F;test01();
	test02();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="5-3-3策略模式练习题"><a href="#5-3-3策略模式练习题" class="headerlink" title="5.3.3策略模式练习题"></a><strong>5.3.3策略模式练习题</strong></h4><ul>
<li>​    商场促销有策略A（0.8折） 策略B（消费满200，返现100），用策略模式模拟场景。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
using namespace std;

&#x2F;&#x2F;抽象策略类
class AbstractStrategy&#123;
public:
	virtual int CaculateMoney(int) &#x3D; 0;
&#125;;

&#x2F;&#x2F;8折策略
class StrategySaleByEight : public AbstractStrategy&#123;
public:
	virtual int CaculateMoney(int money)&#123;
		return money * 0.8;
	&#125;
&#125;;

&#x2F;&#x2F;满200 返现100策略
class StrategySale200Return100 : public AbstractStrategy&#123;
public:
	virtual int CaculateMoney(int money)&#123;
		return money - (money &#x2F; 200) * 100;
	&#125;
&#125;;

&#x2F;&#x2F;超市购物类
class Shopping&#123;
public:
	Shopping()&#123;
		pStrategy &#x3D; NULL;
	&#125;
	void setStrategy(AbstractStrategy* strategy)&#123;
		pStrategy &#x3D; strategy;
	&#125;
	void PayMoney(int money)&#123;
		int realMoney &#x3D; 0;
		if (NULL &#x3D;&#x3D; pStrategy)&#123;
			realMoney &#x3D; money;
		&#125;
		else&#123;
			realMoney &#x3D; pStrategy-&gt;CaculateMoney(money);
		&#125;
		cout &lt;&lt; &quot;商品折前价格:&quot; &lt;&lt; money &lt;&lt; &quot;,折后价格:&quot; &lt;&lt; realMoney &lt;&lt; &quot;元!&quot; &lt;&lt; endl;
	&#125;
private:
	AbstractStrategy* pStrategy;
&#125;;

void test01()&#123;
	
	Shopping* shopping &#x3D; new Shopping;
	AbstractStrategy* strategy &#x3D; NULL;
	cout &lt;&lt; &quot;逢活动 八折优惠&quot; &lt;&lt; endl;
	strategy &#x3D; new StrategySaleByEight;
	shopping-&gt;setStrategy(strategy); &#x2F;&#x2F;设置商场活动为8折优惠
	shopping-&gt;PayMoney(600);

	delete strategy;

	cout &lt;&lt; &quot;再次逢活动 满200 返现100&quot; &lt;&lt; endl;
	strategy &#x3D; new StrategySale200Return100;
	shopping-&gt;setStrategy(strategy);
	shopping-&gt;PayMoney(900);

	delete strategy;
	delete shopping;

&#125;

int main()&#123;

	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>




<h4 id="5-3-4策略模式的优缺点"><a href="#5-3-4策略模式的优缺点" class="headerlink" title="5.3.4策略模式的优缺点"></a><strong>5.3.4策略模式的优缺点</strong></h4><p><strong>优点：</strong></p>
<p>  (1)策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。  </p>
<p>(2)使用策略模式可以避免多重条件选择语句。多重条件选择语句不易维护，它把采取哪一种算法或行为的逻辑与算法或行为本身的实现逻辑混合在一起，将它们全部硬编码(Hard Coding)在一个庞大的多重条件选择语句中，比直接继承环境类的办法还要原始和落后。  </p>
<p>(3)策略模式提供了一种算法的复用机制。由于将算法单独提取出来封装在策略类中，因此不同的环境类可以方便地复用这些策略类。 </p>
<p><strong>缺点：</strong></p>
<p>  (1)客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。  </p>
<p>(2)策略模式将造成系统产生很多具体策略类，任何细小的变化都将导致系统要增加一个新的具体策略类。</p>
<h4 id="5-3-5适用场景"><a href="#5-3-5适用场景" class="headerlink" title="5.3.5适用场景"></a><strong>5.3.5适用场景</strong></h4><ul>
<li>​    准备一组算法，并将每一个算法封装起来，使得它们可以互换。</li>
</ul>
<h3 id="5-4观察者模式"><a href="#5-4观察者模式" class="headerlink" title="5.4观察者模式"></a><img src="http://qiniu.orangew.cn/img/wpsB217.tmp.jpg" alt="img"><strong>5.4观察者模式</strong></h3><ul>
<li> 随着交通信号灯的变化，汽车的行为也将随之而变化，一盏交通信号灯可以指挥多辆汽车。</li>
<li>观察者模式是用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应作出反应。在观察者模式中，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间可以没有任何相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。</li>
</ul>
<h4 id="5-4-1观察者模式中的角色和职责"><a href="#5-4-1观察者模式中的角色和职责" class="headerlink" title="5.4.1观察者模式中的角色和职责"></a><strong>5.4.1观察者模式中的角色和职责</strong></h4><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="http://qiniu.orangew.cn/img/wpsB218.tmp.png" alt="img"></td>
</tr>
</tbody></table>
<ul>
<li>Subject（被观察者或目标，抽象主题）：被观察的对象。当需要被观察的状态发生变化时，需要通知队列中所有观察者对象。Subject需要维持（添加，删除，通知）一个观察者对象的队列列表。</li>
</ul>
<ul>
<li>ConcreteSubject（具体被观察者或目标，具体主题）：被观察者的具体实现。包含一些基本的属性状态及其他操作。</li>
</ul>
<ul>
<li>Observer（观察者）：接口或抽象类。当Subject的状态发生变化时，Observer对象将通过一个callback函数得到通知。</li>
</ul>
<ul>
<li>ConcreteObserver（具体观察者）：观察者的具体实现。得到通知后将完成一些具体的业务逻辑处理。</li>
</ul>
<h4 id="5-4-2观察者模式案例"><a href="#5-4-2观察者模式案例" class="headerlink" title="5.4.2观察者模式案例"></a><strong>5.4.2观察者模式案例</strong></h4><p><img src="http://qiniu.orangew.cn/img/wpsB228.tmp.jpg" alt="img"></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td><img src="http://qiniu.orangew.cn/img/wpsB239.tmp.png" alt="img"></td>
</tr>
</tbody></table>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include&lt;list&gt;
using namespace std;

&#x2F;&#x2F;抽象观察者
class AbstractObserver&#123;
public:
	virtual void Update() &#x3D; 0;
&#125;;

&#x2F;&#x2F;说悄悄话的同学
class WhisperStudent : public AbstractObserver&#123;
public:
	virtual void Update()&#123;
		cout &lt;&lt; &quot;停止说悄悄话，专心学习...&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;抄作业的同学
class CopyHomeWorkdStudent : public AbstractObserver&#123;
public:
	virtual void Update()&#123;
		cout &lt;&lt; &quot;停止抄作业，专心自己写作业...&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;玩手机的同学
class PlayTelephoneStudent : public AbstractObserver&#123;
public:
	virtual void Update()&#123;
		cout &lt;&lt; &quot;停止玩手机，专心看书...&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;抽象通知者 也就是被不好好学习的同学观察的目标
class AbstractInformer&#123;
public:
	virtual void addObserver(AbstractObserver*) &#x3D; 0; &#x2F;&#x2F;增加观察者
	virtual void deleteObserver(AbstractObserver*) &#x3D; 0; &#x2F;&#x2F;删除观察者
	virtual void Notify() &#x3D; 0; &#x2F;&#x2F;有情况通知所有观察者
&#125;;

&#x2F;&#x2F;具体通知者 也就是被观察的目标 班长
class MonitorClass : public AbstractInformer&#123;
public:
	virtual void addObserver(AbstractObserver* observer)&#123;
		m_list.push_back(observer);
	&#125;
	virtual void deleteObserver(AbstractObserver* observer)&#123;
		m_list.remove(observer);
	&#125;
	virtual void Notify()&#123;
		for (list&lt;AbstractObserver*&gt;::iterator it &#x3D; m_list.begin(); it !&#x3D; m_list.end(); it ++)&#123;
			(*it)-&gt;Update();
		&#125;
	&#125;
private:
	list&lt;AbstractObserver*&gt; m_list;
&#125;;

void test01()&#123;
	
	&#x2F;&#x2F;三名观察者
	AbstractObserver* stu1 &#x3D; new WhisperStudent;
	AbstractObserver* stu2 &#x3D; new CopyHomeWorkdStudent;
	AbstractObserver* stu3 &#x3D; new PlayTelephoneStudent;

	&#x2F;&#x2F;创建班长
	AbstractInformer* monitor &#x3D; new MonitorClass;

	&#x2F;&#x2F;告诉班长，老师来了那些人需要通知
	monitor-&gt;addObserver(stu1);
	monitor-&gt;addObserver(stu2);
	monitor-&gt;addObserver(stu3);

	cout &lt;&lt; &quot;发生特殊情况... 老师来了... 快通知哪些学生...&quot; &lt;&lt; endl;
	monitor-&gt;Notify();

	cout &lt;&lt; &quot;平日里说悄悄话的这个同学和班长关系不好，班长不想通知他&quot; &lt;&lt; endl;
	monitor-&gt;deleteObserver(stu1);

	cout &lt;&lt; &quot;老师又来了... 班长通知其他人 但是这次不通知说悄悄话的那个同学&quot; &lt;&lt; endl;
	monitor-&gt;Notify();

	&#x2F;&#x2F;释放资源
	delete monitor;
	delete stu3;
	delete stu2;
	delete stu1;
&#125;

int main()&#123;

	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="5-4-3观察者模式练习题"><a href="#5-4-3观察者模式练习题" class="headerlink" title="5.4.3观察者模式练习题"></a><strong>5.4.3观察者模式练习题</strong></h4><ul>
<li>​    江湖中有多个帮派，还有一名无人不知，无事不晓的百晓生。当江湖中发生武林打斗事件，百晓生作为天生的大嘴巴会广播武林消息，每个帮派的门第对于事件的处理方式均不同，同帮派被欺负，要报仇，同帮派欺负别人，叫好。用观察者模式模拟场景。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include&lt;string&gt;
#include&lt;list&gt;
using namespace std;

class Infomation;

&#x2F;&#x2F;抽象观察者
class AbstractGang&#123;
public:
	virtual void Update(Infomation*) &#x3D; 0;
	virtual string GetGangName() &#x3D; 0;
&#125;;

&#x2F;&#x2F;江湖消息
class Infomation&#123;
public:
	Infomation(AbstractGang* beat, AbstractGang* beaten)&#123;
		this-&gt;Beat &#x3D; beat;
		this-&gt;Beaten &#x3D; beaten;
	&#125;
	AbstractGang* Beat; &#x2F;&#x2F;打人的帮派
	AbstractGang* Beaten; &#x2F;&#x2F;被打的帮派
&#125;;

&#x2F;&#x2F;华山派坐等百晓生的广播
class HuashanGang : public AbstractGang&#123;
public:
	HuashanGang()&#123;
		m_GangName &#x3D; &quot;华山派&quot;;
	&#125;
	virtual void Update(Infomation* info)&#123;
		if (info-&gt;Beat &#x3D;&#x3D; this &amp;&amp; info-&gt;Beaten !&#x3D; this)&#123;
			cout &lt;&lt; &quot;打死&quot; &lt;&lt; info-&gt;Beaten-&gt;GetGangName() &lt;&lt; &quot;,&quot; &lt;&lt; this-&gt;GetGangName() &lt;&lt; &quot;最厉害!&quot; &lt;&lt; endl;
		&#125;
		else if (info-&gt;Beat !&#x3D; this &amp;&amp; info-&gt;Beaten !&#x3D; this)&#123;
			cout &lt;&lt; this-&gt;GetGangName()  &lt;&lt;&quot;坐看&quot; &lt;&lt; info-&gt;Beat-&gt;GetGangName() &lt;&lt; &quot;和&quot; &lt;&lt; info-&gt;Beaten-&gt;GetGangName() &lt;&lt; &quot;干架!&quot; &lt;&lt; endl;
		&#125;
		else if(info-&gt;Beat !&#x3D; this &amp;&amp; info-&gt;Beaten &#x3D;&#x3D; this)&#123;
			cout &lt;&lt; info-&gt;Beat-&gt;GetGangName() &lt;&lt; &quot;干我们&quot; &lt;&lt; this-&gt;GetGangName() &lt;&lt; &quot;，我们要报仇!&quot; &lt;&lt; endl;
		&#125;
	&#125;
	virtual string GetGangName()&#123;
		return m_GangName;
	&#125;
private:
	string m_GangName;
&#125;;

&#x2F;&#x2F;昆仑派坐等百晓生的广播
class KunlunGang : public AbstractGang&#123;
public:
	KunlunGang()&#123;
		m_GangName &#x3D; &quot;昆仑派&quot;;
	&#125;
	virtual void Update(Infomation* info)&#123;
		if (info-&gt;Beat &#x3D;&#x3D; this &amp;&amp; info-&gt;Beaten !&#x3D; this)&#123;
			cout &lt;&lt; &quot;打死&quot; &lt;&lt; info-&gt;Beaten-&gt;GetGangName() &lt;&lt; &quot;,&quot; &lt;&lt; this-&gt;GetGangName() &lt;&lt; &quot;最厉害!&quot; &lt;&lt; endl;
		&#125;
		else if (info-&gt;Beat !&#x3D; this &amp;&amp; info-&gt;Beaten !&#x3D; this)&#123;
			cout &lt;&lt; this-&gt;GetGangName() &lt;&lt; &quot;坐看&quot; &lt;&lt; info-&gt;Beat-&gt;GetGangName() &lt;&lt; &quot;和&quot; &lt;&lt; info-&gt;Beaten-&gt;GetGangName() &lt;&lt; &quot;干架!&quot; &lt;&lt; endl;
		&#125;
		else if (info-&gt;Beat !&#x3D; this &amp;&amp; info-&gt;Beaten &#x3D;&#x3D; this)&#123;
			cout &lt;&lt; info-&gt;Beat-&gt;GetGangName() &lt;&lt; &quot;干我们&quot; &lt;&lt; this-&gt;GetGangName() &lt;&lt; &quot;，我们要报仇!&quot; &lt;&lt; endl;
		&#125;
	&#125;
	virtual string GetGangName()&#123;
		return m_GangName;
	&#125;
private:
	string m_GangName;
&#125;;

&#x2F;&#x2F;武当派坐等百晓生的广播
class WudangGang : public AbstractGang&#123;
public:
	WudangGang()&#123;
		m_GangName &#x3D; &quot;武当派&quot;;
	&#125;
	virtual void Update(Infomation* info)&#123;
		if (info-&gt;Beat &#x3D;&#x3D; this &amp;&amp; info-&gt;Beaten !&#x3D; this)&#123;
			cout &lt;&lt; &quot;打死&quot; &lt;&lt; info-&gt;Beaten-&gt;GetGangName() &lt;&lt; &quot;,&quot; &lt;&lt; this-&gt;GetGangName() &lt;&lt; &quot;最厉害!&quot; &lt;&lt; endl;
		&#125;
		else if (info-&gt;Beat !&#x3D; this &amp;&amp; info-&gt;Beaten !&#x3D; this)&#123;
			cout &lt;&lt; this-&gt;GetGangName() &lt;&lt; &quot;坐看&quot; &lt;&lt; info-&gt;Beat-&gt;GetGangName() &lt;&lt; &quot;和&quot; &lt;&lt; info-&gt;Beaten-&gt;GetGangName() &lt;&lt; &quot;干架!&quot; &lt;&lt; endl;
		&#125;
		else if (info-&gt;Beat !&#x3D; this &amp;&amp; info-&gt;Beaten &#x3D;&#x3D; this)&#123;
			cout &lt;&lt; info-&gt;Beat-&gt;GetGangName() &lt;&lt; &quot;干我们&quot; &lt;&lt; this-&gt;GetGangName() &lt;&lt; &quot;，我们要报仇!&quot; &lt;&lt; endl;
		&#125;
	&#125;
	virtual string GetGangName()&#123;
		return m_GangName;
	&#125;
private:
	string m_GangName;
&#125;;

&#x2F;&#x2F;百晓生 - 大嘴巴子
class Baixiaosheng&#123;
public:
	void addGang(AbstractGang* gang)&#123;
		m_list.push_back(gang);
	&#125;
	void setInfomation(Infomation* info)&#123;
		pInfo &#x3D; info;
	&#125;
	void Notify()&#123;
		for (list&lt;AbstractGang*&gt;::iterator it &#x3D; m_list.begin(); it !&#x3D; m_list.end(); it ++)&#123;
			(*it)-&gt;Update(pInfo);
		&#125;
	&#125;
private:
	list&lt;AbstractGang*&gt; m_list;
	Infomation* pInfo;
&#125;;

void test01()&#123;
	
	AbstractGang* wudang &#x3D; new WudangGang; &#x2F;&#x2F;武当派
	AbstractGang* kunlun &#x3D; new KunlunGang; &#x2F;&#x2F;昆仑派
	AbstractGang* huashan &#x3D; new HuashanGang; &#x2F;&#x2F;华山派

	Baixiaosheng* baixiaosheng &#x3D; new Baixiaosheng; &#x2F;&#x2F;百晓生 大嘴巴子
	baixiaosheng-&gt;addGang(wudang);
	baixiaosheng-&gt;addGang(kunlun);
	baixiaosheng-&gt;addGang(huashan);

	Infomation* pInfo &#x3D; new Infomation(wudang, huashan); &#x2F;&#x2F;创建江湖消息  武当打华山
	baixiaosheng-&gt;setInfomation(pInfo); &#x2F;&#x2F;告诉百晓生武当打华山了

	&#x2F;&#x2F;大嘴巴开始向各大门派发消息了
	baixiaosheng-&gt;Notify();

&#125;

int main()&#123;

	test01();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>




<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include&lt;list&gt;
using namespace std;

&#x2F;&#x2F;抽象的英雄 抽象的观察者
class AbstractHero&#123;
public:
	virtual void Update() &#x3D; 0;
&#125;;


&#x2F;&#x2F;具体英雄  具体观察者
class HeroA :public AbstractHero&#123;
public:
	HeroA()&#123;
		cout &lt;&lt; &quot;英雄A正在撸BOSS ...&quot; &lt;&lt; endl;
	&#125;
	virtual void Update()&#123;
		cout &lt;&lt; &quot;英雄A停止撸,待机状态...&quot; &lt;&lt; endl;
	&#125;
&#125;;

class HeroB :public AbstractHero&#123;
public:
	HeroB()&#123;
		cout &lt;&lt; &quot;英雄B正在撸BOSS ...&quot; &lt;&lt; endl;
	&#125;
	virtual void Update()&#123;
		cout &lt;&lt; &quot;英雄B停止撸,待机状态...&quot; &lt;&lt; endl;
	&#125;
&#125;;

class HeroC :public AbstractHero&#123;
public:
	HeroC()&#123;
		cout &lt;&lt; &quot;英雄C正在撸BOSS ...&quot; &lt;&lt; endl;
	&#125;
	virtual void Update()&#123;
		cout &lt;&lt; &quot;英雄C停止撸,待机状态...&quot; &lt;&lt; endl;
	&#125;
&#125;;

class HeroD :public AbstractHero&#123;
public:
	HeroD()&#123;
		cout &lt;&lt; &quot;英雄D正在撸BOSS ...&quot; &lt;&lt; endl;
	&#125;
	virtual void Update()&#123;
		cout &lt;&lt; &quot;英雄D停止撸,待机状态...&quot; &lt;&lt; endl;
	&#125;
&#125;;

class HeroE :public AbstractHero&#123;
public:
	HeroE()&#123;
		cout &lt;&lt; &quot;英雄E正在撸BOSS ...&quot; &lt;&lt; endl;
	&#125;
	virtual void Update()&#123;
		cout &lt;&lt; &quot;英雄E停止撸,待机状态...&quot; &lt;&lt; endl;
	&#125;
&#125;;


&#x2F;&#x2F;观察目标抽象
class AbstractBoss&#123;
public:
	&#x2F;&#x2F;添加观察者
	virtual void addHero(AbstractHero* hero) &#x3D; 0;
	&#x2F;&#x2F;删除观察者
	virtual void deleteHero(AbstractHero* hero) &#x3D; 0;
	&#x2F;&#x2F;通知所有观察者
	virtual void notify() &#x3D; 0; 
&#125;;


&#x2F;&#x2F;具体的观察者 BOSSA
class BOSSA : public AbstractBoss&#123;
public:
	virtual void addHero(AbstractHero* hero)&#123;
		pHeroList.push_back(hero);
	&#125;
	&#x2F;&#x2F;删除观察者
	virtual void deleteHero(AbstractHero* hero)&#123;
		pHeroList.remove(hero);
	&#125;
	&#x2F;&#x2F;通知所有观察者
	virtual void notify()&#123;
		for (list&lt;AbstractHero*&gt;::iterator it &#x3D; pHeroList.begin(); it !&#x3D; pHeroList.end();it ++)&#123;
			(*it)-&gt;Update();
		&#125;
	&#125;
public:
	list&lt;AbstractHero*&gt; pHeroList;
&#125;;



void test01()&#123;
	

	&#x2F;&#x2F;创建观察者
	AbstractHero* heroA &#x3D; new HeroA;
	AbstractHero* heroB &#x3D; new HeroB;
	AbstractHero* heroC &#x3D; new HeroC;
	AbstractHero* heroD &#x3D; new HeroD;
	AbstractHero* heroE &#x3D; new HeroE;

	&#x2F;&#x2F;创建观察目标
	AbstractBoss* bossA &#x3D; new BOSSA;
	bossA-&gt;addHero(heroA);
	bossA-&gt;addHero(heroB);
	bossA-&gt;addHero(heroC);
	bossA-&gt;addHero(heroD);
	bossA-&gt;addHero(heroE);


	cout &lt;&lt; &quot;heroC阵亡...&quot; &lt;&lt; endl;
	bossA-&gt;deleteHero(heroC);

	cout &lt;&lt; &quot;Boss死了...通知其他英雄停止攻击，抢装备...&quot; &lt;&lt; endl;
	bossA-&gt;notify();

&#125;


int main(void)&#123;
	test01();
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="5-4-3观察者模式的优缺点"><a href="#5-4-3观察者模式的优缺点" class="headerlink" title="5.4.3观察者模式的优缺点"></a><strong>5.4.3观察者模式的优缺点</strong></h4><p><strong>优点：</strong></p>
<p>  (1)观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。 </p>
<p> (2)观察者模式在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。 </p>
<p> (3)观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。  </p>
<p>(4)观察者模式满足“开闭原则”的要求，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。</p>
<p><strong>缺点：</strong></p>
<p>  (1)如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间。  </p>
<p>(2)观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p>
<h4 id="5-4-4适用场景"><a href="#5-4-4适用场景" class="headerlink" title="5.4.4适用场景"></a><strong>5.4.4适用场景</strong></h4><p>  (1)一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用。  </p>
<p>(2)一个对象的改变将导致一个或多个其他对象也发生改变，而并不知道具体有多少对象将发生改变，也不知道这些对象是谁。  </p>
<p>(3)需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</p>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/c/" rel="tag"><i class="fa fa-tag"></i> c++</a>
              <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" rel="tag"><i class="fa fa-tag"></i> 设计模式</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/06/C-STL/" rel="prev" title="C++STL">
      <i class="fa fa-chevron-left"></i> C++STL
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/07/07/UML/" rel="next" title="UML">
      UML <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">1.设计模式概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5"><span class="nav-number">1.1.</span> <span class="nav-text">1.1设计模式从何而来</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%88%E4%BB%8E%E4%BD%95%E8%80%8C%E6%9D%A5"><span class="nav-number">1.2.</span> <span class="nav-text">1.2软件设计模式又从何而来</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%A7%8D%E7%B1%BB"><span class="nav-number">1.3.</span> <span class="nav-text">1.3软件设计模式的种类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%EF%BC%9F"><span class="nav-number">1.4.</span> <span class="nav-text">1.4软件设计模式有什么用？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5%E5%A6%82%E4%BD%95%E5%AD%A6%E5%A5%BD%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.5.</span> <span class="nav-text">1.5如何学好设计模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E8%A7%88%E8%A1%A8"><span class="nav-number">1.6.</span> <span class="nav-text">1.6设计模式总览表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="nav-number">2.</span> <span class="nav-text">2.面向对象设计原则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%9B%E8%A1%A8"><span class="nav-number">2.1.</span> <span class="nav-text">2.1面向对象设计原创表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99%E6%A1%88%E4%BE%8B"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1开闭原则案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%E6%A1%88%E4%BE%8B"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.1.2迪米特法则案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-3%E5%90%88%E6%88%90%E5%A4%8D%E7%94%A8%E5%8E%9F%E5%88%99%E6%A1%88%E4%BE%8B"><span class="nav-number">2.1.3.</span> <span class="nav-text">2.1.3合成复用原则案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-4%E4%BE%9D%E8%B5%96%E5%80%92%E8%BD%AC%E5%8E%9F%E5%88%99%E6%A1%88%E4%BE%8B"><span class="nav-number">2.1.4.</span> <span class="nav-text">2.1.4依赖倒转原则案例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.</span> <span class="nav-text">3.创建型模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.1.</span> <span class="nav-text">3.1简单工厂模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E8%A7%92%E8%89%B2%E5%92%8C%E8%81%8C%E8%B4%A3"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.1.1模式中的角色和职责</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E6%A1%88%E4%BE%8B"><span class="nav-number">3.1.2.</span> <span class="nav-text">3.1.2简单工厂模式案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">3.1.3.</span> <span class="nav-text">3.1.3简单工厂模式的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-4%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.1.4.</span> <span class="nav-text">3.1.4适用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.2.</span> <span class="nav-text">3.2工厂方法模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E8%A7%92%E8%89%B2%E4%B8%8E%E8%81%8C%E8%B4%A3"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.2.1 工厂方法模式中的角色与职责</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E6%A1%88%E4%BE%8B"><span class="nav-number">3.2.2.</span> <span class="nav-text">3.2.2工厂方法模式案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">3.2.3.</span> <span class="nav-text">3.1.3工厂方法模式的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-4%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="nav-number">3.2.4.</span> <span class="nav-text">3.1.4适用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.3.</span> <span class="nav-text">3.3抽象工厂模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E8%A7%92%E8%89%B2%E5%92%8C%E8%81%8C%E8%B4%A3"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.3.1模式中的角色和职责</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E6%A1%88%E4%BE%8B"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.3.2抽象工厂模式案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">3.3.3.</span> <span class="nav-text">3.3.3抽象工厂模式的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-4%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.3.4.</span> <span class="nav-text">3.3.4适用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-5%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="nav-number">3.3.5.</span> <span class="nav-text">3.3.5抽象工厂模式练习题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.4.</span> <span class="nav-text">3.4单例模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E8%A7%92%E8%89%B2%E5%92%8C%E8%81%8C%E8%B4%A3"><span class="nav-number">3.4.1.</span> <span class="nav-text">3.4.1单例模式中的角色和职责</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2%E5%8D%95%E4%BE%8B%E7%A2%B0%E5%88%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">3.4.2.</span> <span class="nav-text">3.4.2单例碰到多线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-3-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">3.4.3.</span> <span class="nav-text">3.4.3 单例模式的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-4%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.4.4.</span> <span class="nav-text">3.4.4适用场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.</span> <span class="nav-text">4.结构型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.1.</span> <span class="nav-text">4.1代理模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E8%A7%92%E8%89%B2%E5%92%8C%E8%81%8C%E8%B4%A3"><span class="nav-number">4.1.1.</span> <span class="nav-text">4.1.1模式中的角色和职责</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A1%88%E4%BE%8B"><span class="nav-number">4.1.2.</span> <span class="nav-text">4.1.2代理模式的案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">4.1.3.</span> <span class="nav-text">4.1.3代理模式的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-4%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">4.1.4.</span> <span class="nav-text">4.1.4适用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-5-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="nav-number">4.1.5.</span> <span class="nav-text">4.1.5 代理模式练习题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.2.</span> <span class="nav-text">4.2装饰模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E8%A7%92%E8%89%B2%E5%92%8C%E8%81%8C%E8%B4%A3"><span class="nav-number">4.2.1.</span> <span class="nav-text">4.2.1装饰模式中的角色和职责</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E6%A1%88%E4%BE%8B"><span class="nav-number">4.2.2.</span> <span class="nav-text">4.2.2装饰模式案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">4.2.3.</span> <span class="nav-text">4.2.3装饰模式的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-4-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">4.2.4.</span> <span class="nav-text">4.2.4 适用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.3.</span> <span class="nav-text">4.3外观模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E4%B8%AD%E8%A7%92%E8%89%B2%E5%92%8C%E8%81%8C%E8%B4%A3"><span class="nav-number">4.3.1.</span> <span class="nav-text">4.3.1外观模式中角色和职责</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E6%A1%88%E4%BE%8B"><span class="nav-number">4.3.2.</span> <span class="nav-text">4.3.2外观模式案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">4.3.3.</span> <span class="nav-text">4.3.3外观模式的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-4%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">4.3.4.</span> <span class="nav-text">4.3.4适用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">4.4.</span> <span class="nav-text">4.4适配器模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E8%A7%92%E8%89%B2%E5%92%8C%E8%81%8C%E8%B4%A3"><span class="nav-number">4.4.1.</span> <span class="nav-text">4.4.1适配器模式中的角色和职责</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A1%88%E4%BE%8B"><span class="nav-number">4.4.2.</span> <span class="nav-text">4.4.2适配器模式的案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-3%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">4.4.3.</span> <span class="nav-text">4.4.3适配器模式优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-4%E9%80%82%E5%BA%94%E5%9C%BA%E6%99%AF"><span class="nav-number">4.4.4.</span> <span class="nav-text">4.4.4适应场景</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.</span> <span class="nav-text">5.行为型模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.1.</span> <span class="nav-text">5.1模板方法模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-1%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E8%A7%92%E8%89%B2%E5%92%8C%E8%81%8C%E8%B4%A3"><span class="nav-number">5.1.1.</span> <span class="nav-text">5.1.1模板方法模式中的角色和职责</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-2%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A1%88%E4%BE%8B"><span class="nav-number">5.1.2.</span> <span class="nav-text">5.1.2模板方法模式的案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-3%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">5.1.3.</span> <span class="nav-text">5.1.3模板方法的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-4%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">5.1.4.</span> <span class="nav-text">5.1.4适用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.2.</span> <span class="nav-text">5.2命令模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E8%A7%92%E8%89%B2%E5%92%8C%E8%81%8C%E8%B4%A3"><span class="nav-number">5.2.1.</span> <span class="nav-text">5.2.1命令模式中的角色和职责</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%A1%88%E4%BE%8B"><span class="nav-number">5.2.2.</span> <span class="nav-text">5.2.2命令模式的案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-3%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="nav-number">5.2.3.</span> <span class="nav-text">5.2.3命令模式练习题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-4%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">5.2.4.</span> <span class="nav-text">5.2.4命令模式的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-5%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">5.2.5.</span> <span class="nav-text">5.2.5适用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.3.</span> <span class="nav-text">5.3策略模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-1%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E8%A7%92%E8%89%B2%E5%92%8C%E8%81%8C%E8%B4%A3"><span class="nav-number">5.3.1.</span> <span class="nav-text">5.3.1策略模式中的角色和职责</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-2%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E6%A1%88%E4%BE%8B"><span class="nav-number">5.3.2.</span> <span class="nav-text">5.3.2策略模式案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-3%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="nav-number">5.3.3.</span> <span class="nav-text">5.3.3策略模式练习题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-4%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">5.3.4.</span> <span class="nav-text">5.3.4策略模式的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-5%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">5.3.5.</span> <span class="nav-text">5.3.5适用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="nav-number">5.4.</span> <span class="nav-text">5.4观察者模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-1%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%9A%84%E8%A7%92%E8%89%B2%E5%92%8C%E8%81%8C%E8%B4%A3"><span class="nav-number">5.4.1.</span> <span class="nav-text">5.4.1观察者模式中的角色和职责</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-2%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E6%A1%88%E4%BE%8B"><span class="nav-number">5.4.2.</span> <span class="nav-text">5.4.2观察者模式案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-3%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="nav-number">5.4.3.</span> <span class="nav-text">5.4.3观察者模式练习题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-3%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">5.4.4.</span> <span class="nav-text">5.4.3观察者模式的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-4%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">5.4.5.</span> <span class="nav-text">5.4.4适用场景</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="OrangeW"
      src="/images/orange.png">
  <p class="site-author-name" itemprop="name">OrangeW</p>
  <div class="site-description" itemprop="description">demo_study record</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


<!-- CloudCalendar -->
<div class="widget-wrap" style="width: 90%;margin-left: auto;margin-right: auto; opacity: 0.97;">
	<div class="widget" id="CloudCalendar"></div>
</div>
      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OrangeW</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">837k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">25:22</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
<!-- calendar widget -->

    <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-calendar/calendar.min.js"></script>
    <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-calendar/languages.min.js"></script>
    <script>
    $(function() {
        $('#CloudCalendar').aCalendar('zh-CN',
            $.extend(
                '', {
                    single:true,
                    root:'/calendar/'
                }
            )
        );
    });
    </script>


</body>
</html>
