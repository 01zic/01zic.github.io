<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/orange.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/orange.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/orange.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"01zic.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="前言">
<meta property="og:type" content="article">
<meta property="og:title" content="C++基础">
<meta property="og:url" content="https://01zic.github.io/2022/07/03/C-%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="orangeWBlog">
<meta property="og:description" content="前言">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://qiniu.orangew.cn/img/%E5%B0%B1%E4%B8%9A%E7%8F%ADC++%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B%E5%A4%A7%E7%BA%B2.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/20220703105256.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/20220703111635.png">
<meta property="og:image" content="e:/Computer/myblog/hexo/source_posts/C-基础/20220703184846-16568453665731.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/20220703213915.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/20220703221844.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/20220704224131.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/20220705150418.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/20220705170753.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/20220705171438.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/20220705172952.png">
<meta property="og:image" content="e:/Computer/myblog/hexo/source_posts/C-基础/20220705191201.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/20220705214630.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/20220705223315.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/20220705225904.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/20220706120736.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/20220706150023.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/20220706150249.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/20220706150604.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/20220706200150.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/20220706200318.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/20220706200943.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/20220706201058.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/20220706212923.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/20220706213015.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/20220706213034.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/20220706213719.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/20220706214222.png">
<meta property="article:published_time" content="2022-07-03T01:05:58.000Z">
<meta property="article:modified_time" content="2022-07-06T14:10:14.389Z">
<meta property="article:author" content="OrangeW">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://qiniu.orangew.cn/img/%E5%B0%B1%E4%B8%9A%E7%8F%ADC++%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B%E5%A4%A7%E7%BA%B2.png">

<link rel="canonical" href="https://01zic.github.io/2022/07/03/C-%E5%9F%BA%E7%A1%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++基础 | orangeWBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">orangeWBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://01zic.github.io/2022/07/03/C-%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/orange.png">
      <meta itemprop="name" content="OrangeW">
      <meta itemprop="description" content="demo_study record">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="orangeWBlog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-03 09:05:58" itemprop="dateCreated datePublished" datetime="2022-07-03T09:05:58+08:00">2022-07-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-06 22:10:14" itemprop="dateModified" datetime="2022-07-06T22:10:14+08:00">2022-07-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>160k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>4:51</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>C++基础课程</li>
<li><img src="http://qiniu.orangew.cn/img/%E5%B0%B1%E4%B8%9A%E7%8F%ADC++%E5%9F%BA%E7%A1%80%E8%AF%BE%E7%A8%8B%E5%A4%A7%E7%BA%B2.png" alt="就业班C++基础课程大纲"></li>
</ul>
<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><ul>
<li>应用领域<ul>
<li>如果项目中,既要求效率又要建模和高度抽像,那就选择c++吧。</li>
</ul>
</li>
<li>系统层软件开发<ul>
<li>C++的语言本身的高效</li>
</ul>
</li>
<li>服务器程序开发<ul>
<li>面向对象，具有较强的抽象和建模能力</li>
</ul>
</li>
<li>游戏，网络，分布式，云计算<ul>
<li>效率和建模</li>
</ul>
</li>
<li>科学计算</li>
</ul>
<h2 id="C-对C语言的加强"><a href="#C-对C语言的加强" class="headerlink" title="C++对C语言的加强"></a>C++对C语言的加强</h2><h3 id="namespace命名空间"><a href="#namespace命名空间" class="headerlink" title="namespace命名空间"></a>namespace命名空间</h3><h4 id="C-命名空间基本常识"><a href="#C-命名空间基本常识" class="headerlink" title="C++命名空间基本常识"></a>C++命名空间基本常识</h4><ul>
<li><p>所谓namespace，是指标识符的各种可见范围。C++标准程序库中的所有标识符都被定义于一个名为std的namespace中。</p>
</li>
<li><p>一 : <iostream>和&lt;iostream.h&gt;格式不一样，前者没有后缀，实际上，在你的编译器include文件夹里面可以看到，二者是两个文件，打开文件就会发现，里面的代码是不一样的。后缀为.h的头文件c++标准已经明确提出不支持了，早些的实现将标准库功能定义在全局空间里，声明在带.h后缀的头文件里，c++标准为了和C区别开，也为了正确使用命名空间，规定头文件不使用后缀.h。因此，</p>
<ol>
<li>当使用&lt;iostream.h&gt;时，相当于在c中调用库函数，使用的是全局命名空间，也就是早期的c++实现;</li>
<li>当使用<iostream>的时候，该头文件没有定义全局命名空间，必须使用namespace std;这样才能正确使用cout。</li>
</ol>
</li>
<li><p>二︰由于namespace的概念，使用C++标准程序库的任何标识符时，可以有三种选择:</p>
<ol>
<li><p>直接指定标识符。例如std:ostream而不是ostream。完整语句如</p>
<ul>
<li><code>std:: cout &lt;&lt; std ::hex &lt;&lt; 3.4 &lt;&lt; std::endl;</code></li>
</ul>
</li>
<li><p>使用using关键字</p>
<ul>
<li><code>using std::cout;using std::endl;using std::cin;</code></li>
<li>以上程序可以写成</li>
<li><code>cout&lt;&lt;std::hex&lt;&lt;3.4&lt;&lt;endl;</code></li>
</ul>
</li>
<li><p>最方便的就是使用using namespace std;例如: using namespace std;这样命名空间std内定义的所有标识符都有效（曝光）。就好像它们被声明为全局变量一样。那么以上语句可以如下写: <code>cout &lt;&lt;hex &lt;&lt; 3.4 &lt;&lt; endl;</code>因为标准库非常的庞大，所以程序员在选择的类的名称或函数名时就很有可能和标准库中的某个名字相同。所以为了避免这种情况所造成的名字冲突，就把标准库中的一切都被放在名字空间std中。但这又会带来了一个新问题。无数原有的C++代码都依赖于使用了多年的伪标准库中的功能，他们都是在全局空间下的。所以就有了&lt;iostream.h&gt;和<iostream>等等这样的头文件，一个是为了兼容以前的C++代码，一个是为了支持新的标准。命名空间std封装的是标准程序库的名称，标准程序库为了和以前的头文件区别，一般不加”.h”</p>
</li>
</ol>
</li>
</ul>
<h4 id="C-命名空间定义以及使用方法"><a href="#C-命名空间定义以及使用方法" class="headerlink" title="C++命名空间定义以及使用方法"></a>C++命名空间定义以及使用方法</h4><ul>
<li>在C++中，名称( name )可以是符号常量、变量、宏、函数、结构、枚举、类和对象等等。为了避免，在大规模程序的设计中，以及在程序员使用各种各样的C++库时，这些标识符的命名发生冲突。</li>
<li>标准C++引入了关键字namespace(命名空间/名字空间/名称空间/名域)，可以更好地控制标识符的作用域。</li>
<li>std是c++标准命名空间，c++标准程序库中的所有标识符都被定义在std中，比如标准库中的类iostream、vector等都定义在该命名空间中，使用时要加上using声明(using namespace std)或using指示(如std::string、std:vector<int>).</li>
</ul>
<blockquote>
<p>C中的命名空间<br>在C语言中只有一个全局作用域<br>C语言中所有的全局标识符共享同一个作用域标识符之间可能发生冲突</p>
<p>C++中的命名空间<br>命名空间将全局作用域分成不同的部分<br>不同命名空间中的标识符可以同名而不会发生冲突命名空间可以相互嵌套<br>全局作用域也叫默认命名空间</p>
</blockquote>
<ul>
<li>C++命名空间的定义</li>
<li><code>namespace name&#123;...&#125;</code></li>
<li>C++命名空间的使用<ul>
<li>使用整个命名空间:using namespace name;</li>
<li>使用命名空间中的变量: using name::variable;</li>
<li>使用默认命名空间中的变量: ::variable</li>
<li>默认情况下可以直接使用默认命名空间中的所有标识符</li>
</ul>
</li>
</ul>
<h4 id="C-命名空间编程实践"><a href="#C-命名空间编程实践" class="headerlink" title="C++命名空间编程实践"></a>C++命名空间编程实践</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;stdio.h&gt;
namespace NameSpaceA&#123;
    int a&#x3D;0;
&#125;
namespace NameSpaceB&#123;
    int a&#x3D;1;
    namespace NameSpaceC&#123;
        struct Teacher&#123;
            char name[10];
            int age;
        &#125;;
    &#125;
&#125;
int main()&#123;
    using namespace NameSpaceA;
    using NameSpaceB::NameSpaceC::Teacher;
    printf(&quot;a&#x3D; %d\n&quot;,a);
    printf(&quot;a&#x3D; %d\n&quot;,NameSpaceB::a);
    NameSpaceB::NameSpaceC::Teacher t2;
    Teacher t1&#x3D;&#123;&quot;aaa&quot;,3&#125;;
    printf(&quot;t1.name&#x3D; %s\n&quot;,t1.name);
    printf(&quot;t1.age&#x3D; %d\n&quot;,t1.age);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ol>
<li>当使用<iostream>的时候，该头文件没有定义全局命名空间，必须使用namespace std ;这样才能正确使用cout。若不引入using namespace std ,需要这样做。std::cout</li>
<li>C++标准为了和C区别开，也为了正确使用命名空间，规定头文件不使用后缀.h</li>
<li>C++命名空间的定义:namespace name {…}</li>
<li>using namespace NameSpaceA;</li>
<li>namespace定义可嵌套。</li>
</ol>
<h3 id="实用性增强"><a href="#实用性增强" class="headerlink" title="实用性增强"></a>实用性增强</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
&#x2F;&#x2F;c语言中的变量都必须在作用域开始的位置定义!!
&#x2F;&#x2F;C++中更强调语言的“实用性”，所有的变量都可以在需要使用时再定义。
int main(void)
int i &#x3D; 0;
cout &lt;&lt; &quot;i &#x3D; &quot; &lt;&lt;i &lt;&lt;endl;
int k;
k &#x3D; 4;
cout &lt;&lt; &quot;k &#x3D; &quot; &lt;&lt;k &lt;&lt;endl;
return 0;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="变量检测增强"><a href="#变量检测增强" class="headerlink" title="变量检测增强"></a>变量检测增强</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*
在c语言中，重复定义多个同名的全局变量是合法的在C++中，不允许定义多个同名的全局变量
C语言中多个同名的全局变量最终会被链接到全局数据区的同一个地址空间上
int g_var;
int g_var &#x3D; 1;
C++直接拒绝这种二义性的做法。
*&#x2F;
#include &lt;iostream&gt;
int g_var;
int g_var &#x3D; 1;
int main(int argc, char *argv[])
&#123;
printf( &quot;g_var &#x3D; %d\n&quot;, g_var);
    return 0;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="http://qiniu.orangew.cn/img/20220703105256.png" alt="20220703105256"></p>
<h3 id="struct-类型增强"><a href="#struct-类型增强" class="headerlink" title="struct 类型增强"></a>struct 类型增强</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*
c语言的struct定义了一组变量的集合，c编译器并不认为这是一种新的类型C++中的struct是一个新类型的定义声明
*&#x2F;
#include &lt;iostream&gt;
struct student&#123;
char name[100];
int age;
&#125;;
int main(int argc,char *argv[])&#123;
student s1 &#x3D; &#123;&quot;wang&quot;,1&#125;;
Student s2 &#x3D; &#123;&quot;wang2&quot;,2&#125;;
return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="C-中所有变量和函数都必须有类型"><a href="#C-中所有变量和函数都必须有类型" class="headerlink" title="C++中所有变量和函数都必须有类型"></a>C++中所有变量和函数都必须有类型</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">
&#x2F;*
C++中所有的变量和函数都必须有类型c语言中的默认类型在C++中是不合法的
函数f的返回值是什么类型，参数又是什么类型?函数g可以接受多少个参数?
*&#x2F;
&#x2F;&#x2F;更换成.cpp试试
f(i)
&#123;
	printf( &quot;i &#x3D; %d \n&quot;, i);
&#125;
g()&#123;
return 5;
&#125;
int main(int argc, char *argv[])&#123;
f(10);
printf(&quot;g() &#x3D; %d\n&quot;, g(1，2，3，4，5));
getchar();
return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>在C语言中<br>int f()﹔表示返回值为int ，接受任意参数的函数</p>
<p>int ((void);表示返回值为int的无参函数</p>
<p>在C++中<br>intf( );和int f(void)具有相同的意义，都表示返回值为int的无参函数</p>
<p>C++更加强调类型，任意的程序元素都必须显示指明类型</p>
</blockquote>
<h3 id="新增bool类型关键字"><a href="#新增bool类型关键字" class="headerlink" title="新增bool类型关键字"></a>新增bool类型关键字</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*
C++中的布尔类型
C++在C语言的基本类型系统之上增加了boolC++中的bool可取的值只有true和false理论上bool只占用一个字节，
如果多个bool变量定义在一起，可能会各占一个bit，这取决于编译器的实现
true代表真值，编译器内部用1来表示
false代表非真值，编译器内部用o来表示
bool类型只有true(非e)和false (0)两个值
C++编译器会在赋值时将非o值转换为true，0值转换为false*&#x2F;
#include &lt;iostream&gt;
using namespace std;
int main(int argc,char *argv[])&#123;
int a;
bool b &#x3D; true;
printf( &quot;b &#x3D; %d, sizeof(b) &#x3D; %d \n&quot;, b, sizeof(b));
b &#x3D; 4;
a &#x3D; b;
printf( &quot;a &#x3D; %d, b &#x3D; %d\n&quot;, a,b);
b &#x3D; -4;
a &#x3D; b;
printf( &quot;a &#x3D; %d， b &#x3D; %d \n&quot;, a,b);
a &#x3D; 10;
b &#x3D; a;
printf( &quot;a &#x3D; %d， b &#x3D; %d\n&quot;, a,b);
b &#x3D; 0;
printf( &quot;b &#x3D; %d \n&quot;, b);
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="三目运算符功能增强"><a href="#三目运算符功能增强" class="headerlink" title="三目运算符功能增强"></a>三目运算符功能增强</h3><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span>
using namespace std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>
<span class="token comment">//返回一个最小数并且给最小数赋值成30</span>
<span class="token comment">//三目运算符是一个表达式，表达式不可能做左值( a &lt; b ? a : b ) = 30;</span>
<span class="token function">printf</span><span class="token punctuation">(</span> <span class="token string">"a = %d, b = %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>1 )C语言返回变量的值</p>
<p>​    C++语言是返回变量本身</p>
<p>​    C语言中的三目运算符返回的是变量值，不能作为左值使用</p>
<p>​    C++中的三目运算符可直接返回变量本身，因此可以出现在程序的任何地<br>方<br>2）注意:三目运算符可能返回的值中如果有一个是常量值，则不能作为左值使用<br>​    ( a&lt; b ? 1 : b )= 30;</p>
<p>3)C语言如何支持类似C++的持性呢?</p>
<p>​    当左值的条件:要有内存空间;</p>
<p>​    C++编译器帮助程序员取了一个地址而已</p>
</blockquote>
<h3 id="const增强"><a href="#const增强" class="headerlink" title="const增强"></a>const增强</h3><h4 id="const基础知识"><a href="#const基础知识" class="headerlink" title="const基础知识"></a>const基础知识</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
int main(void)
&#123;
&#x2F;&#x2F; const 定义常量---&gt; const意味只读
const int a;
int const b;
&#x2F;第一个第二个意思一样代表一个常整形数
const int *c ;
&#x2F;&#x2F;第三个c是一个指向常整形数的指针(所指向的内存数据不能被修改，但是本身可以修改)
int *const d;
&#x2F;第四个d 常指针（指针变量不能被修改，但是它所指向内存空间可以被修改)
const int *const e ;
&#x2F;&#x2F;第五个e一个指向常整形的常指针（指针和它所指向的内存空间，均不能被修改)
return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>合理的利用const的好处，<br>1指针做面数参数，可以有效的提高代码可读性，减少bug ;</p>
<p>2清楚的分清参数的输入和输出特性</p>
</blockquote>
<ul>
<li><code>int setTeacher_err( const Teacher *p)</code></li>
<li>Const修改形参的时候，在利用形参不能修改指针所向的内存空间</li>
</ul>
<h4 id="C语言中的“冒牌货”"><a href="#C语言中的“冒牌货”" class="headerlink" title="C语言中的“冒牌货”"></a>C语言中的“冒牌货”</h4><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span> <span class="token string">"a===>%d a===>%p\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">*</span>p <span class="token operator">=</span> <span class="token number">11</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span> <span class="token string">"a===>%d a===>%p\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="http://qiniu.orangew.cn/img/20220703111635.png" alt="20220703111635"></p>
<h4 id="const-和-define的相同"><a href="#const-和-define的相同" class="headerlink" title="const 和#define的相同"></a>const 和#define的相同</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
&#x2F;&#x2F;#define N 10
int main()
&#123;
	const int a &#x3D; 1;
    const int b &#x3D; 2;
	int array[a + b] &#x3D; &#123;0&#125;;
    int i &#x3D; 0;
	for(i &#x3D; 0; i &lt; (a+b); i++)&#123;
	printf( &quot;array[%d] &#x3D; %d\n&quot;, i, array[i]);
&#125;
	return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>C++中的const修饰的，是一个真正的常量，而不是c中变量（只读)。在const修饰的常量编译期间，就已经确定下来了</li>
</ul>
<h4 id="const和-define的区别"><a href="#const和-define的区别" class="headerlink" title="const和#define的区别"></a>const和#define的区别</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
void fun1()
&#123;
#define a 10
const int b &#x3D; 20;
&#125;
void fun2()&#123;
printf( &quot;a &#x3D; %d\n&quot;, a);
    &#x2F;&#x2F; printf( &quot;b &#x3D; %d \n&quot;, b);
&#125;
int main()&#123;
	fun1();
    fun2();
return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>C++中的const常量类似于宏定义</li>
<li><code>const int c = 5; #define c 5</code></li>
<li>C++中的const常量与宏定义不同</li>
<li><strong>const常量是由编译器</strong>处理的，提供类型检查和作用域检查</li>
<li><strong>宏定义由预处理器处理</strong>，单纯的文本替换</li>
</ul>
<blockquote>
<p>C语言中的const变量<br>C语言中const变量是只读变量，有自己的存储空间</p>
<p>C+＋中的const常量<br>    可能分配存储空间,也可能不分配存储空间<br>    当const常量为全局，并且需要在其它文件中使用，会分配存储空间当使用&amp;操    作符，取const常量的地址时，会分配存储空间<br>    当const int &amp;a = 10; const修饰引用时，也会分配存储空间</p>
</blockquote>
<h3 id="真正的枚举"><a href="#真正的枚举" class="headerlink" title="真正的枚举"></a>真正的枚举</h3><ul>
<li>c语言中枚举本质就是整型,枚举变量可以用任意整型赋值。而c++中枚举变量,只能用被枚举出来的元素初始化。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
enum season &#123;SPR, SUM,AUT ,WIN&#125;;
int main()
&#123;
enum season s &#x3D; SPR;
&#x2F;&#x2F;s &#x3D; 0;l&#x2F;error，但是C语言可以通过s &#x3D; SUM;
    cout &lt;&lt; &quot;s&#x3D; &quot; &lt;&lt; s &lt;&lt;endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="C-对C语言的拓展"><a href="#C-对C语言的拓展" class="headerlink" title="C++对C语言的拓展"></a>C++对C语言的拓展</h2><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><h4 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h4><ul>
<li>变量名实质上是一段连续存储空间的别名，是一个标号(门牌号)</li>
<li>通过变量来申请并命名内存空间.</li>
<li>通过变量的名字可以使用存储空间.</li>
</ul>
<h4 id="引用的概念"><a href="#引用的概念" class="headerlink" title="引用的概念"></a>引用的概念</h4><ul>
<li>变量名，本身是一段内存的引用，即别名(alias).引用可以看作一个已定义变量的别名。</li>
<li>引用的语法：Type &amp;name =var;</li>
<li>用法如下</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
int main(void)
&#123;
	int a &#x3D; 10; &#x2F;&#x2F;c编译器分配4个字节内存，a内存空间的别名
	int &amp;b &#x3D; a; &#x2F;&#x2F;b就是a的别名
	a &#x3D; 11; &#x2F;&#x2F;直接赋值
	&#123;
		int *p &#x3D; &amp;a;
		*p &#x3D; 12;
		cout &lt;&lt; a &lt;&lt;endl;
	&#125;
	b &#x3D; 14;
	cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt;a &lt;&lt; &quot;, b &#x3D; &quot; &lt;&lt; b &lt;&lt;endl;
	return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ol>
<li>引用没有定义,是一种关系型声明。声明它和原有某一变量(实体)的关系。故而类型与原类型保持一致,且不分配内存。与被引用的变量有相同的地址。</li>
<li>声明的时候必须初始化,一经声明,不可变更。</li>
<li>可对引用,再次引用。多次引用的结果,是某一变量具有多个别名。</li>
<li>&amp;符号前有数据类型时,是引用。其它皆为取地址。</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int main(void)&#123;
int a,b;
int &amp;r &#x3D; a;
int &amp;r &#x3D; b; &#x2F;&#x2F;错误,不可更改原有的引用关系
float &amp;rr &#x3D; b;&#x2F;&#x2F;错误,引用类型不匹配 cout&lt;&lt;&amp;a&lt;&lt;&amp;r&lt;&lt;endl;&#x2F;&#x2F;变量与引用具有相&gt;同的地址。
int &amp;ra &#x3D; r;&#x2F;&#x2F;可对引用更次引用,表示a变量有两个别名,分别是r和 ra
return 0;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="引用作为函数参数"><a href="#引用作为函数参数" class="headerlink" title="引用作为函数参数"></a>引用作为函数参数</h4><ul>
<li>普通引用在声明时必须用其它的变量进行初始化，引用作为函数参数声明时不进行初始化。 </li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
struct Teacher
&#123;
	char name[ 64];
    int age ;
&#125;;
void printfT(Teacher *pT)&#123;
cout&lt;&lt; pT-&gt;age &lt;&lt;endl;
&#125;
&#x2F;&#x2F;pT是t1的别名,相当于修改了t1
void printfT2(Teacher &amp;pT)&#123;
pT.age &#x3D; 33;
cout&lt;&lt;pT.age&lt;&lt;endl;
&#125;
&#x2F;&#x2F;pT和t1的是两个不同的变量
void printfT3(Teacher pT)&#123;
cout&lt;&lt;pT.age&lt;&lt;endl;
pT.age &#x3D; 45;&#x2F;&#x2F;只会修改pT变量,不会修改t1变量
&#125;
int main(void)&#123;
Teacher t1;
t1.age &#x3D; 35;
printfT(&amp;t1);
printfT2(t1); &#x2F;&#x2F;pT是t1的别名
printf( &quot;t1.age: %d \n&quot;, t1.age); &#x2F;&#x2F;33
printfT3(t1) ;&#x2F;&#x2F; pT是形参,t1 copy一份数据给pT
printf( &quot;t1.age:%d \n&quot;, t1.age); &#x2F;&#x2F;33
return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="引用的意义"><a href="#引用的意义" class="headerlink" title="引用的意义"></a>引用的意义</h4><ul>
<li>引用作为其它变量的别名而存在，因此在一些场合可以代替指针</li>
<li>引用相对于指针来说具有更好的可读性和实用性</li>
</ul>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//无法实现两数据的交换</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开辟了两个指针空间实现交换</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
void swap( int &amp;a, int &amp;b)&#123;
	int tmp;
	tmp &#x3D; a; 
    	a &#x3D; b;
    	b &#x3D; tmp;
&#125;
int main()&#123;
	int a &#x3D; 3,b &#x3D; 5;
	cout&lt;&lt; &quot;a &#x3D; &quot;&lt;&lt;a&lt;&lt;&quot;b &#x3D; &quot;&lt;&lt;b&lt;&lt;endl;
    	swap(a,b);
	cout&lt;&lt;&quot;a &#x3D; &quot;&lt;&lt;a&lt;&lt;&quot;b &#x3D; &quot;&lt;&lt;b&lt;&lt;endl;
    	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>C++中引入引用后,可以用引用解决的问题。避免用指针来解决。</li>
</ul>
<h4 id="引用的本质"><a href="#引用的本质" class="headerlink" title="引用的本质"></a>引用的本质</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
int main()
&#123;
int a &#x3D; 10;
int &amp;b &#x3D; a; &#x2F;&#x2F;注意:单独定义的引用时，必须初始化。
b &#x3D; 11;
printf( &quot;a:%d \n&quot;, a) ;
printf(&quot;b:%d \n&quot;, b);
printf( &quot;&amp;a : %p\n&quot;, &amp;a);
printf(&quot;&amp;b: %p\n&quot;,&amp;b);
return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>思考一：C++编译器定义引用后，背后做了什么</li>
<li>思考二：普通引用有自己的空间吗？</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
struct Teacher &#123;
int &amp;a;
int &amp;b;
&#125;;
int main()&#123;
printf(&quot;sizeof(Teacher) %d\n&quot;, sizeof( Teacher));
return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol>
<li>引用在C++中的内部实现是一个常指针<ul>
<li><code>Type&amp; name&lt;===&gt;Type* const name</code></li>
</ul>
</li>
<li>C++编译器在编译过程中使用常指针作为引用的内部实现，因此引用所占用的空间大小与指针相同。</li>
<li>从使用的角度，引用会让人误会其只是一个别名，没有自己的存储空间。这是C++为了实用性而做出的细节隐藏。</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void func(int &amp;a)&#123;
a &#x3D; 5;
&#125;
void func(int *const a)&#123;
a &#x3D; 5;
&#125;
int main()i
int x &#x3D; 10;func(x);
return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>间接赋值的3各必要条件<br>1定义两个变量(一个实参一个形参)</p>
<p>2建立关联实参取地址传给形参</p>
<p>3 * p形参去间接的修改实参的值</p>
</blockquote>
<ul>
<li>引用在实现上，只不过是把∶间接赋值成立的三个条件的后两步和二为一.当实参传给形参引用的时候，只不过是c++编译器帮我们程序员手工取了一个实参地址，传给了形参引用（常量指针)。</li>
</ul>
<h4 id="引用作为函数的返回值（引用当左值）"><a href="#引用作为函数的返回值（引用当左值）" class="headerlink" title="引用作为函数的返回值（引用当左值）"></a>引用作为函数的返回值（引用当左值）</h4><blockquote>
<p>当函数返回值为引用时，<br>若返回栈变量:<br>不能成为其它引用的初始值（不能作为左值使用)</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">include &lt;iostream&gt;
using namespace std;
int getA1()
&#123;
	int a;
    a &#x3D; 10;
    return a;
&#125;
int&amp; getA2()&#123;
	int a;
    a &#x3D; 10;
    return a;
&#125;
int main(void)&#123;
int a1 &#x3D; 0;
    int a2 &#x3D; 0;
&#x2F;&#x2F;值拷贝
a1 &#x3D; getA1();
&#x2F;&#x2F;将一个引用赋给一个变量，会有拷贝动作
&#x2F;&#x2F;理解:编译器类似做了如下隐藏操作，a2 &#x3D; *(getA2())
a2 &#x3D; getA2();
&#x2F;&#x2F;将一个引用赋给另一个引用作为初始值，由于是栈的引用，内存非法
int &amp;a3 &#x3D; getA2();
cout &lt;&lt;&quot;a1 &#x3D; &quot; &lt;&lt;a1&lt;&lt;endl;
cout &lt;&lt;&quot;a2 &#x3D; &quot; &lt;&lt;a2&lt;&lt;endl;
cout &lt;&lt;&quot;a3 &#x3D; &quot; &lt;&lt;a3&lt;&lt;endl;
return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>当函数返回值为引用时，</p>
<p>若返回静态变量或全局变量</p>
<p>可以成为其他引用的初始值（可作为右值使用，也可作为左值使用)</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
int getA1()
&#123;
static int a;
a &#x3D; 10;
return a;
&#125;
int&amp; getA2()&#123;
static int a;
a &#x3D; 10;
return a;
&#125;
int main(void)&#123;
int a1 &#x3D; 0;int a2 &#x3D; 0;
&#x2F;&#x2F;值拷贝
a1 &#x3D; getA1();
&#x2F;&#x2F;将一个引用赋给一个变量，会有拷贝动作
&#x2F;&#x2F;理解︰编译器类似做了如下隐藏操作，a2 &#x3D; *(getA2())
a2 &#x3D; getA2();
&#x2F;&#x2F;将一个引用赋给另一个引用作为初始值，由于是静态区域，内存合法
int &amp;a3 &#x3D; getA2();
cout &lt;&lt;&quot;a1 &#x3D; &quot; &lt;&lt;a1&lt;&lt;endl;
    cout &lt;&lt;&quot;a2 &#x3D; &quot; &lt;&lt;a2&lt;&lt;endl;
    cout &lt;&lt;&quot;a3 &#x3D; &quot; &lt;&lt;a3&lt;&lt;endl;
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>引用作为函数返回值，</p>
<p>如果返回值为引用可以当左值，</p>
<p>如果返回值为普通变量不可以当左值。</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
&#x2F;&#x2F;函数当左值
&#x2F;&#x2F;返回变量的值
int func1()&#123;
static int a1 &#x3D; 10;
    return a1;
&#125;
&#x2F;&#x2F;返回变量本身，
int&amp; func2()&#123;
static int a2 &#x3D; 10;
    return a2;
&#125;
int main(void)&#123;
&#x2F;&#x2F;函数当右值
int c1 &#x3D; func1();
cout &lt;&lt; &quot;c1 &#x3D; &quot; &lt;&lt; c1 &lt;&lt;endl;
int c2 &#x3D; func2();&#x2F;&#x2F;函数返回值是一个引用,并且当右值
    cout &lt;&lt; &quot;c2 &#x3D; &quot; &lt;&lt; c2 &lt;&lt;endl;
&#x2F;&#x2F;函数当左值
&#x2F;&#x2F;func1() &#x3D; 100;l &#x2F;&#x2F; error
    func2() &#x3D; 100;
&#x2F;&#x2F;函数返回值是一个引用,并且当左值
c2 &#x3D; func2();
cout &lt;&lt; &quot;c2 &#x3D; &quot; &lt;&lt; c2 &lt;&lt;endl;
return 0;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="指针引用"><a href="#指针引用" class="headerlink" title="指针引用"></a>指针引用</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
struct Teacher
&#123;
char name[64];
    int age ;
&#125;;
&#x2F;&#x2F;在被调用函数获取资源
int getTeacher(Teacher **p)&#123;
	Teacher *tmp &#x3D;NULL;
    if (p &#x3D;&#x3D; NULL)&#123;return -1;&#125;
	tmp &#x3D; (Teacher *)malloc ( sizeof( Teacher) );
    if (tmp &#x3D;&#x3D;NULL)&#123;return -2;&#125;
	tmp-&gt;age &#x3D; 33;
&#x2F;&#x2F;p是实参的地址 *实参的地址去间接的修改实参的值
	*p &#x3D; tmp;
	return 0;
&#125;
&#x2F;&#x2F;指针的引用做函数参数
int getTeacher2(Teacher*&amp;myp)&#123;
&#x2F;&#x2F;给myp赋值相当于给main函数中的pT1赋值
	myp &#x3D; (Teacher * )malloc ( sizeof(Teacher));
    	if (myp &#x3D;&#x3D; NULL)&#123;return -1;&#125;
	myp-&gt;age &#x3D; 36;
	return 0;
&#125;
void FreeTeacher(Teacher *pT1)&#123;
if (pT1 &#x3D;&#x3D; NULL)&#123;
return ;&#125;
free(pT1);
&#125;
int main(void)&#123;
Teacher *pT1 &#x3D; NULL;
&#x2F;&#x2F;1 c语言中的二级指针
    getTeacher(&amp;pT1);
cout&lt;&lt; &quot;age: &quot;&lt;&lt;pT1-&gt;age&lt;&lt;endl;
    FreeTeacher(pT1);
&#x2F;&#x2F;2 c++中的引用(指针的引用)
&#x2F;&#x2F;引用的本质间接赋值后2个条件让c++编译器帮我们程序员做了。
getTeacher2(pT1);
cout&lt;&lt; &quot;age: &quot;&lt;&lt;pT1-&gt;age&lt;&lt;endl;
FreeTeacher(pT1);
return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="const引用"><a href="#const引用" class="headerlink" title="const引用"></a>const引用</h4><ul>
<li>const引用有较多使用。它可以防止对象的值被随意修改。因而具有一些特性。</li>
<li>const 对象的引用必须是const的,将普通引用绑定到const对象是不合法的。这个原因比较简单。既然对象是const的,表示不能被修改,引用当然也不能修改,必须使用const引用。实际上，const int a=1;int &amp;b=a;这种写法是不合法的,编译不过。</li>
<li>const引用可使用相关类型的对象(常量,非同类型的变量或表达式)初始化。这个是const引用与普通引用最大的区别。const int &amp;a=2;是合法的。double x=3.14;const int &amp;b=a;也是合法的。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
int main(void)
&#123;
&#x2F;&#x2F;普通引用
int a &#x3D; 10;
int &amp;b &#x3D; a;
cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt;endl;
&#x2F;&#x2F;常引用
int x &#x3D; 20;
const int &amp;y &#x3D; x;&#x2F;&#x2F;常引用是限制变量为只读不能通过y去修改x了
&#x2F;&#x2F;y &#x3D; 21;&#x2F;&#x2F; error
return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="const引用的原理"><a href="#const引用的原理" class="headerlink" title="const引用的原理"></a>const引用的原理</h4><ul>
<li>const 引用的目的是,禁止通过修改引用值来改变被引用的对象。const引用的初始化特性较为微妙,可通过如下代码说明:</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double val &#x3D; 3.14;
const int &amp;ref &#x3D; val;
double &amp; ref2 &#x3D; val;
cout&lt;&lt;ref&lt;&lt;&quot; &quot;&lt;&lt;ref2&lt;&lt;endl;
val &#x3D; 4.14;
cout&lt;&lt;ref&lt;&lt;&quot; &quot;&lt;&lt;ref2&lt;&lt;endl;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>上述输出结果为3 3.14和3 4.14。因为ref是const的,在初始化的过程中已经给定值,不允许修改。而被引用的对象是val,是非const的,所以val的修改并未影响ref的值,而ref2的值发生了相应的改变。</li>
<li>那么,为什么非const的引用不能使用相关类型初始化呢?实际上,const引用使用相关类型对象初始化时发生了如下过程:</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int temp &#x3D; val;
const int &amp;ref &#x3D; temp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li>如果ref 不是const的,那么改变ref值,修改的是temp,而不是val。期望对ref的赋值会修改val的程序员会发现val实际并未修改。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
int main(void)
&#123;
&#x2F;&#x2F;1&gt;用变量初始化 常引用
    int x1 &#x3D; 30;
const int &amp;y1 &#x3D; x1;&#x2F;&#x2F;用x1变量去初始化 常引用
&#x2F;&#x2F;2&gt;用字面量初始化常量引用
const int a &#x3D; 40;&#x2F;&#x2F;c++编译器把a放在符号表中
&#x2F;&#x2F;int &amp;m &#x3D; 41; &#x2F;&#x2F;error ，普通引用引用一个字面量请问字面量有没有内存地址
const int &amp;m &#x3D; 43;&#x2F;&#x2F;c++编译器会分配内存空间
				&#x2F;&#x2F;int temp &#x3D; 43
				&#x2F;&#x2F;const int &amp;m &#x3D; temp;
return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
struct Teacher
&#123;
	char name[64];
    int age ;
&#125;;
void printTeacher( const Teacher &amp;myt)&#123;
&#x2F;&#x2F;常引用让实参变量拥有只读属性&#x2F;&#x2F; myt.age &#x3D; 33;
printf(&quot;myt.age: %d \n&quot;, myt.age);
&#125;
int main( void)&#123;
Teacher t1;
t1.age &#x3D; 36;
printTeacher(t1);
return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>结论:<br>1 ) const int &amp; e 相当于const int * const e</p>
<p>2）普通引用相当于int *const e</p>
<p>3）当使用常量（字面量）对const引用进行初始化时，C++编译器会为常量值分配空间，并将引用名作为这段空间的别名</p>
<p>4）使用字面量对const引用初始化后，将生成一个只读变量</p>
</blockquote>
<h3 id="inline内联函数"><a href="#inline内联函数" class="headerlink" title="inline内联函数"></a>inline内联函数</h3><ul>
<li>c语言中有宏函数的概念。宏函数的特点是内嵌到调用代码中去,避免了函数调用的开销。但是由于宏函数的处理发生在预处理阶段,缺失了语法检测和有可能带来的语意差错。</li>
</ul>
<h4 id="内联函数基本概念"><a href="#内联函数基本概念" class="headerlink" title="内联函数基本概念"></a>内联函数基本概念</h4><ul>
<li>C++提供了inline关键字，实现了真正的内嵌</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
inline void func( int a)&#123;
a &#x3D; 20;
cout &lt;&lt; a &lt;&lt;endl;
&#125;
int main(void)&#123;
func(10);&#x2F;*
&#x2F;编译器将内联函数的函数体直接展开&#123;
a &#x3D; 20;
cout &lt;&lt; a &lt;&lt;endl;
&#125;
*&#x2F;
return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>特点<ol>
<li>内联函数声明时inline关键字必须和函数定义结合在一起，否则编译器会直接忽略内联请求。</li>
<li>C++编译器直接将函数体插入在函数调用的地方。</li>
<li>内联函数<strong>没有普通函数调用时的额外开销</strong>(压栈，跳转，返回)。</li>
<li>内联函数是一种特殊的函数，具有普通函数的特征（参数检查，返回类型等）。</li>
<li><strong>内联函数由编译器处理</strong>，<strong>直接将编译后的函数体插入调用的地方</strong>，<strong>宏代码片段由预处理器处理</strong>，进行简单的文本替换，没有任何编译过程。</li>
<li>C++中内联编译的限制︰<ul>
<li>不能存在任何形式的循环语句</li>
<li>不能存在过多的条件判断语句</li>
<li>函数体不能过于庞大</li>
<li>不能对函数进行取址操作</li>
<li>函数内联声明必须在调用语句之前</li>
</ul>
</li>
<li>编译器对于内联函数的限制并不是绝对的，内联函数相对于普通函数的优势只是省去了函数调用时压栈，跳转和返回的开销。因此，<strong>当函数体的执行开销远大于压栈，跳转和返回所用的开销时，那么内联将无意义</strong>。</li>
</ol>
</li>
</ul>
<h4 id="内联函数VS宏函数"><a href="#内联函数VS宏函数" class="headerlink" title="内联函数VS宏函数"></a>内联函数VS宏函数</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;string.h&gt;
using namespace std;
#if 0
优点:内嵌代码,辟免压栈与出栈的开销
缺点:代码替换,易使生成代码体积变大,易产生逻辑错误。
#endif
#define SQR(x)((×)*(x))
#if 0
优点:高度抽象,避免重复开发
缺点:压栈与出栈,带来开销#endif
inline int sqr(int x)&#123;
return x*x;
&#125;
int main()&#123;
int i&#x3D;0;
    while(i&lt;5)&#123;
&#x2F;&#x2F;printf( &quot;%d\n&quot; ,SQR( i++));
        printf( &quot;%d \n&quot;,sqr(i++) );
&#125;
return ;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="内联函数总结"><a href="#内联函数总结" class="headerlink" title="内联函数总结"></a>内联函数总结</h4><blockquote>
<p>优点:避免调用时的额外开销(入栈与出栈操作)<br>代价:由于内联面数的函数体在代码段中会出现多个“副本”,因此会增加代码段的空间。</p>
<p>本质:以牺牲代码段空间为代价,提高程序的运行时间的效率。</p>
<p>适用场景:函数体很“小”,且被“频繁”调用。</p>
</blockquote>
<h3 id="默认参数和占位参数"><a href="#默认参数和占位参数" class="headerlink" title="默认参数和占位参数"></a>默认参数和占位参数</h3><ul>
<li>通常情况下,函数在调用时,形参从实参那里取得值。对于多次调用用一函数同一实参时,C++给出了更简单的处理办法。给形参以默认值,这样就不用从实参那里取值了。</li>
</ul>
<h4 id="单个默认参数"><a href="#单个默认参数" class="headerlink" title="单个默认参数"></a>单个默认参数</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;1若你填写参数,使用你填写的,不填写默认void myPrint(int x &#x3D; 3)
&#123;
cout&lt;&lt;&quot;x : “&lt;&lt;x&lt;&lt; endl;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="多个默认参数"><a href="#多个默认参数" class="headerlink" title="多个默认参数"></a>多个默认参数</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;2在默认参数规则，如果默认参数出现，那么右边的都必须有默认参数float volume(float length，float weight &#x3D; 4,float high &#x3D; 5)&#123;
return length*weight*high;
&#125;
int main()i
float v &#x3D; volume( 10);
float v1 &#x3D; volume(10,20);
float v2 &#x3D; volume(10,20,30);
cout&lt;&lt;v&lt;&lt;endl;
cout&lt;&lt;v1&lt;&lt;endl;
cout&lt;&lt;v2&lt;&lt;endl;
return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="默认参数规则"><a href="#默认参数规则" class="headerlink" title="默认参数规则"></a>默认参数规则</h4><ul>
<li>只有参数列表后面部分的参数才可以提供默认参数值</li>
<li>一旦在一个函数调用中开始使用默认参数值，那么这个参数后的所有参数都必须使用默认参数值</li>
</ul>
<h4 id="占位参数"><a href="#占位参数" class="headerlink" title="占位参数"></a>占位参数</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
&#x2F;*
函数占位参数
占位参数只有参数类型声明，而没有参数名声明一般情况下，在函数体内部无法使用占位参数*&#x2F;
int func( int a, int b, int)&#123;
return a + b;
&#125;
int main()&#123;
func(1，2); &#x2F;&#x2F;error,必须把最后一个占位参数补上。
&#x2F;&#x2F;好悲剧的语法-_-!
printf( &quot;func(1，2，3) &#x3D; %d\n&quot;, func(1，2，3));
return 0;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
&#x2F;*
可以将占位参数与默认参数结合起来使用意义
为以后程序的扩展留下线索
兼容C语言程序中可能出现的不规范写法*&#x2F;
&#x2F;&#x2F;C++可以声明占位符参数，占位符参数一般用于程序扩展和对c代码的兼容
int func2(int a, int b, int &#x3D; 0)
&#123;
return a + b;
&#125;
int main()&#123;
&#x2F;&#x2F;如果默认参数和占位参数在一起，都能调用起来func2(1，2);
func2(1，2，3);
return 0;
&#125;
&#x2F;*
结论:如果默认参数和占位参数在一起，都能调用起来*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><ul>
<li>函数重载(Function Overload)∶用同一个函数名定义不同的函数，当函数名和不同的参数搭配时函数的含义不同。</li>
</ul>
<h4 id="函数重载规则"><a href="#函数重载规则" class="headerlink" title="函数重载规则"></a>函数重载规则</h4><blockquote>
<p>1.函数名相同</p>
<p>2.参数个数不同，参数的类型不同，参数的顺序不同，均可以构成重载</p>
<p>3.返回值类型不同则不可以构成重重</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void func(int a); &#x2F;&#x2F; ok
void func(char a); &#x2F;&#x2F;ok
void func( char a,int b); &#x2F;&#x2F; ok
void func(int a, char b); &#x2F;&#x2F;ok
char func(int a); &#x2F;&#x2F;与第一个函数有冲突<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="调用准则"><a href="#调用准则" class="headerlink" title="调用准则"></a>调用准则</h4><blockquote>
<p>1.严格匹配，找到则调用</p>
<p>2.通过隐式转换寻求一个匹配，找到则调用</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
void print( double a)&#123;
cout&lt;&lt;a&lt;&lt;endl;
&#125;
void print(int a)&#123;
cout&lt;&lt;a&lt;&lt;endl;
&#125;
int main()&#123;
print(1); &#x2F;&#x2F;print(int)
print(1.1); &#x2F;&#x2F;print(double)
print(&#39;a&#39;); &#x2F;&#x2F;print(int)
print(1.11f); &#x2F;&#x2F;print( double)
return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>编译器调用重载函数的准则:<ol>
<li>将所有同名函数作为候选者</li>
<li>尝试寻找可行的候选函数</li>
<li>精确匹配实参</li>
<li>通过默认参数能够匹配实参</li>
<li>通过默认类型转换匹配实参</li>
<li>匹配失败</li>
<li>最终寻找到的可行候选函数不唯一，则出现二义性，编译失败。</li>
<li>无法匹配所有候选者，函数未定义，编译失败。</li>
</ol>
</li>
</ul>
<h4 id="重载的底层实现"><a href="#重载的底层实现" class="headerlink" title="重载的底层实现"></a>重载的底层实现</h4><ul>
<li>C++利用name mangling(倾轧)技术,来改名函数名,区分参数不同的同名函数。</li>
<li>实现原理:用vcifl d表示 void char int float long double及其引用。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void func( char a) ;
&#x2F;&#x2F;func_c(char a)
void func(char a, int b, double c); 
&#x2F;&#x2F;func_cid(char a, int b, double c)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="函数重载与函数默认参数"><a href="#函数重载与函数默认参数" class="headerlink" title="函数重载与函数默认参数"></a>函数重载与函数默认参数</h4><ul>
<li>一个函数,不能既作重载,又作默认参数的函数。当你少写一个参数时,系统无法确认是重载还是默认参数。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
int func(int a, int b, int c &#x3D; 0)&#123;
return a * b * c;
&#125;
int func(int a, int b)&#123;
return a + b;
&#125;
int func(int a)&#123;
return a;
&#125;
int main()&#123;
int c &#x3D; 0;
c &#x3D; func(1，2); &#x2F;&#x2F;error．存在二义性，调用失败，编译不能通过
printf(&quot;c &#x3D; %d\n&quot;， c);
return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="函数重载与函数指针相结合"><a href="#函数重载与函数指针相结合" class="headerlink" title="函数重载与函数指针相结合"></a>函数重载与函数指针相结合</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*
函数重载与函数指针
当使用重载函数名对函数指针进行赋值时
根据重载规则挑选与函数指针参数列表一致的候选者严格匹配候选者的函数类型与函数指针的函数类型*&#x2F;
#include &lt;iostream&gt;
using namespace std;
int func(int x)&#x2F;&#x2F;int(int a)
&#123;
return x;
&#125;
int func(int a, int b)&#123;
return a + b;
&#125;
int func( const char* s)&#123;
return strlen(s);
&#125;
typedef int(*PFUNC)(int a); &#x2F;&#x2F;int(*)(int a)
typedef int(*PFUNC2)(int a， int b); &#x2F;&#x2F;int(*)(int a， int b)
int main()
&#123;
int c &#x3D; 0;
PFUNC p &#x3D; func;
c &#x3D; p(1);
printf( &quot;c &#x3D; %d\n&quot;,c);
PFUNC2 p2 &#x3D; func;
c &#x3D; p2(1，2);
printf(&quot;c &#x3D; %d\n&quot;,c);
return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="函数指针基本语法"><a href="#函数指针基本语法" class="headerlink" title="函数指针基本语法"></a>函数指针基本语法</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;方法一:
&#x2F;&#x2F;声明一个函数类型
typedef void (myTypeFunc)(int a,int b);
&#x2F;&#x2F;定义一个函数指针
myTypeFunc *myfuncp &#x3D; NULL;&#x2F;&#x2F;定义一个函数指针这个指针指向函数的入口地址
&#x2F;&#x2F;方法二:
&#x2F;&#x2F;声明一个函数指针类型
typedef void (*myPTypeFunc)(int a,int b) ;&#x2F;&#x2F;声明了一个指针的数据类型
&#x2F;&#x2F;定义一个函数指针
myPTypeFunc fp &#x3D; NULL;&#x2F;&#x2F;通过函数指针类型定义了一个函数指针，
&#x2F;&#x2F;方法三:
&#x2F;&#x2F;定义一个函数指针变量
void (*myVarPFunc)(int a, int b);
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="函数重载总结"><a href="#函数重载总结" class="headerlink" title="函数重载总结"></a>函数重载总结</h4><blockquote>
<p>重载函数在本质上是相互独立的不同函数。</p>
<p>函数的函数类型是不同的</p>
<p>函数返回值不能作为函数重载的依据</p>
<p>函数重载是由函数名和参数列表决定的。</p>
</blockquote>
<h2 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h4><h4 id="成员变量与成员函数"><a href="#成员变量与成员函数" class="headerlink" title="成员变量与成员函数"></a>成员变量与成员函数</h4><h3 id="封装与访问控制"><a href="#封装与访问控制" class="headerlink" title="封装与访问控制"></a>封装与访问控制</h3><h4 id="从struct说起"><a href="#从struct说起" class="headerlink" title="从struct说起"></a>从struct说起</h4><ul>
<li>当单一变量无法完成描述需求的时候,结构体类型解决了这一问题。可以将多个类型打包成一体,形成新的类型。这是c语言中封装的概念。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
struct Date
&#123;
int year;
int month;
int day;
&#125;;
void init(Date &amp;d)&#123;
cout&lt;&lt; &quot;year,month,day : &quot;&lt;&lt;endl;
cin&gt;&gt;d.year&gt;&gt;d.month&gt;&gt;d.day;
&#125;
void print(Date &amp; d)&#123;
cout&lt;&lt;&quot;year month day&quot; &lt;&lt;endl;
cout&lt;&lt;d.year&lt;&lt;&quot; : &quot;&lt;&lt;d.month&lt;&lt;&quot; : &quot;&lt;&lt;d.day&lt;&lt;endl;
    
bool isLeapYear(Date &amp; d)
&#123;
if((d.year%4&#x3D;&#x3D;0&amp;&amp; d.year%100 !&#x3D; 0)||d.year%400 &#x3D;&#x3D; 0)
	return true;
else
	return false;
&#125;
int main()
Date d;
init(d);
print(d);
if(isLeapYear(d))
cout&lt;&lt;&quot;leap year&quot;&lt;&lt;endl;
else
cout&lt;&lt; &quot;not leap year&quot;&lt;&lt;endl;
return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>对C语言中结构体的操作，都是通过外部函数来实现的。比如</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void init(Date &amp;d) ;
void print(Date &amp; d);
bool isLeapYear(Date &amp; d);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h4 id="封装的访问属性"><a href="#封装的访问属性" class="headerlink" title="封装的访问属性"></a>封装的访问属性</h4><ul>
<li>struct 中所有行为和属性都是public的(默认)。</li>
<li>C++中的class可以指定行为和属性的访问方式。</li>
<li>封装,可以达到,对内开放数据,对外屏蔽数据,对外提供接口。达到了信息隐蔽的功能。</li>
<li>比如我们用struct封装的类,即知其接口,又可以直接访问其内部数据,这样却没有达到信息隐蔽的功效。而class则提供了这样的功能,屏蔽内部数据,对外开放接口。</li>
</ul>
<h4 id="用class去封装带行为的类"><a href="#用class去封装带行为的类" class="headerlink" title="用class去封装带行为的类"></a>用class去封装带行为的类</h4><ul>
<li>class封装的本质,在于将数据和行为,绑定在一起然后能过对象来完成操作。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespaec std;
class Date&#123;
    public:
    void init(Data &amp;d);
    void print(Data &amp;d);
    bool isLeapYear(Date &amp;d);
    private:
    int year;
    int month;
    int day;
&#125;;
void Data::init(Data &amp;d)&#123;
    cout&lt;&lt;&quot;year,month,day:&quot;&lt;&lt;endl;
    cin&gt;&gt;d.year&gt;&gt;d.month&gt;&gt;d.day;
&#125;
void Date::print(Date &amp; d)&#123;
cout&lt;&lt;&quot;year month day&quot;&lt;&lt;endl;
cout&lt;&lt;d.year&lt;&lt;&quot; : &quot;&lt;&lt;d.month&lt;&lt; &quot; : &quot;&lt;&lt;d.day&lt;&lt;endl;
&#125;
bool Date::isLeapYear(Date &amp; d)&#123;
if((d.year%4&#x3D;&#x3D; &amp;&amp; d.year%100 !&#x3D; 0)||d.year%400 &#x3D;&#x3D; 0)
	return true;
else
	return false;
&#125;
int main()&#123;
Date d;
d.init(d);
d.print(d);
if(d.isLeapYear(d))
cout&lt;&lt; &quot;leap year&quot;&lt;&lt;endl;
	else
cout&lt;&lt; &quot;not leap year&quot;&lt;&lt;endl;
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>Date类访问自己的成员,可以不需要传引用的方式</li>
<li>封装有2层含义(把属性和方法进行封装对属性和方法进行访问控制)</li>
<li>Public修饰成员变量和成员函数可以在类的内部和类的外部被访问。Private修饰成员变量和成员函数只能在类的内部被访问。</li>
</ul>
<blockquote>
<p>struct和class关键字区别</p>
<p>在用struct定义类时，所有成员的默认属性为public</p>
<p>在用class定义类时，所有成员的默认属性为private</p>
</blockquote>
<h3 id="面向对象编程案例练习"><a href="#面向对象编程案例练习" class="headerlink" title="面向对象编程案例练习"></a>面向对象编程案例练习</h3><h4 id="求圆的周长和面积"><a href="#求圆的周长和面积" class="headerlink" title="求圆的周长和面积"></a>求圆的周长和面积</h4><blockquote>
<p>数据描述:<br>                半径，周长，面积均用实型数表示<br>数据处理:<br>                输入半径r ;</p>
<p>​                计算周长= 2 * Π * r ;</p>
<p>​                计算面积=Π * r^2 ;</p>
<p>​                输出半径，周长，面积;</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;不用结构化
&#x2F;&#x2F;count the girth and area of circle
#include &lt;iostream&gt;
using namespace std;
int main ( void)
&#123;
double r, girth，area ;
const double PI &#x3D; 3.1415 ;
cout &lt;&lt; &quot;Please input radius : \n&quot; ;&#x2F;&#x2F;操作符重载
cin &gt;&gt; r ; &#x2F;&#x2F;输入
girth &#x3D; 2 *PI * r ;
area &#x3D; PI* r * r ;
cout &lt;&lt; &quot;radius &#x3D; &quot; &lt;&lt; r &lt;&lt; endl ;
cout &lt;&lt; &quot;girth &#x3D; &quot; &lt;&lt; girth &lt;&lt; endl ;
cout &lt;&lt; &quot;area &#x3D; &quot; &lt;&lt; area &lt;&lt; endl ;
return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;用面向对象的方法
#include&lt;iostream&gt;
using namespace std;
class Circle
&#123;
private:
	double radius ; &#x2F;&#x2F;成员变量
public : &#x2F;&#x2F;类的访问控制
	void set_Radius( double r )&#123;
	radius &#x3D; r;&#125;&#x2F;&#x2F;成员函数
	double Get_Radius()&#123;
	return radius;&#125;&#x2F;&#x2F;通过成员函数设置成员变量
    double Get_Girth()&#123;
	return2 *3.14f *radius;&#125;&#x2F;&#x2F;通过成员函数获取成员变量
	double Get_Area()&#123;
	return3.14f *radius *radius;
    &#125;
&#125;;
int main(void)
    &#123;
Circle A，B ; &#x2F;&#x2F;用类定义对象
A.Set_Radius( 6.23 ) ;&#x2F;&#x2F;类的调用
	cout &lt;&lt; &quot;A.Radius &#x3D; &quot; &lt;&lt; A.Get_Radius() &lt;&lt; endl ;
    cout &lt;&lt; &quot;A.Girth &#x3D; &quot; &lt;&lt;A.Get_Girth() &lt;&lt; endl ;
    cout &lt;&lt; &quot;A.Area &#x3D; &quot; &lt;&lt; A.Get_Area() &lt;&lt; endl ;
    B.Set_Radius( 10.5 ) ;
	cout &lt;&lt; &quot;B.radius &#x3D; &quot; &lt;&lt; B.Get_Radius() &lt;&lt; endl ;
    cout &lt;&lt;&quot;B.Girth&#x3D;&quot; &lt;&lt; B.Get_Girth( ) &lt;&lt; endl ;
	cout &lt;&lt;&quot;B.Area &#x3D; &quot; &lt;&lt;B.Get_Area() &lt;&lt; endl ;
return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="C语言和C-语言的关系"><a href="#C语言和C-语言的关系" class="headerlink" title="C语言和C++语言的关系"></a>C语言和C++语言的关系</h4><ul>
<li><p><img src="E:\Computer\myblog\hexo\source_posts\C-基础\20220703184846-16568453665731.png" alt="20220703184846"></p>
</li>
<li><p>C语言实在实践过程中逐步完善起来的</p>
</li>
</ul>
<blockquote>
<p>没有深思熟虑的设计过程</p>
<p>使用时存在很多“灰色地带”</p>
<p>残留量过多低级语言的特征</p>
<p>直接利用指针进行内存操作</p>
</blockquote>
<ul>
<li>C语言+面向对象方法论===&gt;Objective C/C++</li>
</ul>
<blockquote>
<p>C语言和C++并不是对立的竞争关系<br>C++是C语言的加强，是一种更好的C语言<br>C++是以C语言为基础的，并且完全兼容C语言的特性</p>
</blockquote>
<ul>
<li>学习C++并不会影响原有的C语言知识，相反会根据加深对C的认知;</li>
<li>学习C++可以接触到更多的软件设计方法，并带来更多的机会。</li>
<li>C++是一种更强大的C，通过学习C++能够掌握更多的软件设计方法.</li>
<li>C++是Java/C#/D等现代开发语言的基础，学习C++后能够快速掌握这些语言.</li>
<li>C++是各大知名软件企业挑选人才的标准之一.</li>
</ul>
<h4 id="综合面向对象案例分析"><a href="#综合面向对象案例分析" class="headerlink" title="综合面向对象案例分析"></a>综合面向对象案例分析</h4><blockquote>
<p>面向对象练习1</p>
<p>设计立方体类(cube)，求出立方体的面积和体积</p>
<p>求两个立方体，是否相等（全局面数和成员面数）</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
using namespace std;

&#x2F;&#x2F;立方体类
class Cube
&#123;
public:
	void setABC(int a, int b, int c)
	&#123;
		m_a &#x3D; a;
		m_b &#x3D; b;
		m_c &#x3D; c;
	&#125;
	int getArea()
	&#123;
		return (m_a*m_b) * 2 + (m_a*m_c) * 2 + (m_b*m_c) * 2;
	&#125;

	int getVolume()
	&#123;
		return (m_a*m_b*m_c);
	&#125;

	int getA()
	&#123;
		return m_a;
	&#125;

	int getB()
	&#123;
		return m_b;
	&#125;

	int getC()
	&#123;
		return m_c;
	&#125;

	&#x2F;&#x2F;同类之间无私处
	bool judgeCube(Cube &amp;another)
	&#123;
		if (m_a &#x3D;&#x3D; another.m_a &amp;&amp;
			m_b &#x3D;&#x3D; another.getB() &amp;&amp;
			m_c &#x3D;&#x3D; another.getC()) &#123;
			return true;
		&#125;
		else &#123;
			return false;
		&#125;
	&#125;
private:
	int m_a;
	int m_b;
	int m_c;
&#125;;

&#x2F;&#x2F;全局函数
bool judgeCube(Cube &amp;c1, Cube &amp;c2)
&#123;
	if (c1.getA() &#x3D;&#x3D; c2.getA() &amp;&amp;
		c1.getB() &#x3D;&#x3D; c2.getB() &amp;&amp;
		c1.getC() &#x3D;&#x3D; c2.getC()) &#123;
		return true;
	&#125;
	else &#123;
		return false;
	&#125;
&#125;

int main(void)
&#123;
	Cube c1;
	c1.setABC(10, 20, 30);

	Cube c2;
	c2.setABC(10, 20, 30);

	cout &lt;&lt; &quot;c1 的体积是&quot; &lt;&lt; c1.getVolume() &lt;&lt; endl;
	cout &lt;&lt; &quot;c1 的面积是&quot; &lt;&lt; c1.getArea() &lt;&lt; endl;

	if (judgeCube(c1, c2) &#x3D;&#x3D; true) &#123;
		cout &lt;&lt; &quot;相等&quot; &lt;&lt; endl;
	&#125;
	else &#123;
		cout &lt;&lt; &quot;不相等&quot; &lt;&lt; endl;
	&#125;
	cout &lt;&lt; &quot; ------ &quot; &lt;&lt; endl;

	if (c1.judgeCube(c2) &#x3D;&#x3D; true) &#123;
		cout &lt;&lt; &quot;相等&quot; &lt;&lt; endl;
	&#125;
	else &#123;
		cout &lt;&lt; &quot;不相等&quot; &lt;&lt; endl;
	&#125;


	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>面向对象练习2<br>设计一个圆形类（AdvCircle)，和一个点类（ Point)，</p>
<p>计算点在圆内部还是圆外部:</p>
<p>求点和圆的关系(圆内和圆外)</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;


using namespace std;

&#x2F;&#x2F;点类
class Point
&#123;
public:
	void setXY(int x, int y)
	&#123;
		m_x &#x3D; x;
		m_y &#x3D; y;
	&#125;

	int getX()
	&#123;
		return m_x;
	&#125;

	int getY()
	&#123;
		return m_y;
	&#125;
private:
	int m_x;
	int m_y;
&#125;;

&#x2F;&#x2F;圆类
class Circle
&#123;
public:
	void setXY(int x, int y)
	&#123;
		x0 &#x3D; x;
		y0 &#x3D; y;
	&#125;

	void setR(int r)
	&#123;
		m_r &#x3D; r;
	&#125;

	&#x2F;&#x2F;提供一个判断点是否在圆内
	&#x2F;&#x2F;true 在内部
	&#x2F;&#x2F;false 在外部
	bool judgePoint(Point &amp;p)
	&#123;
		int dd;

		dd &#x3D; (p.getX() - x0)*(p.getX() - x0) + (p.getY() - y0)*(p.getY() - y0);

		if (dd &gt; m_r*m_r) &#123;
			return false;
		&#125;
		else &#123;
			return true;
		&#125;
	&#125;


private:
	int x0;
	int y0;
	int m_r;
&#125;;

int main(void)
&#123;
	Circle c;
	c.setXY(2, 2);
	c.setR(4);

	Point p;
	p.setXY(8, 8);

	if (c.judgePoint(p) &#x3D;&#x3D; true) &#123;
		cout &lt;&lt; &quot;圆的内部&quot; &lt;&lt; endl;
	&#125;
	else &#123;
		cout &lt;&lt; &quot;圆的外部&quot; &lt;&lt; endl;
	&#125;



	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>面向对象练习3<br>对于第二个案例，类的声明和类的实现分开</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;Circle.h
#pragma once
#include &quot;Point.h&quot;

class Circle
&#123;
public:
	void setXY(int x, int y);

	void setR(int r);

	&#x2F;&#x2F;提供一个判断点是否在圆内
	&#x2F;&#x2F;true 在内部
	&#x2F;&#x2F;false 在外部
	bool judgePoint(Point &amp;p);

private:
	int x0;
	int y0;
	int m_r;
&#125;;

&#x2F;&#x2F;Circle.cpp
#include &quot;Circle.h&quot;

void Circle::setXY(int x, int y)
&#123;
	x0 &#x3D; x;
	y0 &#x3D; y;
&#125;

void Circle::setR(int r)
&#123;
	m_r &#x3D; r;
&#125;

&#x2F;&#x2F;提供一个判断点是否在圆内
&#x2F;&#x2F;true 在内部
&#x2F;&#x2F;false 在外部
bool Circle::judgePoint(Point &amp;p)
&#123;
	int dd;

	dd &#x3D; (p.getX() - x0)*(p.getX() - x0) + (p.getY() - y0)*(p.getY() - y0);

	if (dd &gt; m_r*m_r) &#123;
		return false;
	&#125;
	else &#123;
		return true;
	&#125;
&#125;

&#x2F;&#x2F;Point.h
#pragma once


class Point
&#123;
public:
	void setXY(int x, int y);

	int getX();

	int getY();
private:
	int m_x;
	int m_y;
&#125;;

&#x2F;&#x2F;Point.cpp
#include &quot;Point.h&quot;


void Point::setXY(int x, int y)
&#123;
	m_x &#x3D; x;
	m_y &#x3D; y;
&#125;

int  Point::getX()
&#123;
	return m_x;
&#125;

int Point::getY()
&#123;
	return m_y;
&#125;

&#x2F;&#x2F;main.cpp
#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &quot;Circle.h&quot;
#include &quot;Point.h&quot;

using namespace std;

int main(void)
&#123;
	Circle c;
	c.setR(4);
	c.setXY(2, 2);

	Point p;
	p.setXY(8, 8);

	if (c.judgePoint(p) &#x3D;&#x3D; true) &#123;
		cout &lt;&lt; &quot;nei&quot; &lt;&lt; endl;
	&#125;
	else &#123;
		cout &lt;&lt; &quot;wai&quot; &lt;&lt; endl;
	&#125;
	
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>判断两个圆是否相交</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;

&#x2F;&#x2F;点类
class Point
&#123;
public:
	void setXY(int x, int y)
	&#123;
		m_x &#x3D; x;
		m_y &#x3D; y;
	&#125;


	&#x2F;&#x2F;计算两点距离的方法
	double pointDistance(Point &amp;another)
	&#123;
		int d_x &#x3D; m_x - another.m_x;
		int d_y &#x3D; m_y - another.m_y;

		double dis &#x3D; sqrt(d_x*d_x + d_y*d_y);

		return dis;
	&#125;
private:
	int m_x;
	int m_y;
&#125;;

class Circle
&#123;
public:
	void setR(int r)
	&#123;
		m_r &#x3D; r;
	&#125;

	void setXY(int x, int y)
	&#123;
		p0.setXY(x, y);
	&#125;

	&#x2F;&#x2F;判断圆是否跟我相交
	bool isIntersection(Circle &amp;another)
	&#123;
		&#x2F;&#x2F;两个半径之和
		int rr &#x3D; m_r + another.m_r;
		&#x2F;&#x2F;两圆心之间距离
		double dis &#x3D; p0.pointDistance(another.p0);

		if (dis &lt;&#x3D; rr) &#123;
			&#x2F;&#x2F;相交
			return true;
		&#125;
		else &#123;
			return false;
		&#125;
	&#125;
private:
	int m_r;
	Point p0;
&#125;;

int main(void)
&#123;
	Circle c1, c2;

	int x, y, r;

	cout &lt;&lt; &quot;请输入第一个圆的半径&quot; &lt;&lt; endl;
	cin &gt;&gt; r;
	c1.setR(r);
	cout &lt;&lt; &quot;请输入第一个圆的x&quot; &lt;&lt; endl;
	cin &gt;&gt; x;
	cout &lt;&lt; &quot;请输入第一个圆的y&quot; &lt;&lt; endl;
	cin &gt;&gt; y;
	c1.setXY(x, y);


	cout &lt;&lt; &quot;请输入第2个圆的半径&quot; &lt;&lt; endl;
	cin &gt;&gt; r;
	c2.setR(r);
	cout &lt;&lt; &quot;请输入第2个圆的x&quot; &lt;&lt; endl;
	cin &gt;&gt; x;
	cout &lt;&lt; &quot;请输入第2个圆的y&quot; &lt;&lt; endl;
	cin &gt;&gt; y;
	c2.setXY(x, y);

	if (c1.isIntersection(c2) &#x3D;&#x3D; true) &#123;
		cout &lt;&lt; &quot;相交&quot; &lt;&lt; endl;
	&#125;
	else &#123;
		cout &lt;&lt; &quot;不想交&quot; &lt;&lt; endl;
	&#125;

	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="对象的构造和析构"><a href="#对象的构造和析构" class="headerlink" title="对象的构造和析构"></a>对象的构造和析构</h3><h4 id="如果没有构造函数"><a href="#如果没有构造函数" class="headerlink" title="如果没有构造函数"></a>如果没有构造函数</h4><ul>
<li>如果不用构造函数初始化，该怎么办︰<ul>
<li>为每个类都提供一个public的initialize函数;</li>
<li>对象创建后立即调用initialize函数进行初始化。</li>
</ul>
</li>
<li>缺点<ul>
<li>initialize只是一个普通的函数，必须显示的调用</li>
<li>一旦由于失误的原因，对象没有初始化，那么结果将是不确定的没有初始化的对象，其内部成员变量的值是不定的。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class Test
&#123;
public:
void init(int a, int b)&#123;
	m_a &#x3D; a;
	m_b &#x3D; b;
&#125;
private:
	int m_a;
    int m_b;
&#125;;
int main(void)&#123;
Test t1;
int a &#x3D; 10;int b &#x3D; 20;
t1.init(a, b);
Test tArray[3];
&#x2F;&#x2F;手动调用显示初始化函数
tArray[0].init(0，0);
tArray[1].init(0，0);
tArray[2].init(0，0);
Test t21;
&#x2F;&#x2F;手动调用显示初始化函数
    t21.init(0，0);
Test t22;
&#x2F;&#x2F;手动调用显示初始化函数
    t22.init(0，0);
Test t23;
&#x2F;&#x2F;手动调用显示初始化函数
    t23.init(0，0);
&#x2F;&#x2F;在这种场景之下显示的初始化方案显得很蹩脚
    Test tArray2[3] &#x3D; &#123;t21，t22,t23&#125;;
&#x2F;&#x2F;在这种场景之下,满足不了,编程需要
Test tArray3[1999] &#x3D; &#123;t21,t22,t23&#125;;
return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>所以C++对类提供了一个给对象的初始化方案，就是构造函数。</li>
</ul>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><ul>
<li>定义<ul>
<li>C++中的类可以定义与类名相同的特殊成员函数，这种与类名相同的成员函数叫做构造函数.</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class类名&#123;
	类名(形式参数)&#123;
	构造体
	&#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123;
    A(形参)&#123;
        
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>调用<ul>
<li>自动调用∶一般情况下C++编译器会自动调用构造函数.</li>
<li>手动调用∶在一些情况下则需要手工调用构造函数.</li>
</ul>
</li>
</ul>
<h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><ul>
<li>定义<ul>
<li>C++中的类可以定义一个特殊的成员函数清理对象，这个特殊的成员函数叫做析构函数.</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class类名&#123;
~类名()&#123;析构体&#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123;
	~A()&#123;
	
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>规则:<br>1对象销毁时,自动调用。完成销毁的善后工作。</p>
<p>2无返值,与类名同。无参。不可以重载与默认参数</p>
</blockquote>
<ul>
<li>析构函数的作用,并不是删除对象,而在对象销毁前完成的一些清理工作。</li>
</ul>
<h4 id="构造函数的分类及调用"><a href="#构造函数的分类及调用" class="headerlink" title="构造函数的分类及调用"></a>构造函数的分类及调用</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Test&#123;
public:
&#x2F;&#x2F;无参数构造函数
    Test()&#123;
        ;
    &#125;
&#x2F;&#x2F;带参数的构造函数
    Test(int a, int b)&#123;
        ;
    &#125;
&#x2F;&#x2F;赋值构造函数
	Test(const Test &amp;obj)
    &#123;
        ;
    &#125;
	private:
	int a;int b;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>无参构造函数</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class Test
&#123;
	public:
&#x2F;&#x2F;无参数构造函数
    Test()
    &#123;
		a &#x3D; 0;b &#x3D; 0;
		cout &lt;&lt;&quot;Test()无参构造函数执行&quot;&lt;&lt;endl;
    &#125;
	private:
	int a;int b;
&#125;;
int main(void)&#123;
	Test t;&#x2F;&#x2F;调用无参构造函数
    return 0;
    &#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>有参数构造函数</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class Test
&#123;
private:
int a;
public:
&#x2F;&#x2F;带参数的构造函数
    Test(int a)
    &#123;
        cout &lt;&lt;&quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt;endl;
	&#125;
	Test( int a, int b)&#123;
		cout &lt;&lt;&quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; &quot;, b &#x3D; &quot; &lt;&lt; b &lt;&lt;endl;
	&#125;
&#125;;
int main()&#123;
Test t1(10);
&#x2F;&#x2F;调用有参构造函数Test( int a)
Test t2(10,20);
&#x2F;&#x2F;调用有参构造函数Test(int a, int b)
return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>拷贝构造函数<ul>
<li>由己存在的对象,创建新对象。也就是说新对象,不由构造器来构造,而是由拷贝构造器来完成。拷贝构造器的格式是固定的。</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class类名
&#123;
	类名(const类名&amp; another)
	&#123;
		拷贝构造体
	&#125;
&#125;
class A&#123;
    A(const A&amp; another)&#123;
        
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>使用拷贝构造函数的几种场合</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class Test
&#123;
	public:
		Test()&#x2F;&#x2F;无参构造函数&#123;
			cout&lt;&lt;&quot;我是无参构造函数，被调用了&quot;&lt;&lt;endl;
		&#125;
		Test(int a)l&#x2F;&#x2F;带参数的构造函数&#123;
			m_a &#x3D; a;
		&#125;
		Test(const Test &amp;another_obj)&#x2F;&#x2F;拷贝构造函数&#123;
		cout&lt;&lt;&quot;我也是构造函数，我是通过另外一个对象，来初始化我自己&quot;&lt;&lt;endl;
		m_a &#x3D; another_obj.m_a;
		&#125;
		~Test()&#123;
		cout&lt;&lt;&quot;我是析构函数，自动被调用了&quot;&lt;&lt;endl;
		&#125;
		void printT()&#123;
		cout &lt;&lt; &quot;m_a &#x3D; &quot; &lt;&lt;m_a &lt;&lt;endl;
		&#125;
	private:
		int m_a;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;拷贝构造函数的第一个应用场景
int main()&#123;
	Test t2&#x3D;t1;&#x2F;&#x2F;用对象t1来初始化对象t2
	t2.printT();
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//拷贝构造函数的第二个应用场景</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    Test <span class="token function">t1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Test <span class="token function">t2</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    t2<span class="token punctuation">.</span><span class="token function">printT</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;拷贝构造函数的第三个应用场景
#include&lt;iostream&gt;
using namespace std;
class Location&#123;
    public:
    &#x2F;&#x2F;带参数的构造函数
    Location(int xx&#x3D;0,int yy&#x3D;0)&#123;
        X&#x3D;xx;
        Y&#x3D;yy;
        cout&lt;&lt;&quot;Constructor Object.&quot;&lt;&lt;endl;
    &#125;
    &#x2F;&#x2F;copy构造函数 完成对象的初始化
    Location(const Location &amp;obj)&#123;
        X&#x3D;obj.X;
        Y&#x3D;obj.Y;
        cout&lt;&lt;&quot;Copy Constructor.&quot;&lt;&lt;endl;
    &#125;
    ~Location()&#123;
        cout&lt;&lt;X&lt;&lt;&quot;,&quot;&lt;&lt;Y&lt;&lt;&quot;Obejct destroyed.&quot;&lt;&lt;endl;
    &#125;
    int GetX()&#123;
        return X;
    &#125;
    int GetY()&#123;
        return Y;
    &#125;
    
   private:
    	int X;
    	int Y;
&#125;;
void func(Location p)&#x2F;&#x2F;会执行p &#x3D; b 的操作，p会调用copy构造函数进行初始化
&#123;
    cout &lt;&lt;&quot;func begin&quot; &lt;&lt;endl;
	cout&lt;&lt;p.GetX( )&lt;&lt;endl;
	cout &lt;&lt;&quot;func end&quot; &lt;&lt;endl;
&#125;
void test()&#123;
	Location a(1,2); &#x2F;&#x2F;对象a 调用带参数的构造函数进行初始化
    Location b &#x3D; a;&#x2F;&#x2F;对象b 调用copy构造函数进行初始化
    cout &lt;&lt;&quot;----&quot; &lt;&lt;endl;
	func(b);
	&#x2F;&#x2F; b实参取初始化形参p,会调用copy构造函数
&#125;
int main(void)&#123;
	test();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class Location
&#123;
    public:
	&#x2F;&#x2F;带参数的构造函数
	Location( int xx &#x3D; 0 , int yy &#x3D; 0 )&#123;
		X&#x3D; xx ;Y &#x3D; yy ;
		cout &lt;&lt; &quot;Constructor Object.&quot; &lt;&lt;endl;
	&#125;
    &#x2F;&#x2F; copy构造函数完成对象的初始化
	Location( const Location &amp; obj) &#x2F;&#x2F; copy构造函数
    &#123;
		x &#x3D; obj.X;
        Y &#x3D; obj.Y;	
		cout &lt;&lt;&quot;Copy Constructor.&quot; &lt;&lt;endl;
	&#125;
	~Location()&#123;
		cout &lt;&lt; X &lt;&lt; &quot;,&quot; &lt;&lt; Y &lt;&lt; &quot; object destroyed.&quot; &lt;&lt; endl ;
	&#125;
	int Getx () &#123;
		return x;
	&#125;
	int GetY ) &#123;
		return Y;
	&#125;
	private :
	int X;
    int Y;
&#125;;
&#x2F;&#x2F;g函数返回一个元素
&#x2F;&#x2F;结论1 ∶函数的返回值是一个元素（复杂类型的)，返回的是一个新的匿名对象(所以会调用匿名对象类的copy构造函数)
&#x2F;&#x2F;
&#x2F;&#x2F;结论2:有关匿名对象的去和留
&#x2F;&#x2F;如果用匿名对象初始化另外一个同类型的对象，匿名对象转成有名对象
&#x2F;&#x2F;如果用匿名对象赋值给另外一个同类型的对象，匿名对象被析构
&#x2F;&#x2F;
&#x2F;&#x2F;设计编译器的大牛们:
&#x2F;&#x2F;我就给你返回一个新对象(没有名字匿名对象)
Location g()&#123;
	Location temp(1，2);
    return temp;
&#125;
void test1()&#123;
g();
&#125;
void test2()&#123;
&#x2F;&#x2F;用匿名对象初始化m 此时c++编译器直接把匿名对转成m;(扶正）从匿名转成有名字了m
&#x2F;&#x2F;就是将这个匿名对象起了名字m,他们都是同一个对象
Location m &#x3D; g();
printf(&quot;匿名对象,被扶正,不会析构掉\n&quot; );
    cout&lt;&lt;m.GetX()&lt;&lt;endl; 
&#125;
void test3()&#123;
&#x2F;&#x2F;用匿名对象赋值给m2后，匿名对象被析构
    Location m2(1，2);
	m2 &#x3D; g();
	printf(&quot;因为用匿名对象&#x3D;给m2，匿名对象,被析构\n&quot;);
    cout&lt;&lt;m2.GetX( )&lt;&lt;endl;
&#125;
int main(void)&#123;
	test1();
    test2();
    test3();
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>默认构造函数<ul>
<li>默认无参构造函数<ul>
<li>当类中没有定义构造函数时，编译器默认提供一个无参构造函数，并且其函数体为空</li>
</ul>
</li>
<li>默认拷贝构造函数<ul>
<li>当类中没有定义拷贝构造函数时，编译器默认提供一个默认拷贝构造函数，简单的进行成员变量的值复制</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="构造函数规则"><a href="#构造函数规则" class="headerlink" title="构造函数规则"></a>构造函数规则</h4><blockquote>
<p>规则:<br>1系统提供默认的拷贝构造器。一经实现,不复存在。</p>
<p>2系统提供的时等位拷贝,也就是所谓的浅浅的拷贝。</p>
<p>3要实现深拷贝,必须要自定义。</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
&#x2F;&#x2F;当类中定义了拷贝构造函数时，c++编译器不会提供无参数构造函数
&#x2F;&#x2F;当类中定义了有参数构造函数是,c++编译器不会提供无参数构造函数
&#x2F;&#x2F;在定义类时，只要你写了构造函数,则必须要用
class Test
&#123;
public:
	Test(const Test&amp; obj) &#x2F;&#x2F;copy构造函数作用:用一个对象初始化另外一个对象
    &#123;
		a &#x3D; obj.a + 100;b &#x3D; obj.b + 100;
	&#125;
#if	0
	Test()
    &#123;
	&#125;
#endif
	void printT()&#123;
	cout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot;b: &quot;&lt;&lt;b&lt;&lt; endl;&#125;
	private:
		int a;
    	int b;
&#125;;
int main( void)&#123;
	Test t1; &#x2F;&#x2F;error，没有合适的构造函数
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h4><ul>
<li>系统提供默认的拷贝构造器,一经定义不再提供。但系统提供的默认拷贝构造器是等位拷贝,也就是通常意义上的浅拷贝。如果类中包含的数据元素全部在栈上,浅拷贝也可以满足需求的。但如果堆上的数据,则会发生多次析构行为。</li>
<li><img src="http://qiniu.orangew.cn/img/20220703213915.png" alt="20220703213915" style="zoom:33%;" /></li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class Name
&#123;
	public:
		Name ( const char *myp)&#123;
		m_len &#x3D; strlen(myp);
		m_p &#x3D;(char *) malloc(m_len + 1); &#x2F;&#x2F;
   		strcpy(m_p, myp);
	&#125;
&#x2F;&#x2F; Name obj2 &#x3D; obj1;
&#x2F;&#x2F;解决方案:手工的编写拷贝构造函数使用深copy
    	Name( const Name&amp; obj1)
		&#123;
			m_len &#x3D; obj1.m_len;
			m_p &#x3D; (char * )malloc(m_len + 1);
        	strcpy(m_p,obj1.m_p);
		&#125;
		~Name()&#123;
		if (m_p !&#x3D; NULL)&#123;
			free(m_p);
            m_p &#x3D; NULL;
            m_len &#x3D; 0;
		&#125;
	&#125;
    private:
		char *m_p ;
    	int m_len;
&#125;;
&#x2F;&#x2F;对象析构的时候出现coredump
void test()&#123;
	Name obj1( &quot;abcdefg&quot; );
	Name obj2 &#x3D; obj1;&#x2F;&#x2F;C++编译器提供的默认的copy构造函数惇浅拷贝
    Name obj3(&quot;abc&quot; );
&#x2F;&#x2F;obj3 &#x3D; obj2;&#x2F;&#x2F;当执行&#x3D;操作的时候，C++编译器也是使用的默认拷贝构造函数，也是浅拷贝
&#125;
int main(void)&#123;
test();return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="构造函数初始化列表"><a href="#构造函数初始化列表" class="headerlink" title="构造函数初始化列表"></a>构造函数初始化列表</h4><ul>
<li>如果我们有一个类成员，它本身是一个类或者是一个结构，而且这个成员它只有一个带参数的构造函数，没有默认构造函数。这时要对这个类成员进行初始化，就必须调用这个类成员的带参数的构造函数，</li>
<li>如果没有初始化列表，那么他将无法完成第一步，就会报错。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class A &#123;
	public:
	A(int a) &#123;
	m_a &#x3D; a;
&#125;
	private:
	int m_a;
&#125;;
class B &#123;
    public:
	B(int b) &#123;
	m_b &#x3D; b;
&#125;
	private:
	int m_b;
	A obja; &#x2F;&#x2F;当A的对象是B类的一个成员的时候，在初始化B对象的时候，
	&#x2F;&#x2F;无法给B分配空间，因为无法初始化A类对象
&#125;;
int main( void)&#123;
A obja(10);
B objb(20) ; &#x2F;&#x2F; error,
return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class ABC&#123;
public:
	ABC( int a, int b, int c)&#123;
		this-&gt;a &#x3D; a;
        this-&gt;b &#x3D; b;
        this-&gt;c &#x3D; c;
		printf( &quot;a: %d ,b: %d , c: %d \n&quot;, a, b, c);
        printf( &quot;ABC construct ..\n&quot; );
&#125;
	~ABC()&#123;
		printf( &quot;a: %d ,b: %d , c: %d \n&quot;, a, b,c);
        printf( &quot;~ABC() ..\n&quot; );
&#125;
	private:
		int a;
    	int b;
    	int c;
&#125;;
class MyD&#123;
public:
	MyD():abc1(1,2,3),abc2(4,5,6),m(100)&#123;
	cout&lt;&lt;&quot;MyD()&quot;&lt;&lt;endl;&#125;
    ~MyD()&#123;
	cout&lt;&lt;&quot;~MyD()&quot;&lt;&lt;endl;
	&#125;
private:
	ABC abc1;
    ABC abc2;
    const int m;
&#125;;
int main()&#123;
	MyD myD;
    return 0;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>当类成员中含有一个const对象时，或者是一个引用时，他们也必须要通过成员初始化列表进行初始化，因为这两种对象要在声明后马上初始化，而在构造函数中，做的是对他们的赋值，这样是不被允许的。</li>
<li>初始化列表中的初始化顺序与声明顺序有关,与前后赋值顺序无关。</li>
</ul>
<h4 id="强化训练"><a href="#强化训练" class="headerlink" title="强化训练"></a>强化训练</h4><ul>
<li>分析下列代码构造器和析构器的执行顺序</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include	 &lt;iostream&gt;
using namespace	std;

class	ABCD
&#123;
public:
	ABCD(int	a, int	b, int	c)
	&#123;
		_a &#x3D; a;
		_b &#x3D; b;
		_c &#x3D; c;
		printf(&quot;ABCD()	construct,	a: %d,b: %d,c: %d		 \n&quot;, _a, _b, _c);
	&#125;
	~ABCD()
	&#123;
		printf(&quot;~ABCD()	construct,a: %d,b: %d,c: %d		 \n&quot;, _a, _b, _c);
	&#125;
	int	getA()
	&#123;
		return	_a;
	&#125;
private:
	int	_a;
	int	_b;
	int	_c;
&#125;;

class	MyE
&#123;
public:

	MyE() :abcd1(1, 2, 3), abcd2(4, 5, 6), m(100)
	&#123;
		cout &lt;&lt; &quot;MyE()&quot; &lt;&lt; endl;
	&#125;
	~MyE()
	&#123;
		cout &lt;&lt; &quot;~MyE()&quot; &lt;&lt; endl;
	&#125;

	MyE(const	MyE	&amp;	obj) :abcd1(7, 8, 9), abcd2(10, 11, 12), m(100)
	&#123;
		printf(&quot;MyD(const	MyD	&amp;	obj) \n&quot;);
	&#125;
public:
	ABCD	abcd1;	 &#x2F;&#x2F;c++编译器不知道如何构造abc1
	ABCD	abcd2;
	const int	m;
&#125;;

int	doThing(MyE	mye1)&#x2F;&#x2F;mye1.拷贝构造(main::myE)
&#123;
	printf(&quot;doThing()	mye1.abc1.a: %d \n&quot;, mye1.abcd1.getA());
	return 0;
&#125;
int	run()
&#123;
	MyE	myE;
	doThing(myE);
	return 0;
&#125;

int	run2()
&#123;
	printf(&quot;run2	start.. \n&quot;);
	&#x2F;&#x2F;ABCD(400, 500, 600);	 &#x2F;&#x2F;临时对象的⽣命周期		
	ABCD	abcd	&#x3D;	ABCD(100,	200,	300);
	printf(&quot;run2	end\n&quot;);
	return 0;
&#125;

int	main(void)
&#123;
	run2();
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>构造函数再调用构造函数，分析以下代码结果</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include	 &lt;iostream&gt;
using namespace	std;

&#x2F;&#x2F;构造中调⽤构造是危险的⾏为
class	MyTest
&#123;
public:
	MyTest(int	a, int	b, int	c)
	&#123;
		_a &#x3D; a;
		_b &#x3D; b;
		_c &#x3D; c;
	&#125;
	MyTest(int	a, int	b)
	&#123;
		_a &#x3D; a;
		_b &#x3D; b;
		MyTest(a, b, 100);&#x2F;&#x2F;创建一个匿名对象	
		&#x2F;&#x2F;
	&#125;
	~MyTest()
	&#123;
		printf(&quot;MyTest~: %d,	 %d,	 %d\n&quot;, _a, _b, _c);
	&#125;
	int	getC()
	&#123;
		return	_c;
	&#125;
	void	setC(int	val)
	&#123;
		_c &#x3D; val;
	&#125;

private:
	int	_a;
	int	_b;
	int	_c;
&#125;;

int	main()
&#123;
	MyTest	t1(1, 2);
	printf(&quot;c: %d\n&quot;, t1.getC());	 &#x2F;&#x2F;请问c的值是？
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="http://qiniu.orangew.cn/img/20220703221844.png" alt="20220703221844"></p>
<h3 id="对象动态建立和释放new和delete"><a href="#对象动态建立和释放new和delete" class="headerlink" title="对象动态建立和释放new和delete"></a>对象动态建立和释放new和delete</h3><ul>
<li>在软件开发过程中，常常需要动态地分配和撤销内存空间，例如对动态链表中结点的插入与删除。在C语言中是利用库函数malloc和free来分配和撤销内存空间的。C++提供了较简便而功能较强的运算符new和delete来取代malloc和free函数。</li>
<li>new和delete是运算符，不是函数，因此执行效率高。</li>
<li>虽然为了与c语言兼容，C++仍保留malloc和free函数，但建议用户不用malloc和free函数，而用new和delete运算符。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">new int;
&#x2F;&#x2F;开辟一个存放整数的存储空间，返回一个指向该存储空间的地址(即指针)
new int(100);
&#x2F;&#x2F;开辟一个存放整数的空间，并指定该整数的初值为100，返回一个指向该存储空间的地址
new char[10];
&#x2F;&#x2F;开辟一个存放字符数组(包括10个元素)的空间，返回首元素的地址
new int[5][4];
&#x2F;&#x2F;开辟一个存放二维整型数组(大小为5*4)的空间，返回首元素的地址
float *p&#x3D;new float (3.14159);
&#x2F;&#x2F;开辟一个存放单精度数的空间，并指定该实数的初值为&#x2F;&#x2F;3.14159，将返回的该空间的地址赋给指针变量p
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>​    new运算符动态分配堆内存<br>​    使用形式:</p>
<p>​    指针变量=new类型(常量) ;<br>​    指针变量=new类型[表达式];<br>​    作用:从堆分配一块“类型”大小的存储空间,返回首地址</p>
<p>​    其中:“常量”是初始化值，可缺省<br>​    创建数组对象时，不能为对象指定初始值</p>
<p>​    delete运算符释放已分配的内存空间<br>​    使用形式:<br>​    delete 指针变量﹔</p>
<p>​    delete[]指针变量﹔<br>​    其中:“指针变量”必须是一个new返回的指针</p>
</blockquote>
<ul>
<li>用new分配数组空间时不能指定初值。如果由于内存不足等原因而无法正常分配空间，则new会返回一个空指针NULL，用户可以根据该指针的值判断分配空间是否成功。</li>
</ul>
<blockquote>
<p>malloc不会调用类的构造函数,而new会调用类的构造函数</p>
<p>Free不会调用类的析构函数，而delete会调用类的析构函数</p>
</blockquote>
<h3 id="静态成员变量和成员函数"><a href="#静态成员变量和成员函数" class="headerlink" title="静态成员变量和成员函数"></a>静态成员变量和成员函数</h3><ul>
<li>在C++中,静态成员是属于整个类的而不是某个对象,静态成员变量只存储一份供所有对象共用。所以在所有对象中都可以共享它。使用静态成员变量实现多个对象之间的数据共享不会破坏隐藏的原则,保证了安全性还可以节省内存。</li>
<li>类的静态成员,属于类,也属于对象,但终归属于类。</li>
</ul>
<h4 id="静态成员变量"><a href="#静态成员变量" class="headerlink" title="静态成员变量"></a>静态成员变量</h4><blockquote>
<p>//声明<br>static数据类型成员变量; //在类的内部<br>//初始化<br>数据类型类名::静态数据成员=初值;//在类的外部<br>//调用<br>类名::静态数据成员类对象.静态数据成员</p>
</blockquote>
<blockquote>
<p>案例：生成一个Box类，要求所在Box的高度height一致</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class Box
&#123;
	public:
		Box(int 1, int w) : length( l),width(w) &#123;
		&#125;
	int volume()&#123;
		return length * width * height;
	&#125;
	static int height;
    int length;
	int width;
&#125;;
int Box::height &#x3D; 5;
int main()
&#123;
&#x2F;&#x2F;cout&lt;&lt;sizeof( Box )&lt;&lt;endl;
    &#x2F;&#x2F;Box b(2,3);
&#x2F;&#x2F;cout&lt;&lt;sizeof(b)&lt;&lt;endl;
cout&lt;&lt;Box::height&lt;&lt;endl;
Box b(1,1);
cout&lt;&lt;b.height&lt;&lt;endl;
cout&lt;&lt;b.volume( )&lt;&lt;endl;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>1,static成员变量实现了同类对象间信息共享。</p>
<p>2.static成员类外存储,求类大小,并不包含在内。</p>
<p>3.static成员是命名空间属于类的全局变量,存储在data 区。</p>
<p>4,static成员只能类外初始化。</p>
<p>5,可以通过类名访问(无对象生成时亦可),也可以通过对象访问。</p>
</blockquote>
<h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h4><blockquote>
<p>//声明<br>static函数声明<br>//调用<br>类名::函数调用</p>
<p>类对象.函数调用</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class student
&#123;
public:
Student(int n,int a,float s) :num(n),age(a),score(s)&#123;&#125;
    void total()&#123;
		count++;
		sum +&#x3D; score;
	&#125;
	static float average();
private:
	int num;
    int age;
	float score;
	static float sum;
    static int count;
&#125;;
float Student:: sum &#x3D; 0;
int Student:: count &#x3D; 0;
float Student::average() &#123;
return sum&#x2F; count;
&#125;
int main()
Sudent stu[3]&#x3D; &#123;
	Sudent(1001,14,70),
    Sudent(1002,15,34),
    Sudent(1003,16,90)&#125;;
for(int i&#x3D;0 i&lt;3; i++) &#123;
	stu[i].total();
&#125;
cout&lt;&lt;Student::average()&lt;&lt;endl;
return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>静态成员函数的意义,不在于信息共享,数据沟通,而在于管理静态数据成员，完成对静态数据成员的封装。</li>
<li>静态成员函数只能访问静态数据成员。原因:非静态成员函数,在调用时this指针被当作参数传进。而静态成员函数属于类,而不属于对象,没有 this指针。</li>
</ul>
<h3 id="编译器对属性和方法的处理机制"><a href="#编译器对属性和方法的处理机制" class="headerlink" title="编译器对属性和方法的处理机制"></a>编译器对属性和方法的处理机制</h3><h4 id="静态成员占多大"><a href="#静态成员占多大" class="headerlink" title="静态成员占多大"></a>静态成员占多大</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class c1
&#123;
	public:
	int i; &#x2F;&#x2F;4
    int j;&#x2F;&#x2F;4
    int k;l&#x2F;4
&#125;; &#x2F;&#x2F;12
class C2&#123;
	public:
		int i;
    	int j;
    	int k;
	static int m;	&#x2F;&#x2F;4
	public:
	int getk() const &#123; return k; &#125;&#x2F;&#x2F; 4
    void setk( int val) &#123;k &#x3D; val; &#125;&#x2F;&#x2F;4
&#125;;
struct s1&#123;
	int i;
    int j;
    int k;; &#x2F;&#x2F;12
struct s2&#123;
	int i;
    int j;
    int k;
	static int m;
&#125;; &#x2F;&#x2F;12?
int main()&#123;
	cout &lt;&lt; &quot;c1: &quot; &lt;&lt; sizeof(C1) &lt;&lt;endl;
    cout &lt;&lt;&quot;c1: &quot; &lt;&lt; sizeof(C2) &lt;&lt;endl;
	cout &lt;&lt;&quot;c1:&quot; &lt;&lt; sizeof(S1) &lt;&lt;endl;
	cout &lt;&lt;&quot;c1: &quot; &lt;&lt; sizeof(S2) &lt;&lt;endl;
	return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="处理机制"><a href="#处理机制" class="headerlink" title="处理机制"></a>处理机制</h4><ul>
<li>C++类对象中的成员变量和成员函数是分开存储的</li>
<li>成员变量︰<ul>
<li>普通成员变量∶存储于对象中，与struct变量有相同的内存布局和字节对齐方式</li>
<li>静态成员变量∶存储于全局数据区中</li>
</ul>
</li>
<li>成员函数:存储于代码段中。</li>
<li>C++编译器对类的成员的内部处理机制类似如下</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
&#125;
using namespace std;
class Test&#123;
    private:
    int ml;
    public:
    Test(int i):ml(i)&#123;&#125;
    int getI()&#123;
        return ml;
    &#125;
    static void Print()&#123;
        printf(&quot;This is class Test.\n&quot;);
    &#125;
&#125;;
int main()&#123;
Test a(10);
a.getI();
Test::Print();
a.Print();
&#125;

&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;
    struct Test&#123;
        int ml;
    &#125;;
	void Test_initialize(Test * pThis,int i)&#123;
        pThis-&gt;ml&#x3D;i;
    &#125;
	int Test_getI(Test*pThis)&#123;
        return pThis-&gt;ml;
    &#125;
	void Test_Print()&#123;
        printf(&quot;This is class Test.\n&quot;);
    &#125;
		Test a;
		Test_initialize(&amp;a,10);
		Test_getI(&amp;a);
		Test_Print();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>1、C++类对象中的成员变量和成员函数是分开存储的。C语言中的内存四区模型仍然有效!</p>
<p>2、C++中类的普通成员函数都隐式包含一个指向当前对象的this指针。</p>
<p>3、静态成员函数、成员变量属于类</p>
<p>4、静态成员函数与普通成员函数的区别</p>
<p>静态成员函数不包含指向具体对象的指针</p>
<p>普通成员函数包含一个指向具体对象的指针</p>
</blockquote>
<h4 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h4><ul>
<li>成员函数隐含定义this指针接受调用对象的地址</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void setXY(int a,int b)&#123;x&#x3D;a;y&#x3D;b;&#125;
void setXY(simple * const this,int a,int b)&#123;this-&gt;x&#x3D;a;this-&gt;y&#x3D;b;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class Test
&#123;
	public:
	Test(int a, int b) &#x2F;&#x2F;---&gt; Test(Test *this,int a, int b)
    &#123;
	this-&gt;a &#x3D; a;
    this-&gt; b &#x3D; b;
    &#125;
void printT()&#123;
cout&lt;&lt; &quot;a: &quot; &lt;&lt;a &lt;&lt;endl;
cout&lt;&lt; &quot;b: &quot; &lt;&lt; this-&gt;b &lt;&lt;endl;
&#125;
	protected:
    private:
	int a;
    int b;
&#125;;
int main(void)&#123;
	Test t1(1，2);&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&gt; Test(&amp;t1，1，2);
    t1.printT();&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&gt; printT(&amp;t1)
return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>(1)︰若类成员函数的形参和类的属性，名字相同，通过this指针来解决。</p>
<p>(2)︰类的成员函数可通过const修饰。</p>
</blockquote>
<h4 id="全局函数与成员函数"><a href="#全局函数与成员函数" class="headerlink" title="全局函数与成员函数"></a>全局函数与成员函数</h4><ol>
<li>把全局函数转化成成员函数，通过this指针隐藏左操作数<br><code>Test add(Test &amp;t1,Test &amp;t2)===》Test add(Test &amp;t2)</code></li>
<li>把成员函数转换成全局函数，多了一个参数<br><code>void printAB()===》void printAB(Test *pthis)</code></li>
<li>函数返回元素和返回引用</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Test&amp; add(Test &amp;t2)&#x2F;&#x2F;*this &#x2F;&#x2F;函数返回引用
&#123;
	this-&gt;a &#x3D; this-&gt;a + t2.getA();
    this-&gt;b &#x3D; this-&gt;b + t2.getB();
	return *this; &#x2F;&#x2F;*操作让this指针回到元素状态
&#125;
Test add2(Test &amp;t2)&#x2F;&#x2F;*this &#x2F;&#x2F;函数返回元素
&#123;
	&#x2F;&#x2F;t3是局部变量
	Test t3(this-&gt;a+t2.getA(),this-&gt;b+t2.getB()) ;
    return t3;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="强化练习"><a href="#强化练习" class="headerlink" title="强化练习"></a>强化练习</h3><blockquote>
<p>某商店经销一种货物。货物购进和卖出时以箱为单位，各箱的重量不一样，因此，商店需要记录目前库存的总重量。现在用C++模拟商店货物购进和卖出的情况。</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;


using namespace std;


class Goods
&#123;
public:
	Goods()
	&#123;
		weight &#x3D; 0;
		next &#x3D; NULL;
		cout &lt;&lt; &quot;创建了一个重量为&quot; &lt;&lt; weight &lt;&lt; &quot;的货物&quot; &lt;&lt; endl;
	&#125;

	Goods(int w) &#123;
		&#x2F;&#x2F;需要创建一个w的货物，并且仓库加上这个重量
		weight &#x3D; w;
		next &#x3D; NULL;
		total_weight +&#x3D; w;
		cout &lt;&lt; &quot;创建了一个重量为&quot; &lt;&lt; weight &lt;&lt; &quot;的货物&quot; &lt;&lt; endl;
	&#125;

	~Goods() &#123;
		&#x2F;&#x2F;仓库减少这个货物的重量
		cout &lt;&lt; &quot;删除了一箱重量是&quot; &lt;&lt; weight &lt;&lt; &quot;的货物&quot; &lt;&lt; endl;
		total_weight -&#x3D; weight;
	&#125;


	static int get_total_weight()
	&#123;
		return total_weight;
	&#125;

	Goods *next;
private:
	int weight;&#x2F;&#x2F;重量
	static int total_weight;&#x2F;&#x2F;仓库的总重量
&#125;;

int Goods::total_weight &#x3D; 0;


void buy(Goods * &amp;head, int w)
&#123;
	&#x2F;&#x2F;创建一个货物 重量是w
	Goods *new_goods &#x3D; new Goods(w);

	if (head &#x3D;&#x3D; NULL) &#123;
		head &#x3D; new_goods;
	&#125;
	else &#123;
		new_goods-&gt;next &#x3D; head;
		head &#x3D; new_goods;
	&#125;

&#125;

void sale(Goods * &amp;head)
&#123;
	if (head &#x3D;&#x3D; NULL) &#123;
		cout &lt;&lt; &quot;仓库中已经没有货物了。。&quot; &lt;&lt; endl;
		return;
	&#125;

	Goods *temp &#x3D; head;
	head &#x3D; head-&gt;next;

	delete temp;
	cout &lt;&lt; &quot;saled.&quot; &lt;&lt; endl;
&#125;



int main(void)
&#123;
	int choice &#x3D; 0;
	Goods *head &#x3D; NULL;
	int w;

	do &#123;
		cout &lt;&lt; &quot;1 进货&quot; &lt;&lt; endl;
		cout &lt;&lt; &quot;2 出货&quot; &lt;&lt; endl;
		cout &lt;&lt; &quot;0 退出&quot; &lt;&lt; endl;

		cin &gt;&gt; choice;
		switch (choice)
		&#123;
		case 1:
			&#x2F;&#x2F;进货
			cout &lt;&lt; &quot;请输出要创建货物的重量&quot; &lt;&lt; endl;
			cin &gt;&gt; w;
			buy(head, w);
			break;
		case 2:
			&#x2F;&#x2F;出货
			sale(head);
			break;
		case 0:
			&#x2F;&#x2F;退出
			return 0;
		default:
			break;
		&#125;

		cout &lt;&lt; &quot;当前仓库的总重量是&quot;&lt;&lt;Goods::get_total_weight() &lt;&lt; endl;

	&#125; while (1);
	
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>数组类封装<br>目标︰解决实际问题，训练构造函敬、copy构造函数等，</p>
<p>为操作符重载做准备</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;MyArray.h
#pragma once
#include &lt;iostream&gt;

using namespace std;

class MyArray
&#123;
public:
	MyArray();
	MyArray(int len);
	MyArray(const MyArray &amp;another);
	~MyArray();

	void setData(int index, int data);
	int getData(int index);
	int getLen();

	void operator&#x3D;(const MyArray&amp; another);
private:
	int len;
	int *space;
&#125;;

&#x2F;&#x2F;MyArray.c

#include &quot;MyArray.h&quot;

MyArray::MyArray()
&#123;
	cout &lt;&lt; &quot;MyArray()...&quot; &lt;&lt; endl;
	this-&gt;len &#x3D; 0;
	this-&gt;space &#x3D; NULL;
&#125;

MyArray::MyArray(int len)
&#123;
	if (len &lt;&#x3D; 0) &#123;
		this-&gt;len &#x3D; 0;
		return;
	&#125;
	else &#123;
		this-&gt;len &#x3D; len;

		&#x2F;&#x2F;给space开辟空间
		this-&gt;space &#x3D; new int[this-&gt;len];
		cout &lt;&lt; &quot;MyArray::MyArray(int len) ...&quot; &lt;&lt; endl;
	&#125;
&#125;
MyArray::MyArray(const MyArray &amp;another)
&#123;
	if (another.len &gt;&#x3D; 0) &#123;
		this-&gt;len &#x3D; another.len;

		&#x2F;&#x2F;深拷贝
		this-&gt;space &#x3D; new int[this-&gt;len];
		for (int i &#x3D; 0; i &lt; this-&gt;len; i++) &#123;
			this-&gt;space[i] &#x3D; another.space[i];
		&#125;
		cout &lt;&lt; &quot;MyArray::MyArray(const MyArray &amp;another) ...&quot; &lt;&lt; endl;

	&#125;
&#125;
MyArray::~MyArray()
&#123;
	if (this-&gt;space !&#x3D; NULL) &#123;
		delete[]this-&gt;space;
		this-&gt;space &#x3D; NULL;
		len &#x3D; 0;
		cout &lt;&lt; &quot;MyArray::~MyArray() ...&quot; &lt;&lt; endl;
	&#125;
&#125;

void MyArray::setData(int index, int data)
&#123;
	if (this-&gt;space !&#x3D; NULL) &#123;
		this-&gt;space[index] &#x3D; data;
	&#125;
&#125;
int MyArray::getData(int index)
&#123;
	return this-&gt;space[index];
&#125;
int MyArray::getLen()
&#123;
	return this-&gt;len;
&#125;

void MyArray::operator&#x3D;(const MyArray&amp; another)
&#123;
	if (another.len &gt;&#x3D; 0) &#123;
		this-&gt;len &#x3D; another.len;

		&#x2F;&#x2F;深拷贝
		this-&gt;space &#x3D; new int[this-&gt;len];
		for (int i &#x3D; 0; i &lt; this-&gt;len; i++) &#123;
			this-&gt;space[i] &#x3D; another.space[i];
		&#125;
		cout &lt;&lt; &quot;MyArray::operator&#x3D;(const MyArray&amp; another) ...&quot; &lt;&lt; endl;

	&#125;
&#125;

&#x2F;&#x2F;main.c
#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &quot;MyArray.h&quot;

using namespace std;

int main(void)
&#123;

	MyArray array1(10);&#x2F;&#x2F;开辟10元素的数组

	&#x2F;&#x2F;赋值操作
	for (int i &#x3D; 0; i &lt; 10; i++) &#123;
		array1.setData(i, i + 10);
	&#125;

	cout &lt;&lt; &quot;--------&quot; &lt;&lt; endl;

	cout &lt;&lt; &quot;array1:&quot; &lt;&lt; endl;
	for (int i &#x3D; 0; i &lt; 10; i++) &#123;
		cout &lt;&lt; array1.getData(i) &lt;&lt; &quot; &quot;;
	&#125;
	cout &lt;&lt; endl;

	MyArray array2 &#x3D; array1;
	cout &lt;&lt; &quot;array2:&quot; &lt;&lt; endl;
	for (int i &#x3D; 0; i &lt; array2.getLen(); i++) &#123;
		cout &lt;&lt; array2.getData(i) &lt;&lt; &quot; &quot;;
	&#125;
	cout &lt;&lt; endl;
	
	MyArray array3;
	array3 &#x3D; array1;


	cout &lt;&lt; &quot;array3:&quot; &lt;&lt; endl;
	for (int i &#x3D; 0; i &lt; array3.getLen(); i++) &#123;
		cout &lt;&lt; array3.getData(i) &lt;&lt; &quot; &quot;;
	&#125;
	cout &lt;&lt; endl;

	return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><ul>
<li>采用类的机制后实现了数据的隐藏与封装,类的数据成员一般定义为私有成员,成员函数一般定义为公有的,依此提供类与外界间的通信接口。但是,有时需要定义一些函数这些函数不是类的一部分,但又需要频繁地访问类的数据成员,这时可以将这些函数定义为该函数的友元函数。除了友元函数外,还有友元类,两者统称为友元。友元的作用是提高了程序的运行效率(即减少了类型检查和安全性检查等都需要时间开销),但它破坏了类的封装性和隐藏性,使得非成员函数可以访问类的私有成员。</li>
<li>友元可以是一个函数,该函数被称为友元函数;友元也可以是一个类,该类被称为友元类。</li>
<li>同类对象间无私处</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">MyString::MyString( const MyString &amp; other)&#123;
	int len &#x3D; strlen(other._str);
    this-&gt;_str &#x3D; new char[ len+1];
    strcpy(this-&gt;_str,other._str);
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>异类对象间有友元</li>
</ul>
<h4 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h4><ul>
<li>友元函数是可以直接访问类的私有成员的非成员函数。它是定义在类外的普通函数它不属于任何类,但需要在类的定义中加以声明,声明时只需在友元的名称前加上关键字friend,其格式如下:</li>
<li>friend 类型 函数名(形式参数);</li>
<li>全局函数作友元函数</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;\
#include&lt;cmath&gt;
using namespace std;
class Point&#123;
	public:
	Point( double xx, double yy)&#123;
	x &#x3D; xx;
    y &#x3D; yy;
    &#125;
	void Getxy();
	friend double Distance(Point &amp;a,Point &amp;b);
	private:
	double x,y;
&#125;;
void Point::Getxy()&#123;
cout &lt;&lt; &quot;(&quot; &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; &quot;)&quot;&lt;&lt; endl;
&#125;
double Distance(Point &amp;a，Point &amp;b)&#123;
	double dx &#x3D; a.x - b.x;
    double dy &#x3D; a.y - b.y;
return sqrt( dx*dx + dy*dy ) ;
&#125;
int main(void)
&#123;
Point p1(3.0，4.0)，p2(6.0，8.0);p1.Getxy();
p2.Getxy();
double d &#x3D; Distance(p1，p2);
cout &lt;&lt; &quot;Distance is &quot; &lt;&lt; d &lt;&lt; endl;
return 0;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>类成员函数作友元函数</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;cmath&gt;
using namespace std;
class Point;
&#x2F;&#x2F;前向声明,是一种不完全型声明,即只需提供类名(无需提供类实现)即可。仅可用于声明指针和引用。
class ManagerPoint&#123;
	public:
		double Distance(Point &amp;a，Point &amp;b);
&#125;;
class Point&#123;
	public:
		Point( double xx,double yy)&#123;
		x &#x3D; xx;y &#x3D; yy;&#125;
		void Getxy();
	friend double ManagerPgint::Distanse(Point 8a,Point &amp;b);
    private:
		double x,y;
&#125;;
void Point::Getxy()&#123;
cout &lt;&lt; “(”&lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; &quot;)&quot;&lt;&lt; endl;
&#125;
double ManagerPoint::Distance(Point &amp;a，Point &amp;b) &#123;
double dx &#x3D; a.x - b.x;
double dy &#x3D; a.y - b.y;
return sqrt( dx*dx + dy*dy);
&#125;
int main(void)&#123;
Point p1(3.0，4.0),p2(6.0，8.0);
    p1.Getxy();
	p2.Getxy();
	ManagerPoint mp;
	float d &#x3D; mp.Distance(p1,p2);
	cout &lt;&lt; &quot;Distance is &quot; &lt;&lt; d&lt;&lt; endl;
	return 0;
&#125;     <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="友元对象"><a href="#友元对象" class="headerlink" title="友元对象"></a>友元对象</h4><ul>
<li>友元类的所有成员函数都是另一个类的友元函数,都可以访问另一个类中的隐藏信息(包括私有成员和保护成员)。</li>
<li>当希望一个类可以存取另一个类的私有成员时,可以将该类声明为另一类的友元类。定义友元类的语句格式如下:</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">friend class 类名;
其中:friend 和 class是关键字,类名必须是程序中的一个已定义过的类。例如,以下语句说明类B是类A的友元类:
class A
&#123;
	public:
	friend class B;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>经过以上说明后,类B的所有成员函数都是类A的友元函数,能存取类A的私有成员和保护成员</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123;
	public:
	inline void Test()&#123;
	&#125;
    private:
	int x,y; 
    friend class B;
&#125;
class B&#123;
	public:
	inline void Test()
    	&#123;
		A a;
		printf( &quot;x&#x3D;%d , y&#x3D;%d&quot;.a.x,a.y );
		&#125;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="论友元"><a href="#论友元" class="headerlink" title="论友元"></a>论友元</h4><ul>
<li>声明位置<ul>
<li>友元声明以关键字<code>friend</code>开始,它只能出现在类定义中。因为友元不是授权类的成员,所以它不受其所在类的声明区域<code>public private</code>和<code>protected</code>的影响。通常我们选择把所有友元声明组织在一起并放在类头之后.</li>
</ul>
</li>
<li>友元的利弊<ul>
<li>友元不是类成员,但是它可以访问类中的私有成员。友元的作用在于提高程序的运行效率,但是,它破坏了类的封装性和隐藏性,使得非成员函数可以访问类的私有成员。不过,类的访问权限确实在某些应用场合显得有些呆板,从而容忍了友元这一特别语法现象。</li>
</ul>
</li>
<li>注意事项<ul>
<li>友元关系不能被继承。</li>
<li>友元关系是单向的,不具有交换性。若类B是类A的友元,类A不一定是类B的友元,要看在类中是否有相应的声明。</li>
<li>友元关系不具有传递性。若类B是类A的友元,类C是B的友元,类C不一定是类A的友元,同样要看类中是否有相应的声明。</li>
</ul>
</li>
</ul>
<h4 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h4><ul>
<li>所谓重载，就是重新赋予新的含义。函数重载就是对一个已有的函数赋予新的含义，使之实现新功能，因此，一个函数名就可以用来代表不同功能的函数，也就是”一名多用”。</li>
<li>运算符也可以重载。实际上，我们已经在不知不觉之中使用了运算符重载。例如，大家都已习惯于用加法运算符”+”对整数、单精度数和双精度数进行加法运算，如5+8，5.8+3.67等，其实计算机对整数、单精度数和双精度数的加法操作过程是很不相同的，但由于C++已经对运算符”+”进行了重载，所以就能适用于int, float, doUble类型的运算。</li>
<li>又如”&lt;&lt;”是C++的位运算中的位移运算符（左移)，但在输出操作中又是与流对象cout配合使用的流插入运算符，”&gt;&gt;“也是位移运算符(右移），但在输入操作中又是与流对象cin配合使用的流提取运算符。这就是运算符重载<br>(operator overloading)。C++系统对”&lt;&lt;“和”&gt;&gt;“进行了重载，用户在不同的场合下使用它们时，作用是不同的。对”&lt;&lt;“和”&gt;&gt;“的重载处理是放在头文件stream中的。因此，如果要在程序中用”&lt;&lt;”和”&gt;&gt;”作流插入运算符和流提取运算符，必须在本文件模块中包含头文件stream(当然还应当包括”using namespace std”)。现在要讨论的问题是∶用户能否根据自己的需要对C++已提供的运算符进行重载，赋予它们新的含义，使之一名多用.</li>
<li>运算符重载的本质是函数重载。</li>
<li>重载函数的一般格式如下:</li>
</ul>
<blockquote>
<p>函数类型 operator 运算符名称(形参表列){<br>重载实体;<br>}</p>
</blockquote>
<ul>
<li>operator 运算符名称在一起构成了新的函数名。比如</li>
<li><code>const Complex operator+( const Complex &amp;c1,const Complex &amp;c2);</code></li>
<li>我们会说,operator+重载了重载了运算符+。</li>
</ul>
<h4 id="友元重载"><a href="#友元重载" class="headerlink" title="友元重载"></a>友元重载</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class Complex
&#123;
	public:
	Complex(float x&#x3D;0，float y&#x3D;0) :_x(x),_y(y)&#123;&#125;
	void dis() &#123;
	cout&lt;&lt;&quot; ( &quot;&lt;&lt;_x&lt;&lt;&quot; , &quot;&lt;&lt;_y&lt;&lt; &quot;)&quot;&lt;&lt;endl;
&#125;
friend const Complex operator+(const Complex &amp;c1,const Complex &amp;c2);
    	private:
	float _x;
    float _y;
&#125;;
const Complex operator+(const Complex &amp;c1,const Complex &amp;c2) &#123;
return Complex(c1._x + c2._x,c1._y + c2._y);
&#125;
int main() &#123;
	complex c1(2,3);
    complex c2(3,4);
	c1.dis();
    c2.dis();
	complex c3 &#x3D; c1+c2;
&#x2F;&#x2F; Complex c3 &#x3D; operator+(c1,c2);
    c3.dis();
return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="成员重载"><a href="#成员重载" class="headerlink" title="成员重载"></a>成员重载</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class Complex
&#123;
	public:
	Complex( float x&#x3D;0,float y&#x3D;0):_x(×),_y(y)&#123;&#125;
    void dis() &#123;
	cout&lt;&lt;&quot;(&quot;&lt;&lt;_x&lt;&lt;&quot; ,&quot;&lt;&lt;_y&lt;&lt;&quot;)&quot;&lt;&lt;endl;
	&#125;
	friend const Complex operator+(const Complex &amp;c1,const Complex &amp;c2);
	const complex operator+( const Complex &amp;another);
	private:
	float _x;
    float _y ;
&#125;;
	const Complex operator+(const Complex &amp;c1,const Complex &amp;c2)&#123;
	cout&lt;&lt;&quot;友元函数重载&quot;&lt;&lt;endl;
	return Complex(c1._x +c2._x,c1._y + c2._y);
&#125;
	const Complex Complex::operator+( const Complex &amp; another)&#123;
	cout&lt;&lt;&quot;成员函数重载&quot;&lt;&lt;endl;
	return Complex(this-&gt;_x + another._x,this-&gt;_y + another._y);
&#125;
int main( )&#123;
	complex c1(2,3);
    complex c2(3,4);
    c1.dis();
	c2.dis();
    &#x2F;&#x2F; Complex c3 &#x3D; c1+c2;
	&#x2F;&#x2F; complex c3 &#x3D; operator+(c1,c2);complex c3 &#x3D; c1+c2;
	c3.dis();
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="重载规则"><a href="#重载规则" class="headerlink" title="重载规则"></a>重载规则</h4><ol>
<li><p>C++不允许用户自己定义新的运算符,只能对已有的C++运算符进行重载。</p>
</li>
<li><p>C+＋允许重载的运算符</p>
<blockquote>
<p>new new[] delete delete[] + - * / % ^ &amp; | ~ ! = &lt;  &gt;  += -=  *= /= %=</p>
<p>^= &amp;= |= &lt;&lt; &gt;&gt; &lt;&lt;= &gt;&gt;= == != &lt;= &gt;= &amp;&amp; || ++ – , -&gt;* -&gt; () []</p>
</blockquote>
</li>
</ol>
<ul>
<li><p>不能重载的运算符只有五个。</p>
<blockquote>
<p>? :    .    ::   sizeof   .* </p>
</blockquote>
</li>
</ul>
<ol start="3">
<li>重载不能改变运算符运算对象(即操作数)的个数。<ul>
<li>如,关系运算符“&gt;”和“&lt;”等是双目运算符,重载后仍为双目运算符,需要两个参数。运算符”+“,”-“，”*“,”&amp;“等既可以作为单目运算符,也可以作为双目运算符,可以分别将它们重载为单目运算符或双目运算符。</li>
</ul>
</li>
<li>重载不能改变运算符的优先级别。<ul>
<li>例如”*“和”/“优先级高于”＋“和”-“,不论怎样进行重载,各运算符之间的优先级不会改变。有时在程序中希望改变某运算符的优先级,也只能使用加括号的方法强制改变重载运算符的运算顺序。</li>
</ul>
</li>
<li>重载不能改变运算符的结合性。<ul>
<li>如,复制运算符”=“是右结合性(自右至左),重载后仍为右结合性。</li>
</ul>
</li>
<li>重载运算符的函数不能有默认的参数<ul>
<li>重载运算符的函数不能有默认的参数</li>
</ul>
</li>
<li>重载的运算符必须和用户定义的自定义类型的对象一起使用,其参数至少应有一个是类对象(或类对象的引用)。<ul>
<li>也就是说,参数不能全部是C++的标准类型,以防止用户修改用于标准类型数据成员的运算符的性质,如下面这样是不对的:</li>
<li>代码如下:</li>
<li><code>int operator + (int a,int b)&#123;return(a-b); &#125;</code></li>
<li>原来运算符+的作用是对两个数相加,现在企图通过重载使它的作用改为两个数相减。如果允许这样重载的话,如果有表达式4+3,它的结果是7还是1呢?显然,这是绝对要禁止的。</li>
</ul>
</li>
<li>用于类对象的运算符一般必须重载,但有两个例外,运算符”=“和运算符”&amp;“不必用户重载。<ul>
<li>复制运算符”=“可以用于每一个类对象,可以用它在同类对象之间相互赋值。因为系统已为每一个新声明的类重载了一个赋值运算符,它的作用是逐个复制类中的数据成员地址运算符&amp;也不必重载,它能返回类对象在内存中的起始地址。</li>
</ul>
</li>
<li>应当使重载运算符的功能类似于该运算符作用于标准类型数据时候时所实现的功能。</li>
<li>运算符重载函数可以是类的成员函数,也可以是类的友元函数,还可以是既非类的成员函数也不是友元函数的普通函数</li>
</ol>
<h4 id="双目运算符重载"><a href="#双目运算符重载" class="headerlink" title="双目运算符重载"></a>双目运算符重载</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class Complex
&#123;
public:
	Complex(float x&#x3D;0,float y&#x3D;0) :_x(x),_y(y)&#123;&#125;
void dis()
&#123;
cout&lt;&lt;&quot;(&quot;&lt;&lt;_x&lt;&lt;&quot;, &quot;&lt;&lt;_y&lt;&lt;&quot; )&quot;&lt;&lt;endl;
&#125;
Complex&amp; operator+&#x3D;( const Complex &amp;c)
&#123;
this-&gt;_x+&#x3D; c._x; this-&gt;_y +&#x3D; c._y ;
    return *this;
&#125;
private:
	float _x;
	float _y;
&#125;;
int main()&#123;
	&#x2F;&#x2F; int a&#x3D;10,b&#x3D;20,c&#x3D;30;
    &#x2F;&#x2F; a+&#x3D;b;
	&#x2F;&#x2F;b+&#x3D;C;
    &#x2F;&#x2F;cout&lt;&lt;&quot;a &#x3D; &quot;&lt;&lt;a&lt;&lt;endl;
    &#x2F;&#x2F; cout&lt;&lt;&quot;b &#x3D; &quot;&lt;&lt;b&lt;&lt;endl;
    &#x2F;&#x2F; cout&lt;&lt;&quot;c &#x3D; &quot;&lt;&lt;c&lt;&lt;endl;
    &#x2F;&#x2F;complex a1( 10,0),b1(20,0), c1(30,0);
    &#x2F;&#x2F;此时的+&#x3D;重载函数返回void
    &#x2F;&#x2F; a1 +&#x3D; b1;
    &#x2F;&#x2F; b1 +&#x3D; c1;l &#x2F; a1.dis();&#x2F;&#x2F; b1.dis();&#x2F; c1.dis();
    &#x2F;&#x2F; --------------------
    &#x2F;&#x2F;int a&#x3D;10, b&#x3D;20,c&#x3D;30;
    &#x2F;&#x2F;a+&#x3D;b+&#x3D;c;
    &#x2F;&#x2F;cout&lt;&lt;&quot;a &#x3D; &quot;&lt;&lt;a&lt;&lt;endl;
    &#x2F;&#x2F; cout&lt;&lt;&quot;b &#x3D; &quot;&lt;b&lt;&lt;endl;
    &#x2F;&#x2F; cout&lt;&lt; &quot;c &#x3D; &quot;&lt;&lt;c&lt;&lt;endl;
    &#x2F;&#x2F; complex a1(10,0),b1(20,0), c1(30,0);
    &#x2F;&#x2F;此时重载函数+&#x3D;返回的是Complex 
    &#x2F;&#x2F; a1+&#x3D;b1+&#x3D;c1;
    &#x2F;&#x2F; a1.dis();
    &#x2F;&#x2F; b1.dis();
    &#x2F;&#x2F; c1.dis();
    &#x2F;&#x2F; -------------------------------
    int a &#x3D; 10, b &#x3D; 20,c &#x3D; 30;
    (a +&#x3D; b) +&#x3D; c;
    cout&lt;&lt;&quot;a &#x3D; &quot;&lt;&lt;a&lt;&lt;endl;
    cout&lt;&lt;&quot;b &#x3D; &quot;&lt;&lt;b&lt;&lt;endl;
    cout&lt;&lt;&quot;c &#x3D; &quot;&lt;&lt;c&lt;&lt;endl;
    Complex a1(10,0),b1(20,0), c1(30,0);
    &#x2F;&#x2F;此时重载函数+&#x3D;返回的是Complex &amp;
    &#x2F;&#x2F;一定要注意在连等式中,返回引用和返回对象的区别
    (a1 +&#x3D; b1) +&#x3D; c1;
	a1.dis();
	b1.dis();
    c1.dis();
    return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="单目运算符重载"><a href="#单目运算符重载" class="headerlink" title="单目运算符重载"></a>单目运算符重载</h4><ul>
<li>不可以被重载的操作符</li>
</ul>
<blockquote>
<p>.    .*   ::   ?:</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;前++
#include &lt;iostream&gt;
using namespace std;
class Complex
&#123;
	public:
	Complex(float x&#x3D;0,float y&#x3D;0):_x(x),_y(y)&#123;&#125;
	void dis()
    &#123;
	cout&lt;&lt;&quot;( &quot;&lt;&lt;_x&lt;&lt;&quot;, &quot;&lt;&lt;_y&lt;&lt;&quot;)&quot;&lt;&lt;endl;
    &#125;
	friend Complex &amp; operator++(Complex&amp; c);
    private:
		float _x;
    	float _y;
&#125;;
	Complex &amp; operator++(Complex&amp; c)&#123;
		c._x++;
       	c._y++;
		return c;
&#125;
int main()
&#123;
	int n &#x3D; 10;
	cout&lt;&lt;n&lt;&lt;endl;&#x2F;&#x2F;10
    cout&lt;&lt;++n&lt;&lt;endl;&#x2F;&#x2F;11
	cout&lt;&lt;n&lt;&lt;endl;&#x2F;&#x2F;11
	cout&lt;&lt;++++n&lt;&lt;endl;&#x2F;&#x2F;13
    cout&lt;&lt;n&lt;&lt;endl;
	
	Complex c( 10,10);
    	c.dis();&#x2F;&#x2F;10 10
	Complex c2&#x3D;++c;
	c2.dis( );	&#x2F;&#x2F;11 11
	c.dis();&#x2F;&#x2F;11 11
	c2 &#x3D; ++++c;
	c2.dis();&#x2F;&#x2F;13 13
	c.dis();&#x2F;&#x2F;13 13
return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;后++
#include &lt;iostream&gt;
using namespace std;
class Complex&#123;
public:
Complex(float x&#x3D;0,float y&#x3D;0):_x(x),_y(y)&#123;&#125;
void dis()
&#123;
cout&lt;&lt;&quot;( &quot;&lt;&lt;_x&lt;&lt;&quot;, &quot;&lt;&lt;_y&lt;&lt;&quot;) &quot;&lt;&lt;endl;
&#125;
#if 0
const Complex operator++(int)&#123;
	Complex t &#x3D; *this;
    _x++;
    _y++;
return t;
&#125;
#endif
	friend const Complex operator++(Complex &amp;c ,int);
    private:
	float _x;
    float y ;
&#125;;
const Complex operator++(Complex &amp;c,int)
	Complex t(c._x,c._y); 
	c._x++;
	c._y++;
	return t;
&#125;
int main()&#123;
	int n &#x3D; 10;
    cout&lt;&lt;n&lt;&lt;endl;
&#x2F;&#x2F;10
	cout&lt;&lt;n++&lt;&lt;endl;
&#x2F;&#x2F;10
	cout&lt;&lt;n&lt;&lt;endl;
&#x2F;&#x2F;11
&#x2F;&#x2F;cout&lt;&lt;n++++&lt;&lt;endl;&#x2F;&#x2F;13后++表达式不能连用
    cout&lt;&lt;n&lt;&lt;endl; &#x2F;&#x2F;11
	Complex c(10);
	c.dis();
	Complex c2 &#x3D;C++;
    c2.dis();
	c.dis();
&#x2F;&#x2F;c2 &#x3D; C++十+;&#x2F;&#x2F; c2.dis();
    c.dis();
return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="输入输出运算符重载"><a href="#输入输出运算符重载" class="headerlink" title="输入输出运算符重载"></a>输入输出运算符重载</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">istream &amp; operator&gt;&gt;(istream &amp;,自定义类&amp;);
ostream &amp; operator&lt;&lt;(ostream &amp;,自定义类&amp;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li>通过友元函数来实现，避免修改C++的标准库</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class Complex &#123;
public:
	Complex(float x&#x3D;0，float y&#x3D;0):_×(×),_y(y)&#123;&#125;
	void dis() &#123;
	cout&lt;&lt; &quot; ( &quot;&lt;&lt;_x&lt;&lt;&quot; , &quot;&lt;&lt;_y&lt;&lt;&quot;) &quot;&lt;&lt;endl;&#125;
	friend ostream &amp; operator&lt;&lt;(ostream &amp;os, const Complex &amp; c);
    friend istream &amp; operator&gt;&gt;(istream &amp;is，Complex &amp;c);
private:
	float _x;
    float _y;&#125;;
ostream &amp; operator&lt;&lt;(ostream &amp;os,const Complex &amp; c)
&#123;
	os&lt;&lt;&quot;( &quot;&lt;&lt;c._x&lt;&lt;&quot;,&quot;&lt;&lt;c._y&lt;&lt;&quot;)&quot;;
    return os;
&#125;
istream &amp; operator&gt;&gt;(istream &amp;is, Complex &amp;c)&#123;
is&gt;&gt;c._x&gt;&gt;c._y;
    return is;
&#125;
int main()&#123;
	Complex c(2,3);
    cout&lt;&lt;c&lt;&lt;endl;cin&gt;&gt;c;
	cout&lt;&lt;c&lt;&lt;endl;
	return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="友元还是成员"><a href="#友元还是成员" class="headerlink" title="友元还是成员"></a>友元还是成员</h4><ul>
<li>假设,我们有类Sender类和Mail类,实现发送邮件的功能。sender&lt;&lt; mail;</li>
<li>sender左操作数,决定了operator&lt;&lt;为Sender的成员函数,而mail决定了operator&lt;&lt;要作Mail类的友员。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class Mail;
class Sender&#123;
	public:
	Sender(string s):_addr(s)&#123;&#125;
	Sender&amp; operator&lt;&lt;( const Mail &amp; mail);&#x2F;&#x2F;成员
	private:
	string _addr;
&#125;;
class Maili&#123;
	public:
Mail(string _t,string _c ):_title(_t),_content(_c)&#123;&#125;
    friend Sender&amp; Sender::operator&lt;&lt;(const Mail &amp; mail);
    private:
	string _title;
    string _content;&#125;;
Sender&amp; Sender::operator&lt;&lt; ( const Mail &amp; mail)
cout&lt;&lt; &quot;Address: &quot;&lt;&lt;_addr&lt;&lt;endl;
cout&lt;&lt;&quot;Title : &quot;&lt;&lt;mail._title&lt;&lt;endl;
cout&lt;&lt;&quot;Content: &quot;&lt;&lt;mail._content&lt;&lt;endl;
return *this;
&#125;
int main( )
Sender sender( &quot;danbing_at@gmail.com&quot; );
Mail mail( &quot;note&quot; , &quot;meeting at 3:00 pm&quot; ) ;
Mail mail2( &quot;tour&quot; , &quot;One night in beijing&quot; );
sender&lt;&lt;mail&lt;&lt;mail2;
return 0;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>结论:<br>1,一个操作符的左右操作数不一定是相同类型的对象,这就涉及到将该操作符函数定义为谁的友元,谁的成员问题。<br>2,一个操作符函数,被声明为哪个类的成员,取决于该函数的调用对象(通常是左操作数)。<br>3,一个操作符函数,被声明为哪个类的友员,取决于该函数的参数对象(通常是右操作数)。</p>
</blockquote>
<h4 id="运算符重载提高"><a href="#运算符重载提高" class="headerlink" title="运算符重载提高"></a>运算符重载提高</h4><ol>
<li>赋值运算符重载（operator=)<ul>
<li>用一个己有对象,给另外一个己有对象赋值。两个对象均己创建结束后,发生的赋值行为。</li>
</ul>
</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">类名&#123;
	类名&amp; operator&#x3D;(const 类名&amp; 源对象）拷贝体
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123;
	A&amp; operator&#x3D;( const A&amp; another)&#123;
		&#x2F;&#x2F;函数体
		return *this;
	&#125;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>规则<br>1系统提供默认的赋值运算符重载,一经实现,不复存在。</p>
<p>2系统提供的也是等位拷贝,也就浅拷贝,一个内存泄漏,重析构。</p>
<p>3要实再深深的赋值,必须自定义。</p>
<p>4自定义面临的问题有三个:</p>
<p>​        1,自赋值</p>
<p>​        2,内存泄漏</p>
<p>​        3,重析构。</p>
<p>5返回引用,且不能用const 修饰。其目的是实现连等式。</p>
</blockquote>
<ol start="2">
<li>数组下标运算符（operator[]）</li>
</ol>
<blockquote>
<p>类型 类   : :  operator[] (  类 型  ) ;</p>
</blockquote>
<blockquote>
<p>设×是类×的一个对象，则表达式<br>x [ y ]可被解释为x. operator [] ( y )</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int &amp; operator[](int i)&#123;return v[i];&#125;&#x2F;&#x2F;返回元素的引用 this-&gt;v[i]
a[2]&#x3D;12;&#x2F;&#x2F;返回引用的函数调用作左值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<blockquote>
<p>自定义一个数组类要有&lt;&lt; &gt;&gt;操作符重载</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;MyArray.h
#pragma once
#include &lt;iostream&gt;

using namespace std;

class MyArray
&#123;
public:
	MyArray();
	MyArray(int len);
	MyArray(const MyArray &amp;another);
	~MyArray();

	void setData(int index, int data);
	int getData(int index);
	int getLen() const ;

	MyArray&amp; operator&#x3D;(const MyArray&amp; another);

	int &amp; operator[](int index) const;

	friend ostream &amp;operator&lt;&lt;(ostream &amp;os,const MyArray &amp;array);
	friend istream &amp;operator&gt;&gt;(istream &amp;is, MyArray &amp;array);

	friend bool operator&#x3D;&#x3D;(MyArray &amp;array1, MyArray &amp;array2);
	bool operator!&#x3D;(MyArray &amp;another);
private:
	int len;
	int *space;
&#125;;

&#x2F;&#x2F;MyArray.cpp
#include &quot;MyArray.h&quot;


MyArray::MyArray()
&#123;
	cout &lt;&lt; &quot;MyArray()...&quot; &lt;&lt; endl;
	this-&gt;len &#x3D; 0;
	this-&gt;space &#x3D; NULL;
&#125;

MyArray::MyArray(int len)
&#123;
	if (len &lt;&#x3D; 0) &#123;
		this-&gt;len &#x3D; 0;
		return;
	&#125;
	else &#123;
		this-&gt;len &#x3D; len;

		&#x2F;&#x2F;给space开辟空间
		this-&gt;space &#x3D; new int[this-&gt;len];
		cout &lt;&lt; &quot;MyArray::MyArray(int len) ...&quot; &lt;&lt; endl;
	&#125;
&#125;
MyArray::MyArray(const MyArray &amp;another)
&#123;
	if (another.len &gt;&#x3D; 0) &#123;
		this-&gt;len &#x3D; another.len;

		&#x2F;&#x2F;深拷贝
		this-&gt;space &#x3D; new int[this-&gt;len];
		for (int i &#x3D; 0; i &lt; this-&gt;len; i++) &#123;
			this-&gt;space[i] &#x3D; another.space[i];
		&#125;
		cout &lt;&lt; &quot;MyArray::MyArray(const MyArray &amp;another) ...&quot; &lt;&lt; endl;

	&#125;
&#125;
MyArray::~MyArray()
&#123;
	if (this-&gt;space !&#x3D; NULL) &#123;
		delete[]this-&gt;space;
		this-&gt;space &#x3D; NULL;
		len &#x3D; 0;
		cout &lt;&lt; &quot;MyArray::~MyArray() ...&quot; &lt;&lt; endl;
	&#125;
&#125;

void MyArray::setData(int index, int data)
&#123;
	if (this-&gt;space !&#x3D; NULL) &#123;
		this-&gt;space[index] &#x3D; data;
	&#125;
&#125;
int MyArray::getData(int index)
&#123;
	return this-&gt;space[index];
&#125;
int MyArray::getLen() const
&#123;
	return this-&gt;len;
&#125;

MyArray&amp;  MyArray::operator&#x3D;(const MyArray&amp; another)
&#123;
	if (this &#x3D;&#x3D; &amp;another) &#123;
		return *this;
	&#125;

	if (this-&gt;space !&#x3D; NULL) &#123;
		delete[]this-&gt;space;
		this-&gt;space &#x3D; NULL; 
		this-&gt;len &#x3D; 0;
	&#125;

	if (another.len &gt;&#x3D; 0) &#123;
		this-&gt;len &#x3D; another.len;

		&#x2F;&#x2F;深拷贝
		this-&gt;space &#x3D; new int[this-&gt;len];
		for (int i &#x3D; 0; i &lt; this-&gt;len; i++) &#123;
			this-&gt;space[i] &#x3D; another.space[i];
		&#125;
		cout &lt;&lt; &quot;MyArray::operator&#x3D;(const MyArray&amp; another) ...&quot; &lt;&lt; endl;

	&#125;

	return *this;
&#125;

int &amp; MyArray::operator[](int index) const
&#123;
	return this-&gt;space[index];
&#125;


ostream &amp;operator&lt;&lt;(ostream &amp;os,const MyArray &amp;array)
&#123;
	os &lt;&lt; &quot;遍历整个数组 &quot; &lt;&lt; endl;
	&#x2F;&#x2F;array.getLen(); &#x2F;&#x2F;getLen(&amp;array);
	for (int i &#x3D; 0; i &lt; array.getLen(); i++) &#123;
		os &lt;&lt; array[i] &lt;&lt;&quot; &quot;;&#x2F;&#x2F;array.operator[]( i)
	&#125;

	os &lt;&lt; &quot;调用的&lt;&lt;操作符重载&quot; &lt;&lt; endl;

	return os;
&#125;

istream &amp;operator&gt;&gt;(istream &amp;is, MyArray &amp;array)
&#123;
	cout &lt;&lt; &quot;请输入&quot; &lt;&lt; array.getLen() &lt;&lt; &quot;个数&quot; &lt;&lt; endl;
	for (int i &#x3D; 0; i &lt; array.getLen(); i++) &#123;
		cin &gt;&gt; array[i];
	&#125;
	return is;
&#125;


bool operator&#x3D;&#x3D;(MyArray &amp;array1, MyArray &amp;array2)
&#123;
	if (array1.len !&#x3D; array2.len) &#123;
		return false;
	&#125;

	for (int i &#x3D; 0; i &lt; array1.len; i++) &#123;
		if (array1.space[i] !&#x3D; array2.space[i]) &#123;
			return false;
		&#125;
	&#125;

	return true;
&#125;
bool MyArray::operator!&#x3D;(MyArray &amp;another)
&#123;
	return !(*this &#x3D;&#x3D; another);
&#125;

&#x2F;&#x2F;main.cpp
#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &quot;MyArray.h&quot;

using namespace std;



int main(void)
&#123;

 MyArray array1(10);&#x2F;&#x2F;开辟10元素的数组

	&#x2F;&#x2F;赋值操作
	for (int i &#x3D; 0; i &lt; 10; i++) &#123;
		&#x2F;&#x2F;array1.setData(i, i + 10);
		array1[i] &#x3D; i + 10;&#x2F;&#x2F;space[1] &#x3D; 1+10
	&#125;

	cout &lt;&lt; &quot;--------&quot; &lt;&lt; endl;

	cout &lt;&lt; &quot;array1:&quot; &lt;&lt; endl;
	for (int i &#x3D; 0; i &lt; 10; i++) &#123;
		cout &lt;&lt; array1[i] &lt;&lt; &quot; &quot;;
	&#125;
	cout &lt;&lt; endl;

	MyArray array2 &#x3D; array1;
	cout &lt;&lt; &quot;array2:&quot; &lt;&lt; endl;
	for (int i &#x3D; 0; i &lt; array2.getLen(); i++) &#123;
		cout &lt;&lt; array2[i] &lt;&lt; &quot; &quot;;
	&#125;
	cout &lt;&lt; endl;
	

	cout &lt;&lt; &quot; ------------&quot; &lt;&lt; endl;
	MyArray array3(5);

	cin &gt;&gt; array3;


	cout &lt;&lt; &quot;array3:&quot; &lt;&lt; endl;
	cout &lt;&lt; array3 &lt;&lt; endl;
	cout &lt;&lt; endl;

	
	if (array3 !&#x3D; array1)  &#123;
		cout &lt;&lt; &quot;不相等&quot; &lt;&lt; endl;
	&#125;
	else &#123;
		cout &lt;&lt; &quot;相等 &quot; &lt;&lt; endl;
	&#125;

	return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>




<ol start="3">
<li>函数调用符号（operator())<ul>
<li>把类对象像函数名一样使用。</li>
<li>仿函数(functor),就是使一个类的使用看上去象一个函数。其实现就是类中实现一个operator(),这个类就有了类似函数的行为,就是一个仿函数类了。</li>
</ul>
</li>
</ol>
<blockquote>
<p>class类名{<br>返值类型 operator()(参数类型)  函数体<br>}</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class Sqr
&#123;
	public:
		int operator()(int i)&#123;
			return i*i;
		&#125;
		double operator ()(double d)&#123;
			return d*d;
		&#125;
&#125;;
int main()&#123;
	Sqr sqr;
	int i &#x3D; sqr(4);
	double d &#x3D; sqr(5.5);
	cout&lt;&lt;i&lt;&lt;endl;
	cout&lt;&lt;d&lt;&lt;endl;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol start="4">
<li>不可重载&amp;&amp;和||操作符</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class Test&#123;
	public:
	Test( int i &#x3D; 0)&#123;
	this-&gt;i &#x3D; i;
	&#125;
	Test operator+ ( const Test&amp; obj)&#123;
		cout&lt;&lt;&quot;执行+号重载函数&quot;&lt;&lt;endl;
        Test ret;
		ret.i &#x3D; i + obj.i;
        return ret;
&#125;
	bool operator&amp;&amp;( const Test&amp; obj)&#123;
		cout&lt;&lt;&quot;执行&amp;&amp;重载函数&quot;&lt;&lt;endl;
        return i &amp;&amp; obj.i;
&#125;
	private:
    int i;
&#125;;
int main()&#123;
	int a1 &#x3D; 0;
    int a2 &#x3D; 1;
	cout&lt;&lt;&quot;注意:&amp;&amp;操作符的结合顺序是从左向右&quot;&lt;&lt;endl;
    if( a1 &amp;&amp; (a1 + a2) )
    &#123;
	cout&lt;&lt;&quot;有一个是假，则不在执行下一个表达式的计算&quot;&lt;&lt;endl;
	&#125;
	Test t1(0);
    Test t2(1);
	if ( t1 &amp;&amp;(t1 + t2) )&#123;
&#x2F;&#x2F;t1 &amp;&amp; t1.operator(t2)
&#x2F;&#x2F; t1.operator&amp;&amp;(t1.operator+(t2))
	cout&lt;&lt;&quot;两个函数都被执行了，而且是先执行了+&quot;&lt;&lt;endl;
&#125;
return 0
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>C+＋如果重载&amp;&amp;或||将无法实现短路规则</p>
</blockquote>
<blockquote>
<p>实现一个字符串类</p>
<p>构造函数要求：</p>
<p>MyString a;</p>
<p>MyString a(“dddd”);</p>
<p>MyString b = a;</p>
<p>常用的操作符</p>
<p>&lt;&lt;    &gt;&gt;   !=    ==   &gt;  &lt;=  []</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;MyString.h
#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
using namespace std;

class MyString
&#123;
public:
	MyString();
	&#x2F;&#x2F;MyString(int len); &#x2F;&#x2F;创建一个长度是len的string对象
	MyString(const char *str);
	MyString(const MyString &amp;another);
	~MyString();

	&#x2F;&#x2F;重载操作符[]
	char &amp;operator[](int index);



	&#x2F;&#x2F;重载操作符&gt;&gt;
	friend istream &amp; operator&gt;&gt;(istream &amp;is, MyString &amp;s);

	&#x2F;&#x2F;重载&#x3D;操作符
	MyString &amp; operator&#x3D;(const MyString &amp;another);

	&#x2F;&#x2F;重载&#x3D;&#x3D;操作符

	&#x2F;&#x2F;重载!&#x3D;操作符


	&#x2F;&#x2F;重载+操作符
	MyString operator+(MyString &amp;another);


	&#x2F;&#x2F;重载操作符&lt;&lt;
	friend ostream &amp; operator&lt;&lt;(ostream &amp;os, MyString&amp;s);

private:
	int len;
	char *str;
&#125;;

&#x2F;&#x2F;MyString.cpp
#include &quot;MyString.h&quot;


MyString::MyString()
&#123;
	this-&gt;len &#x3D; 0;
	this-&gt;str &#x3D;NULL;
&#125;

MyString::MyString(const char *str)
&#123;
	if (str &#x3D;&#x3D; NULL) &#123;
		this-&gt;len &#x3D; 0;
		this-&gt;str &#x3D; new char[0 + 1];
		strcpy(this-&gt;str, &quot;&quot;);
	&#125;
	else &#123;
		int len &#x3D; strlen(str);
		this-&gt;len &#x3D; len;

		this-&gt;str &#x3D; new char[len + 1];
		strcpy(this-&gt;str, str);
	&#125;
&#125;

&#x2F;&#x2F;初始化时候被调用的
MyString::MyString(const MyString &amp;another)
&#123;
	this-&gt;len &#x3D; another.len;
	this-&gt;str &#x3D; new char[this-&gt;len + 1];
	strcpy(this-&gt;str, another.str);
&#125;



MyString::~MyString()
&#123;
	if (this-&gt;str !&#x3D; NULL) &#123;
		cout &lt;&lt; this-&gt;str &lt;&lt; &quot;执行了析构函数&quot; &lt;&lt; endl;
		delete this-&gt;str;
		this-&gt;str &#x3D; NULL; 
		this-&gt;len &#x3D; 0;
	&#125;
&#125;

char &amp; MyString::operator[](int index)
&#123;
	return this-&gt;str[index];
&#125;

MyString &amp;  MyString::operator&#x3D;(const MyString &amp;another)
&#123;
	if (this &#x3D;&#x3D; &amp;another) &#123;
		return *this;
	&#125;

	if (this-&gt;str !&#x3D; NULL) &#123;
		delete[] this-&gt;str;
		this-&gt;str &#x3D; NULL;
		this-&gt;len &#x3D; 0;
	&#125;

	this-&gt;len &#x3D; another.len;
	this-&gt;str &#x3D; new char[this-&gt;len + 1];
	strcpy(this-&gt;str, another.str);

	return *this;
&#125;

ostream &amp; operator&lt;&lt;(ostream &amp;os, MyString&amp;s)
&#123;
	os &lt;&lt; s.str;
	return os;
&#125;

istream &amp; operator&gt;&gt;(istream &amp;is, MyString &amp;s)
&#123;
	&#x2F;&#x2F;1 将s之前的字符串释放掉
	if (s.str !&#x3D; NULL) &#123;
		delete[] s.str;
		s.str &#x3D; NULL;
		s.len &#x3D; 0;
	&#125;

	&#x2F;&#x2F;2 通过cin添加新的字符串
	char temp_str[4096] &#x3D; &#123; 0 &#125;;
	cin &gt;&gt; temp_str;

	int len &#x3D; strlen(temp_str);
	s.str &#x3D; new char[len + 1];
	strcpy(s.str, temp_str);
	s.len &#x3D; len;

	return is;
&#125;

MyString MyString::operator+(MyString &amp;another)
&#123;
	MyString temp;

	int len &#x3D; this-&gt;len + another.len;

	temp.len &#x3D; len;

	temp.str &#x3D; new char[len + 1];
	memset(temp.str, 0, len + 1);
	strcat(temp.str, this-&gt;str);
	strcat(temp.str, another.str);

	return temp;
&#125;
&#x2F;&#x2F;main.c
#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &quot;MyString.h&quot;

using namespace std;

int main(void)
&#123;
	string s1;
	MyString s1(&quot;abc&quot;);
	MyString s2(&quot;123&quot;);

	&#x2F;&#x2F;cout &lt;&lt; s1 + s2 &lt;&lt; endl;

	cout &lt;&lt; s1 &lt;&lt; endl;
	cout &lt;&lt; s2 &lt;&lt; endl;


#if 0
	MyString s1(&quot;abc&quot;);
	MyString s2(s1);
	MyString s3 &#x3D; &quot;123&quot;;


	cout &lt;&lt; s1 &lt;&lt; endl;
	cout &lt;&lt; s2 &lt;&lt; endl;

	s1[1] &#x3D; &#39;x&#39;;

	cout &lt;&lt; s1 &lt;&lt; endl;

	s1 &#x3D; s3;

	cout &lt;&lt; s1 &lt;&lt; endl;

#endif
	return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="重载new和delete运算符"><a href="#重载new和delete运算符" class="headerlink" title="重载new和delete运算符"></a>重载new和delete运算符</h4><pre class="line-numbers language-none"><code class="language-none">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;


using namespace std;

class A
&#123;
public:
	A()
	&#123;
		cout &lt;&lt; &quot;A()...&quot; &lt;&lt; endl;
	&#125;
	A(int a) &#123;
		cout &lt;&lt; &quot;A(int)...&quot; &lt;&lt; endl;
		this-&gt;a &#x3D; a;
	&#125;

	&#x2F;&#x2F;重载的new操作符 依然会触发对象的构造函数
	void * operator new(size_t size)
	&#123;
		cout &lt;&lt; &quot;重载了new操作符&quot; &lt;&lt; endl;
		return malloc(size);
	&#125;

	void *operator new[](size_t size)
	&#123;
		cout &lt;&lt; &quot;重载了new[]操作符&quot; &lt;&lt; endl;
		return malloc(size);
	&#125;
	void operator delete(void * p)
	&#123;
		cout &lt;&lt; &quot;重载了delete操作符&quot; &lt;&lt; endl;
		if (p !&#x3D; NULL) &#123;
			free(p);
			p &#x3D; NULL;
		&#125;
	&#125;

	void operator delete[](void *p)
	&#123;
		cout &lt;&lt; &quot;重载了delete[]操作符&quot; &lt;&lt; endl;
		if (p !&#x3D; NULL) &#123;
			free(p);
			p &#x3D; NULL;
		&#125;
	&#125;

	~A() &#123;
		cout &lt;&lt; &quot;~A().... &quot; &lt;&lt; endl;
	&#125;

private:
	int a;
&#125;;

int main(void)
&#123;
	&#x2F;&#x2F;char *array &#x3D; malloc(sizeof(char)* 80);

	&#x2F;&#x2F;int *value_p &#x3D; new int;

	A *array_p &#x3D; new A[10];


	&#x2F;&#x2F;array_p-&gt;operator new[](sizeof(A[10]));
	delete[] array_p;

	A *ap &#x3D; new A(10);

	&#x2F;&#x2F;ap-&gt;operator new(sizeof(A));

	delete ap;
	
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="解引用与智能指针"><a href="#解引用与智能指针" class="headerlink" title="解引用与智能指针"></a>解引用与智能指针</h4><ul>
<li>常规意义上讲,new或是malloc出来的堆上的空间,都需要手动delete和free的。但在其它高级语言中,只需申请无需释放的功能是存在的。</li>
<li>c++中也提供了这样的机制。我们先来探究一下实现原理。</li>
<li>常规</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void foo()&#123;
A*p &#x3D; new A;
&#x2F;&#x2F;do something
delete p;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>智能指针</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;memory&gt;
using namespace std;
class A&#123;
    public:
		A() &#123;
			cout&lt;&lt;&quot;A constructor&quot;&lt;&lt;endl;
			&#125;
		~A() &#123;
			cout&lt;&lt;&quot;A destructor&quot;&lt;&lt;endl;
			&#125;
		void dis() &#123;
			cout &lt;&lt;&quot;class A&#39;s dis() &quot; &lt;&lt;endl;
		&#125;
&#125;;
int main()&#123;
&#x2F;&#x2F;使用智能指针auto_ptr 
    auto_ptr&lt;A&gt; p (new A);
	p-&gt;dis();
	return 0;
&#125;

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>自定义智能指针</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;memory&gt;


using namespace std;

class A
&#123;
public:
	A(int a)
	&#123;
		cout &lt;&lt; &quot;A()...&quot; &lt;&lt; endl;
		this-&gt;a &#x3D; a;
	&#125;

	void func() &#123;
		cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; this-&gt;a &lt;&lt; endl;
	&#125;

	~A() &#123;
		cout &lt;&lt; &quot;~A()...&quot; &lt;&lt; endl;
	&#125;
private:
	int a;
&#125;;


class MyAutoPtr
&#123;
public:
	MyAutoPtr(A * ptr)
	&#123;
		this-&gt;ptr &#x3D; ptr;&#x2F;&#x2F;ptr &#x3D; new A(10)
	&#125;

	~MyAutoPtr() &#123;
		if (this-&gt;ptr !&#x3D; NULL) &#123;
			cout &lt;&lt; &quot;delte ptr&quot; &lt;&lt; endl;
			delete ptr;
			this-&gt;ptr &#x3D; NULL;
		&#125;
	&#125;

	A* operator-&gt;()
	&#123;
		return this-&gt;ptr;
	&#125;


	A&amp; operator*()
	&#123;
		return *ptr;
	&#125;

private:
	A *ptr;
&#125;;

void test1()
&#123;
#if 0
	A* ap &#x3D; new A(10);

	ap-&gt;func();
	(*ap).func();

	delete ap;
	auto_ptr&lt;int&gt; ptr(new int);
#endif
	auto_ptr&lt;A&gt; ptr(new A(10));

	ptr-&gt;func();
	(*ptr).func();
&#125;


void test2()
&#123;
	MyAutoPtr my_p(new A(10));

	my_p-&gt;func(); &#x2F;&#x2F;my_p.ptr -&gt; func()
	(*my_p).func(); &#x2F;&#x2F;  *ptr.func()
&#125;
int main(void)
&#123;
	
	&#x2F;&#x2F;test1();
	test2();

	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>-&gt;和* 重载格式</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">类名&amp; operator*( ) &#123;
函数体
&#125;
类名*operator-&gt;( ) &#123;
函数体
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>作业1：设计TData类</p>
<p>定义一个处理日期的类TDate,它有3个私有数据成员:Month,Day,Year和若干个公有成员函数,并实现如下要求:<br>1构造函数重载<br>2成员函数设置缺省参数<br>3可使用不同的构造函数来创建不同的对象4定义一个友元函数来打印日期</p>
</blockquote>
<blockquote>
<p>作业2：设计一个矩阵类</p>
<p>设计一个3 * 3的矩阵类class Matrix,通过一数组进行初始化。</p>
<p>要求如下:<br>1默认构造(初始化为0),有参构造(数组作实参)</p>
<p>2重载+ / +=</p>
<p>3重载* / *=</p>
<p>4实现输出</p>
</blockquote>
<h2 id="继承派生"><a href="#继承派生" class="headerlink" title="继承派生"></a>继承派生</h2><ul>
<li>在C++中可重用性(software reusability)是通过继承(inheritance)这一机制来实现的。如果没有掌握继承性,就没有掌握类与对象的精华。</li>
</ul>
<h3 id="类和类之间的关系"><a href="#类和类之间的关系" class="headerlink" title="类和类之间的关系"></a>类和类之间的关系</h3><ul>
<li>has-A，uses-A和 is-A</li>
<li>has-A包含关系，用以描述一个类由多个“部件类”构成。实现has-A关系用类成员表示，即一个类中的数据成员是另一种已经定义的类。</li>
<li>uses-A 一个类部分地使用另一个类。通过类之间成员函数的相互联系定义友员或对象参数传递实现。</li>
<li>is-A机制称为“继承”。关系具有传递性,不具有对称性。</li>
</ul>
<h3 id="什么是继承"><a href="#什么是继承" class="headerlink" title="什么是继承"></a>什么是继承</h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class Student
&#123;
public:
	void dis() &#123;
		cout&lt;&lt;name&lt;&lt;endl;
        cout&lt;&lt;age&lt;&lt;endl;
&#125;
		string name;
    	int age;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>重写</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Student2&#123;
public:
void dis() &#123;
	cout&lt;&lt;name&lt;&lt;endl;
    cout&lt;&lt;age&lt;&lt;endl;
    cout&lt;&lt;sex&lt;&lt;endl;
    cout&lt;&lt;score&lt;&lt;endl;
&#125;
private:
    string name;
    int age;
    char sex;
    float score;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>继承</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Student2 : public Student&#123;
public:
	student2(string n,int a,char s,float f)&#123;
	name &#x3D; n; age &#x3D; a; sex &#x3D; s; score &#x3D; f;
&#125;
	void dis() &#123;
		student: :dis();
        cout&lt;&lt;sex&lt;&lt;endl;
        cout&lt;&lt;score&lt;&lt;endl;
&#125;	
	char sex;
    float score;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>定义</p>
<ul>
<li>类的继承,是新的类从已有类那里得到已有的特性。或从已有类产生新类的过程就是类的派生。原有的类称为基类或父类,产生的新类称为派生类或子类。</li>
<li>派生与继承,是同一种意义两种称谓。isA的关系。</li>
</ul>
</li>
<li><p>派生类的组成</p>
<ul>
<li>派生类中的成员,包含两大部分,一类是从基类继承过来的,一类是自己增加的成员。从基类继承过过来的表现其共性,而新增的成员体现了其个性。</li>
<li><img src="http://qiniu.orangew.cn/img/20220704224131.png" alt="20220704224131"></li>
</ul>
</li>
<li><blockquote>
<p>几点说明:<br>1,全盘接收,除了构造器与析构器。基类有可能会造成派生类的成员冗余,所以说基类是需设计的。<br>2,派生类有了自己的个性,使派生类有了意义。</p>
</blockquote>
</li>
</ul>
<h3 id="继承的方式"><a href="#继承的方式" class="headerlink" title="继承的方式"></a>继承的方式</h3><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><blockquote>
<p>class派生类名:[继承方式]基类名{<br>派生类成员声明;<br>};</p>
</blockquote>
<ul>
<li>一个派生类可以同时有多个基类,这种情况称为多重继承,派生类只有一个基类,称为单继承。下面从单继承讲起。</li>
</ul>
<h4 id="protected访问控制"><a href="#protected访问控制" class="headerlink" title="protected访问控制"></a>protected访问控制</h4><ul>
<li>protected 对于外界访问属性来说,等同于私有,但可以派生类中可见。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;class Base
&#123;
	public:
	int pub;
    protected:
    int pro;
    private:
	int pri;
&#125;;
class Drive: public Base &#123;
    public:
	void func() &#123;
		pub &#x3D; 10;
        pro &#x3D; 100;
&#x2F;&#x2F; pri &#x3D; 1000; &#x2F;&#x2F;error
	&#125;
&#125;;
int main(void)&#123;
	Base b;
	b.pub &#x3D; 10;
&#x2F;&#x2F;b.pro &#x3D; 100; &#x2F;&#x2F; error
    &#x2F;&#x2F; b.pri &#x3D; 1000; &#x2F; &#x2F; error
return 0;&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="派生类成员的标识和访问"><a href="#派生类成员的标识和访问" class="headerlink" title="派生类成员的标识和访问"></a>派生类成员的标识和访问</h4><table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>公有继承（public）</td>
<td>public</td>
<td>protected</td>
<td>不可见</td>
</tr>
<tr>
<td>保护继承（protected）</td>
<td>protected</td>
<td>protected</td>
<td>不可见</td>
</tr>
<tr>
<td>私有继承（private）</td>
<td>private</td>
<td>private</td>
<td>不可见</td>
</tr>
</tbody></table>
<ul>
<li>public 公有继承<ul>
<li>当类的继承方式为公有继承时,基类的公有和保护成员的访问属性在派生类中不变,而基类的私有成员不可访问。即基类的公有成员和保护成员被继承到派生类中仍作为派生类的公有成员和保护成员。派生类的其他成员可以直接访问它们。无论派生类的成员还是派生类的对象都无法访问基类的私有成员。</li>
</ul>
</li>
<li>private私有继承<ul>
<li>当类的继承方式为私有继承时,基类中的公有成员和保护成员都以私有成员身份出现在派生类中,而基类的私有成员在派生类中不可访问。基类的公有成员和保护成员被继承后作为派生类的私有成员,派生类的其他成员可以直接访问它们,但是在类外部通过派生类的对象无法访问。无论是派生类的成员还是通过派生类的对象,都无法访问从基类继承的私有成员。通过多次私有继承后,对于基类的成员都会成为不可访问。因此私有继承比较少用。</li>
</ul>
</li>
<li>protected保护继承<ul>
<li>保护继承中,基类的公有成员和私有成员都以保护成员的身份出现在派生类中,而基类的私有成员不可访问。派生类的其他成员可以直接访问从基类继承来的公有和保护成员,但是类外部通过派生类的对象无法访问它们,无论派生类的成员还是派生类的对象,都无法访问基类的私有成员。</li>
</ul>
</li>
</ul>
<blockquote>
<p>private成员在子类中依然存在，但是却无法访问到。不论何种方式继承基类，派生类都不能直接使用基类的私有成员。</p>
</blockquote>
<blockquote>
<p>如何恰当的使用ublic，Protected和private为成员声明访问级别?</p>
<p>1、需要被外界访问的成员直接设置为public</p>
<p>2、只能在当前类中访问的成员设置为private</p>
<p>3、只能在当前类和子类中访问的成员设置为protected , protected成员的访问权限介于public和private之间。</p>
</blockquote>
<blockquote>
<p>分析以下代码的访问权限</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class A
&#123;
	private:int a;
    protected :int b;
    public:
	int c;
    	A()&#123;
		a &#x3D; 0;
        b &#x3D; 0;
        c &#x3D; 0;
&#125;
void set(int a, int b, int c)&#123;
	this-&gt;a &#x3D; a;
    	this-&gt;b &#x3D; b;
   	 this-&gt;c &#x3D; c;
&#125;;
class B:public A&#123;
	public:
	void print()&#123;
	cout&lt;&lt;&quot;a &#x3D; &quot;&lt;&lt;a;&#x2F;&#x2F;能否访问???
        	cout&lt;&lt;&quot;b &#x3D; &quot;&lt;&lt;b;&#x2F;&#x2F;能否访问???
        	cout&lt;&lt;&quot;c &#x3D; &quot;&lt;&lt;endl;&#x2F;&#x2F;能否访问???
	&#125;
&#125;;
class C : protected A&#123;
	public:
	void print()&#123;
	cout&lt;&lt;&quot;a &#x3D; &quot;&lt;&lt;a;&#x2F;&#x2F;能否访问???
	cout&lt;&lt;&quot;b &#x3D; &quot;&lt;&lt;b;&#x2F;&#x2F;能否访问???
    	cout&lt;&lt;&quot;c &#x3D; &quot;&lt;&lt;endl; &#x2F;&#x2F;能否访问???
	&#125;
&#125;;
class D : private A&#123;
	public:
	void print()
	&#123;
	cout&lt;&lt;&quot;a &#x3D; &quot;&lt;&lt;a;&#x2F;&#x2F;能否访问???
        cout&lt;&lt;&quot;b &#x3D; &quot;&lt;&lt;b&lt;&lt;endl;&#x2F;&#x2F;能否访问???
        cout&lt;&lt;&quot;c &#x3D; &quot;&lt;&lt;c&lt;&lt;endl;&#x2F;&#x2F;能否访问???
&#125;
&#125;;
int main(void)&#123;
	A aa;
    B bb;
    C cc;
    D dd;
	aa.c &#x3D; 100;&#x2F;&#x2F;能否访问???
	bb.c &#x3D; 100;&#x2F;&#x2F;能否访问???	
	cc.c &#x3D; 100;&#x2F;&#x2F;能否访问???
	dd.c &#x3D; 100;&#x2F;&#x2F;能否访问???
	aa.set(1，2，3);&#x2F;&#x2F;能否访问???
    bb.set(10，20，30);&#x2F;&#x2F;能否访问???
    cc.set(40，50，60);&#x2F;&#x2F;能否访问???
    dd.set(70,80，90);&#x2F;&#x2F;能否访问???
	bb.print( );&#x2F;&#x2F;能否访问???
	cc.print();&#x2F;&#x2F;能否访问???
	dd.print( );&#x2F;&#x2F;能否访问???
return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="继承中的构造和析构"><a href="#继承中的构造和析构" class="headerlink" title="继承中的构造和析构"></a>继承中的构造和析构</h3><h4 id="类型兼容性原则"><a href="#类型兼容性原则" class="headerlink" title="类型兼容性原则"></a>类型兼容性原则</h4><ul>
<li>类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代。通过公有继承，派生类得到了基类中除构造函数、析构函数之外的所有成员。这样，公有派生类实际就具备了基类的所有功能，凡是基类能解决的问题，公有派生类都可以解决。</li>
<li>类型兼容规则中所指的替代包括以下情况∶</li>
</ul>
<blockquote>
<p>子类对象可以当作父类对象使用</p>
<p>子类对象可以直接赋值给父类对象</p>
<p>子类对象可以直接初始化父类对象</p>
<p>父类指针可以直接指向子类对象</p>
<p>父类引用可以直接引用子类对象</p>
</blockquote>
<ul>
<li>在替代之后，派生类对象就可以作为基类的对象使用，但是只能使用从基类继承的成员。</li>
<li>子类就是特殊的父类<code>(base * p = &amp;chil d ;)</code></li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class Parent
&#123;
	public:
	void printP()
	&#123;
	cout &lt;&lt; &quot;parent. . ..&quot; &lt;&lt; endl;
&#125;;
class Child : public Parent&#123;
	public:
		void printc()&#123;
 		cout &lt;&lt; &quot;child. ..&quot; &lt;&lt; endl;
	&#125;
&#125;;
void print01(Parent *p)&#123;
	p-&gt;printP();
	&#125;
void print02(Parent &amp;p)&#123;
p.printP();
&#125;
int main()&#123;
	child c1;
	c1.printC();
	Parent *p &#x3D; NULL;
	&#x2F;&#x2F;可以用父类指针指向子类对象
	p &#x3D; &amp;c1;
	p-&gt;printP();&#x2F;&#x2F;执行父类的函数
	Childc2;
	Parentp2;
	print01(&amp;p2);
	print01(&amp;c2);&#x2F;&#x2F;父类指针指向子类对象
	print02(p2);
	print02(c2);&#x2F;父类引用指向子类对象
	&#x2F;&#x2F;第二层含义用子类初始化父类对象
	Childc3;
	Parent p3 &#x3D; c3;
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="继承中的对象模型"><a href="#继承中的对象模型" class="headerlink" title="继承中的对象模型"></a>继承中的对象模型</h4><ul>
<li>类在C++编译器的内部可以理解为结构体,子类是由父类成员叠加子类新成员得到的.</li>
<li>问题∶如何初始化父类成员?父类与子类的构造函数有什么关系?</li>
</ul>
<blockquote>
<p>在子类对象构造时，需要调用父类构造函数对其继承得来的成员进行初<br>女始化.<br>在子类对象析构时，需要调用父类析构函数对其继承得来的成员进行清<br>理.</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class Parent
&#123;
	public:
	Parent(const char* s)&#123;
	this-&gt;s &#x3D; s;
	cout&lt;&lt; &quot;Parent()&quot;&lt;&lt;&quot; &quot;&lt;&lt;s&lt;&lt;endl;
	&#125;
	~Parent( )&#123;
	cout&lt;&lt;&quot;~Parent( )&quot;&lt;&lt;endl;
	&#125;
	private:
	const char *s;
&#125;;
class Child : public Parent&#123;
	public:
	Child(int a) : Parent( &quot;Parameter from Child! &quot;)&#123;
	cout&lt;&lt;&quot;Child( )&quot;&lt;&lt;endl;
	this-&gt;a &#x3D; a;
	&#125;
	Child( int a，const char *s) : Parent(s)&#123;
	cout&lt;&lt; &quot;Child( ) &quot;&lt;&lt;endl;this-&gt;a &#x3D; a;
&#125;
	~Child()&#123;
	cout&lt;&lt; &quot;~Child()&quot;&lt;&lt;endl;
&#125;
	private:int a;
&#125;;
void run()&#123;
&#x2F;&#x2F; Child child(10);
Child child(10，&quot;Parameter form child...&quot;);
&#125;
int main(int argc,char *argv[])&#123;
run( );
return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="继承中构造析构调用原则"><a href="#继承中构造析构调用原则" class="headerlink" title="继承中构造析构调用原则"></a>继承中构造析构调用原则</h4><blockquote>
<p>1、子类对象在创建时会首先调用父类的构造函数</p>
<p>2、父类构造函数执行结束后，执行子类的构造函数</p>
<p>3、当父类的构造函数有参数时，需要在子类的初始化列表中显示调用</p>
<p>4、析构函数调用的先后顺序与构造函数相反</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;


using namespace std;

class Parent
&#123;
public:
	Parent()
	&#123;
		cout &lt;&lt; &quot;Parent()..&quot; &lt;&lt; endl;
		a &#x3D; 0;
	&#125;
	Parent(int a) &#123;
		cout &lt;&lt; &quot;Parent(int)...&quot; &lt;&lt; endl;
		this-&gt;a &#x3D; a;
	&#125;
	~Parent()&#123;
		cout &lt;&lt; &quot;~Parent&quot; &lt;&lt; endl;
	&#125;
	int a;
&#125;;

class Child :public Parent
&#123;
public:
	&#x2F;&#x2F;在调用子类的构造函数时候，一定会调用父类的构造函数
	&#x2F;&#x2F; 父类先构造，子类后构造。
	Child(int a, int b) :Parent(a)
	&#123;
		cout &lt;&lt; &quot;Child(int, int)...&quot; &lt;&lt; endl;
		this-&gt;b &#x3D; b;
	&#125;

	void printC() &#123;
		cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;
	&#125;

	~Child()&#123;
		cout &lt;&lt; &quot;~Child()...&quot; &lt;&lt; endl;
	&#125;

	int b;
&#125;;

int main(void)
&#123;
	Child c(10, 20);

	c.printC();
	
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="http://qiniu.orangew.cn/img/20220705150418.png" alt="20220705150418"></p>
<h4 id="继承和组合并存，构造和析构原则"><a href="#继承和组合并存，构造和析构原则" class="headerlink" title="继承和组合并存，构造和析构原则"></a>继承和组合并存，构造和析构原则</h4><blockquote>
<p>先构造父类，再构造成员变量、最后构造自己</p>
<p>先析构自己，在析构成员变量、最后析构父类</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class Object
&#123;
	public:
	Object(const char* s)&#123;
	cout&lt;&lt; &quot;Object()&quot;&lt;&lt;&quot; &quot;&lt;&lt;s&lt;&lt;endl;&#125;
	~Object()&#123;
	cout&lt;&lt; &quot;~object()&quot;&lt;&lt;endl;
	&#125;
&#125;;

class Parent : public Object&#123;
	public:
	Parent( const char* s) : Object(s)&#123;
	cout&lt;&lt;&quot;Parent( )&quot;&lt;&lt;&quot; &quot;&lt;&lt;s&lt;&lt;endl;
&#125;
	~Parent()
	&#123;
	cout&lt;&lt;&quot;~Parent( )&quot;&lt;&lt;endl;
	&#125;
&#125;;
class Child : public Parent&#123;
	public:
	Child() : o2(&quot;o2&quot;)，o1(&quot;o1&quot;)，Parent(&quot;Parameter from Child!&quot;)&#123;
	cout&lt;&lt;&quot;Child()&quot;&lt;&lt;endl;
&#125;
	~Child()&#123;
	cout&lt;&lt;&quot;~Child( ) &quot;&lt;&lt;endl;
&#125;
private:
	object o1;
	object o2;
&#125;;
void run()&#123;
	Child child;
&#125;
int main( int argc, char *argv[])&#123;
	run( );
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="继承中同名成员变量处理方法"><a href="#继承中同名成员变量处理方法" class="headerlink" title="继承中同名成员变量处理方法"></a>继承中同名成员变量处理方法</h4><ol>
<li>当子类成员变量与父类成员变量同名时</li>
<li>子类依然从父类继承同名成员</li>
<li>在子类中通过作用域分辨符::进行同名成员区分(在派生类中使用基类的同名成员，显式地使用类名限定符)</li>
<li>同名成员存储在内存中的不同位置</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;


using namespace std;


class Parent
&#123;
public:
	Parent(int a) &#123;
		this-&gt;a &#x3D; a;
	&#125;

	int a;
&#125;;

class Child :public Parent
&#123;
public:
	Child(int p_a, int c_a) :Parent(p_a)
	&#123;
		this-&gt;a &#x3D; c_a;
	&#125;

	void print()
	&#123;
		cout &lt;&lt; Parent::a &lt;&lt; endl;
		cout &lt;&lt; this-&gt;a &lt;&lt; endl;&#x2F;&#x2F;child&#39;s a
	&#125;
	int a;
&#125;;


int main(void)
&#123;
	Child c(10, 100);
	c.print();

	
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="派生类中的static关键字"><a href="#派生类中的static关键字" class="headerlink" title="派生类中的static关键字"></a>派生类中的static关键字</h4><ul>
<li>基类定义的静态成员，将被所有派生类共享</li>
<li>根据静态成员自身的访问特性和派生类的继承方式，在类层次体系中具有不同的访问性质（遵守派生类的访问控制)</li>
<li>派生类中访问静态成员，用以下形式显式说明∶类名:: 成员  或通过对象访问  对象名.成员</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;


using namespace std;

class A
&#123;
public:
	static int a;
private:

&#125;;

class B :public A
&#123;
public:
private:
&#125;;

int A::a &#x3D; 100;&#x2F;&#x2F;静态成员变量 初始化

int main(void)
&#123;
	A a1;
	A a2;

	cout &lt;&lt; a1.a &lt;&lt; endl;
	cout &lt;&lt; a2.a &lt;&lt; endl;

	A::a &#x3D; 300;

	cout &lt;&lt; a1.a &lt;&lt; endl;
	cout &lt;&lt; a2.a &lt;&lt; endl;

	B b1;
	B b2;
	A::a &#x3D; 400;

	cout &lt;&lt; &quot;------&quot; &lt;&lt; endl;
	cout &lt;&lt; b1.a &lt;&lt; endl;
	cout &lt;&lt; b2.a &lt;&lt; endl;
	cout &lt;&lt; a1.a &lt;&lt; endl;
	cout &lt;&lt; a2.a &lt;&lt; endl;

	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>static函数也遵守3个访问原则</li>
<li>static易犯错误（不但要初始化，更重要的显示的告诉编译器分配内存)</li>
</ul>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><blockquote>
<p>派生类名::派生类名(参数总表):基类名1(参数表1),基类名(参数名2)….<br>基类名n(参数名n),内嵌子对象1(参数表1),<br>内嵌子对象2(参数表 2)….内嵌子对象n(参数表n)</p>
<p>{派生类新增成员的初始化语句;}</p>
</blockquote>
<ul>
<li>一个类有多个直接基类的继承关系称为多继承</li>
</ul>
<h4 id="沙发床实现"><a href="#沙发床实现" class="headerlink" title="沙发床实现"></a>沙发床实现</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;


using namespace std;

&#x2F;&#x2F;家具类
class Furniture
&#123;
public:
	int m; &#x2F;&#x2F;材质
&#125;;

&#x2F;&#x2F;将父亲类继承爷爷类  改成虚继承， 防止儿子在多继承我的时候，出现爷爷中的变量会拷贝多份。
class Bed:virtual public Furniture
&#123;
public:
	void sleep() &#123;
		cout &lt;&lt; &quot;在床上睡觉&quot; &lt;&lt; endl;
	&#125;
&#125;;


class Sofa:virtual public Furniture
&#123;
public:
	void sit() &#123;
		cout &lt;&lt; &quot;在沙发上休息&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;沙发床
class SofaBed :public Bed, public Sofa
&#123;
public:
	void SleepAndSit() &#123;
		sleep();
		sit();
	&#125;
&#125;;

int main(void)
&#123;
	Bed b;
	b.sleep();

	Sofa s;
	s.sit();

	cout &lt;&lt; &quot; ------ &quot; &lt;&lt; endl;

	SofaBed sb;
	sb.SleepAndSit();

	sb.m &#x3D; 100;&#x2F;&#x2F;此时只有一个m
	&#x2F;&#x2F;sb.Bed::m &#x3D; 100;
	&#x2F;&#x2F;sb.Sofa::m &#x3D; 200;
	
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h3><ul>
<li>如果一个派生类从多个基类派生，而这些基类又有一个共同的基类，则在对该基类中声明的名字进行访问时，可能产生二义性</li>
</ul>
<h4 id="多继承中二义性问题"><a href="#多继承中二义性问题" class="headerlink" title="多继承中二义性问题"></a>多继承中二义性问题</h4><h4 id="虚继承virtual"><a href="#虚继承virtual" class="headerlink" title="虚继承virtual"></a>虚继承virtual</h4><ul>
<li>如果一个派生类从多个基类派生，而这些基类又有一个共同的基类，则在对该基类中声明的名字进行访问时，可能产生二义性</li>
<li>如果在多条继承路径上有一个公共的基类，那么在继承路径的某处汇合点，这个公共基类就会在派生类的对象中产生多个基类子对象</li>
<li>要使这个公共基类在派生类中只产生一个子对象，必须对这个基类声明为虚继承，使这个基类成为虚基类。</li>
<li>虚继承声明使用关键字virtual</li>
</ul>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="什么是多态"><a href="#什么是多态" class="headerlink" title="什么是多态"></a>什么是多态</h3><h4 id="浅析多态的意义"><a href="#浅析多态的意义" class="headerlink" title="浅析多态的意义"></a>浅析多态的意义</h4><ul>
<li>如果有几个上似而不完全相同的对象,有时人们要求在向它们发出同一个消息时，它们的反应各不相同,分别执行不同的操作。这种情况就是多态现象。</li>
<li>例如,甲乙丙3个班都是高二年级,他们有基本相同的属性和行为,在同时听到上课铃声的时候,他们会分别走向3个不同的教室,而不会走向同一个教室。</li>
<li>同样,如果有两支军队,当在战场上听到同种号声,由于事先约定不同,A军队可能实施进攻,而B军队可能准备kalalok。</li>
<li>C++中所谓的多态(polymorphism)是指,由继承而产生的相关的不同的类,其对象对同一消息会作出不同的响应。</li>
<li>多态性是面向对象程序设计的一个重要特征,能增加程序的灵活性。可以减轻系统升级,维护,调试的工作量和复杂度.</li>
</ul>
<h4 id="赋值兼容（多态实现的前提）"><a href="#赋值兼容（多态实现的前提）" class="headerlink" title="赋值兼容（多态实现的前提）"></a>赋值兼容（多态实现的前提）</h4><ul>
<li>赋值兼容规则是指在需要基类对象的任何地方都可以使用公有派生类的对象来替代。</li>
<li>赋值兼容是一种默认行为,不需要任何的显示的转化步骤。赋值兼容规则中所指的替代包括以下的情况:</li>
<li>派生类的对象可以赋值给基类对象。派生类的对象可以初始化基类的引用。</li>
<li>派生类对象的地址可以赋给指向基类的指针。</li>
<li>在替代之后,派生类对象就可以作为基类的对象使用,但只能使用从基类继承的成员。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class Parent
&#123;
public:
	Parent(int a)&#123;
	this-&gt;a &#x3D; a;
	cout&lt;&lt;&quot;Parent a&quot;&lt;&lt;a&lt;&lt;endl;
	&#125;
	void print()&#x2F;&#x2F;子类的和父类的函数名字一样
	&#123;
	cout&lt;&lt; &quot;Parent打印a : &quot;&lt;&lt;a&lt;&lt;endl;
&#125;
	private:int a ;
&#125;;
	class Child : public Parent&#123;
	public:
	Child(int b) : Parent( 10)&#123;
	this-&gt;b &#x3D; b;
	cout&lt;&lt;&quot;Child b&quot;&lt;&lt;b&lt;&lt;endl;
&#125;
	void print()&#123;
	cout&lt;&lt;&quot;Child打印b: &quot;&lt;&lt;b&lt;&lt;endl;
&#125;
	private:
	int b;
&#125;;
void howToPrint(Parent *base)&#123;
base-&gt;print();&#x2F;&#x2F;一种调用语句有多种表现形态...
&#125;
void howToPrint2(Parent &amp;base)&#123;
base.print();
&#125;
int main( void)&#123;
	Parent *base &#x3D; NULL;
	Parent p1(20);
	Child c1(30) ;
	base &#x3D; &amp;p1;
	base-&gt;print();&#x2F;&#x2F;执行父类的打印函数
	base &#x3D; &amp;c1;
&#x2F;*
编译器认为最安全的做法是编译到父类的print函数，因为父类和子类肯定都有相同的print函数。
*&#x2F;
	base-&gt;print();&#x2F;&#x2F;执行谁的函数﹖&#x2F;&#x2F;貌似我们希望之星Child的print函数
	Parent &amp;base2 &#x3D; p1;
	base2.print();&#x2F;&#x2F;执行父类的打印函数
	Parent &amp;base3 &#x3D; c1;
	base3.print();&#x2F;&#x2F;执行谁的函数?
	&#x2F;&#x2F;函数调用
	howToPrint(&amp;p1);
	howToPrint(&amp;c1);
	howToPrint2(p1);
	howToPrint2(c1);
return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="http://qiniu.orangew.cn/img/20220705170753.png" alt="20220705170753"></p>
<h4 id="面向对象新需求"><a href="#面向对象新需求" class="headerlink" title="面向对象新需求"></a>面向对象新需求</h4><ul>
<li>编译器的做法不是我们期望的;</li>
<li>根据实际的对象类型来判断重写函数的调用;</li>
<li>如果父类指针指向的是父类对象则调用父类中定义的函数;</li>
<li>如果父类指针指向的是子类对象则调用子类中定义的重写函数;</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/20220705171438.png" alt="20220705171438"></p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ul>
<li>C++中通过virtual关键字对多态进行支持</li>
<li>使用virtual声明的函数被重写后即可展现多态特性</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;


using namespace std;

&#x2F;&#x2F;英雄类
&#x2F;&#x2F;1999
class Hero
&#123;
public:
	virtual int getAd() &#123;
		return 10;
	&#125;
&#125;;

&#x2F;&#x2F;1999
class AdvHero :public Hero
&#123;
public:
	virtual int getAd()
	&#123;
		return 1001;
	&#125;
&#125;;

&#x2F;&#x2F;怪兽类
&#x2F;&#x2F;1999
class Monster
&#123;
public:
	int getAd() &#123;
		return 1000;
	&#125;
&#125;;


&#x2F;&#x2F;战斗方法
&#x2F;&#x2F;1999 &#x2F;&#x2F;写的架构函数，可以调用未来。
void playerFight(Hero *hp, Monster *mp)
&#123;
	&#x2F;&#x2F;多态对于编译器来讲的，也是一个动态联编，也是一个迟邦定。
	if (hp-&gt;getAd() &gt; mp-&gt;getAd()) &#123; &#x2F;&#x2F;hp-&gt;getAd 发生了多态
		cout &lt;&lt; &quot;英雄胜利， 怪兽被打死&quot; &lt;&lt; endl;
	&#125;
	else &#123;
		cout &lt;&lt; &quot;英雄挂了，怪兽赢了&quot; &lt;&lt; endl;
	&#125;
&#125;

&#x2F;&#x2F;2020年
class BugHero :public Hero
&#123;
public:
	virtual int getAd()
	&#123;
		cout &lt;&lt; &quot;调用了bugHero的方法&quot; &lt;&lt; endl;
		return 66666;
	&#125;
&#125;;

int main(void)
&#123;
	Hero h;

	Monster m;

	playerFight(&amp;h, &amp;m);


	AdvHero advH;

	playerFight(&amp;advH, &amp;m);


	BugHero bH;

	playerFight(&amp;bH, &amp;m);

	int a &#x3D; 10;
	int b &#x3D; 20;

	cout &lt;&lt; a &lt;&lt; endl;

	if (a &gt; 10) &#123; &#x2F;&#x2F;迟邦定
		cout &lt;&lt; &quot;a&gt;10&quot; &lt;&lt; endl;
	&#125;
	else &#123;
		cout &lt;&lt; &quot;a &lt; 10&quot; &lt;&lt; endl;
	&#125;


	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="多态工程的意义"><a href="#多态工程的意义" class="headerlink" title="多态工程的意义"></a>多态工程的意义</h4><ul>
<li>封装<ul>
<li>突破了c语言函数的概念。</li>
</ul>
</li>
<li>继承<ul>
<li>代码复用，复用原来写好的代码。</li>
</ul>
</li>
<li>多态<ul>
<li>多态可以使用未来，80年代写了一个框架，90人写的代码。多态是软件行业追寻的一个目标。</li>
</ul>
</li>
</ul>
<h4 id="多态成立的条件"><a href="#多态成立的条件" class="headerlink" title="多态成立的条件"></a>多态成立的条件</h4><blockquote>
<p>1要有继承<br>2要有虚函数重写<br>3要有父类指针（父类引用）指向子类对象</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;string&gt;

using namespace std;


&#x2F;&#x2F;岳不群
class Yuebuqun
&#123;
public:
	Yuebuqun( string kongfu)
	&#123;
		this-&gt;kongfu &#x3D; kongfu;
	&#125;

	virtual  void fight() &#x2F;&#x2F;标识修饰一个成员方法是一个虚函数。
	&#123;
		cout &lt;&lt; &quot;岳不群&quot; &lt;&lt; &quot;使出了&quot; &lt;&lt; kongfu &lt;&lt; &quot;打人&quot; &lt;&lt; endl;
	&#125;

	void print()
	&#123;

	&#125;

	string kongfu;
&#125;;

&#x2F;&#x2F;林平之 继承了 岳不群
class Linpingzhi :public Yuebuqun
&#123;
public:
	Linpingzhi(string kongfu) :Yuebuqun(kongfu)
	&#123;

	&#125;

	&#x2F;&#x2F;如果说父类中有一个虚函数是fight（ ）， 子类如果去重写这个虚函数。
	void fight()
	&#123;
		cout &lt;&lt; &quot;林平之&quot; &lt;&lt; &quot;使出了&quot; &lt;&lt; kongfu &lt;&lt; &quot;打人&quot; &lt;&lt; endl;
	&#125;

	void print()
	&#123;

	&#125;
&#125;;

class Linghuchong :public Yuebuqun
&#123;
public:
	Linghuchong(string kongfu) :Yuebuqun(kongfu)
	&#123;

	&#125;

	void  fight()
	&#123;
		cout &lt;&lt; &quot;令狐冲 &quot; &lt;&lt; &quot;使用了&quot; &lt;&lt; kongfu &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;在全局提供一个打斗的方法
void fightPeople(Yuebuqun *hero)&#x2F;&#x2F;Yuebuqun *hero &#x3D; xiaopp;  Yuebuqun *hero &#x3D; xiaoyy;
&#123;
	cout &lt;&lt; &quot;调用打人的方法&quot; &lt;&lt; endl;
	hero-&gt;fight();&#x2F;&#x2F;希望传递进来的如果是子类，调用子类的fight
			      &#x2F;&#x2F;如果传递进来的是父类， 调用父类的fight
					&#x2F;&#x2F;这种行为就是 多态行为。
&#125;

&#x2F;&#x2F;多态发生的三个必要条件：
&#x2F;&#x2F;1. 要有继承。
&#x2F;&#x2F;2. 要有虚函数重写。
&#x2F;&#x2F;3. 父类指针或引用 指向 子类对象。

int main(void)
&#123;
	Yuebuqun *xiaoyy &#x3D; new Yuebuqun(&quot;葵花宝典&quot;);

	&#x2F;&#x2F;xiaoyy-&gt;fight();



	Linpingzhi *xiaopp &#x3D; new Linpingzhi(&quot;僻邪剑谱&quot;);
	&#x2F;&#x2F;xiaopp-&gt;fight();

	Linghuchong *xiaoll &#x3D; new Linghuchong(&quot;独孤九剑&quot;);

	 
	fightPeople(xiaoyy);
	fightPeople(xiaopp);
	fightPeople(xiaoll);
	&#x2F;&#x2F;编译器默认做了一个安全的处理。 编译认为 不管传递时子类对象还是父类对象，
	&#x2F;&#x2F;如果统一执行父类d方法 那么是一定可以被成功执行。

	delete xiaoyy;
	delete xiaopp;
	delete xiaoll;

	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="http://qiniu.orangew.cn/img/20220705172952.png" alt="20220705172952"></p>
<ul>
<li><code>g++ -fexec-charset=GBK test.c++ -o test</code></li>
</ul>
<h4 id="静态联编和动态联编"><a href="#静态联编和动态联编" class="headerlink" title="静态联编和动态联编"></a>静态联编和动态联编</h4><ol>
<li>联编是指一个程序模块、代码之间互相关联的过程。</li>
<li>静态联编( static binding )，是程序的匹配、连接在编译阶段实现，也称为早期匹配。重载函数使用静态联编。</li>
<li>动态联编是指程序联编推迟到运行时进行，所以又称为晚期联编（迟绑定)。switch语句和if语句是动态联编的例子。</li>
</ol>
<blockquote>
<p>1、C++与C相同，是静态编译型语言<br>2、在编译时，编译器自动根据指针的类型判断指向的是一个什么样的对象;所以编译器认为父类指针指向的是父类对象。<br>3、由于程序没有运行，所以不可能知道父类指针指向的具体是父类对象还是子类对象，从程序安全的角度，编译器假设父类指针只指向父类对象，因此编译的结果为调用父类的成员函数。这种特性就是静态联编。<br>4、多态的发生是动态联编，实在程序执行的时候判断具体父类指针应该调用的方法。</p>
</blockquote>
<h3 id="虚析构函数"><a href="#虚析构函数" class="headerlink" title="虚析构函数"></a>虚析构函数</h3><ul>
<li>构造函数不能是虚函数。建立一个派生类对象时，必须从类层次的根开始，沿着继承路径逐个调用基类的构造函数。</li>
<li>析构函数可以是虚的。虚析构函数用于指引delete运算符正确析构动态对象。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;


using namespace std;

class A
&#123;
public:
	A() &#123;
		cout &lt;&lt; &quot;A()...&quot; &lt;&lt; endl;
		this-&gt;p &#x3D; new char[64];
		memset(this-&gt;p, 0, 64);
		strcpy(this-&gt;p, &quot;A String..&quot;);
	&#125;

	virtual void print()
	&#123;
		cout &lt;&lt; &quot;A: &quot; &lt;&lt; this-&gt;p &lt;&lt; endl;
	&#125;

	virtual ~A() &#123;
		cout &lt;&lt; &quot;~A()...&quot; &lt;&lt; endl;
		if (this-&gt;p !&#x3D; NULL) &#123;
			delete[]this-&gt;p;
			this-&gt;p &#x3D; NULL;
		&#125;
	&#125;
private:
	char *p;
&#125;;

class B :public A
&#123;
public:
	B() &#x2F;&#x2F;此刻会触发A()
	&#123;
		cout &lt;&lt; &quot;B()...&quot; &lt;&lt; endl;
		this-&gt;p &#x3D; new char[64];
		memset(this-&gt;p, 0, 64);
		strcpy(this-&gt;p, &quot;B String..&quot;);
	&#125;

	virtual void print()
	&#123;
		cout &lt;&lt; &quot;B: &quot; &lt;&lt; this-&gt;p &lt;&lt; endl;
	&#125;

	virtual ~B() &#123;
		cout &lt;&lt; &quot;~B()...&quot; &lt;&lt; endl;
		if (this-&gt;p !&#x3D; NULL) &#123;
			delete[] this-&gt;p;
			this-&gt;p &#x3D; NULL;
		&#125;
	&#125;
private:
	char *p;
&#125;;


void func(A *ap)
&#123;
	ap-&gt;print();&#x2F;&#x2F;在此发生多态

&#125;

void deleteFunc(A *ap)
&#123;
	delete ap; &#x2F;&#x2F;此刻ap-&gt;~B() &#x2F;&#x2F;~B() ---&gt; ~A()
&#125;

void test()
&#123;
	&#x2F;&#x2F;A *ap &#x3D; new A;
	&#x2F;&#x2F;func(ap);
	B *bp &#x3D; new B;
	func(bp);

	deleteFunc(bp);
&#125;

int main(void)
&#123;
	test();
	

	B bObj;

	&#x2F;&#x2F;bObj.~B();
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include&lt;cstring&gt;
using namespace std;
class A
&#123;
public:
    A()
    &#123;
        p &#x3D; new char[20];
        strcpy(p, &quot;obja&quot;);
        printf(&quot;A( )\n&quot;);
    &#125;
        virtual ~A()
        &#123;
            delete[] p;
            printf(&quot;~A()\n&quot;);
        &#125;

    private:
        char *p;
    &#125;;
    class B : public A 
    &#123;   
        public : B()&#123;
        p &#x3D; new char[20];
        strcpy(p, &quot;objb&quot;);
        printf(&quot;B()\n&quot;);
        &#125;
        ~B()
        &#123;
            delete[] p;
            printf(&quot;~B( )\n&quot;);
        &#125;

    private:
        char *p;
    &#125;;
    class C : public B &#123;
        public : C() &#123;
            p &#x3D; new char[20];
            strcpy(p, &quot;objc&quot;);
            printf(&quot;C()\n&quot;);
        &#125; 
        ~C()&#123;
    delete[] p;
    printf(&quot;~C( )\n&quot;);
&#125;

private:
char *p;
&#125;
;
&#x2F;&#x2F;通过父类指针把所有的子类对象的析构函数都执行一遍&#x2F;&#x2F;通过父类指针释放所有的子类资源
void howtodelete(A *base)&#123;
    delete base;
&#125;
int main()&#123;
   C *myC &#x3D; new C;
&#x2F;&#x2F; delete myC;&#x2F;&#x2F;直接通过子类对象释放资源不需要写virtualhowtodelete(myC);&#x2F;&#x2F;通过父类的指针调用释放子类的资源
return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="重载、重写、重定义"><a href="#重载、重写、重定义" class="headerlink" title="重载、重写、重定义"></a>重载、重写、重定义</h3><blockquote>
<p>重载（添加） :<br>a    相同的范围（在同一个类中)</p>
<p>b     函数名字相同</p>
<p>c      参数不同</p>
<p>d     virtual关键字可有可无</p>
</blockquote>
<blockquote>
<p>重写（覆盖)是指派生类函数覆盖基类函数，特征是:<br>a不同的范围，分别位于基类和派生类中</p>
<p>b函数的名字相同</p>
<p>c参数相同</p>
<p>d基类函数必须有virtual关键字</p>
</blockquote>
<blockquote>
<p>重定义(隐藏）是指派生类的函数屏蔽了与其同名的基类函数，</p>
<p>规则如下:</p>
<p>a 如果派生类的函数和基类的函数同名，但是参数不同，此时，不管有无virtual ，基类的函数被隐藏。</p>
<p>b 如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual关键字，此时，基类的函数被隐藏。</p>
</blockquote>
<h3 id="多态的实现原理"><a href="#多态的实现原理" class="headerlink" title="多态的实现原理"></a>多态的实现原理</h3><h4 id="虚函数表和vptr指针"><a href="#虚函数表和vptr指针" class="headerlink" title="虚函数表和vptr指针"></a>虚函数表和vptr指针</h4><ul>
<li>当类中声明虚函数时，编译器会在类中生成一个虚函数表;</li>
<li>虚函数表是一个存储类成员函数指针的数据结构;</li>
<li>虚函数表是由编译器自动生成与维护的;</li>
<li>virtual成员函数会被编译器放入虚函数表中;</li>
<li>存在虚函数时，每个对象中都有一个指向虚函数表的指针(vptr指针)。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;


using namespace std;

class Parent
&#123;
public:
	Parent(int a) &#123;
		this-&gt;a &#x3D; a;
	&#125;

	virtual void func(int a)
	&#123;
		cout &lt;&lt; &quot;Parent::func(int)...&quot; &lt;&lt; endl;
	&#125;

	virtual void func(int a, int b, int c)
	&#123;
		cout &lt;&lt; &quot;Parent::func(int ,int ,int )....&quot; &lt;&lt; endl;
	&#125;
private:
	int a;
&#125;;

class Child :public Parent
&#123;
public:
	Child(int a, int b) :Parent(a)
	&#123;
		this-&gt;b &#x3D; b;
	&#125;
	virtual void func(int a) 
	&#123;
		cout &lt;&lt; &quot;Child: func(int)...&quot; &lt;&lt; endl;
	&#125;

	void func(int a, int b) &#123;
		cout &lt;&lt; &quot;Child :func(int ,int )...&quot; &lt;&lt; endl;
	&#125;

	virtual void func(int a, int b, int c)
	&#123;
		cout &lt;&lt; &quot;Child ::func(int ,int ,int )...&quot; &lt;&lt; endl;
	&#125;
private:
	int b;
&#125;;

void myFunc(Parent *pp)
&#123;
	pp-&gt;func(10);
&#125;

int main(void)
&#123;
	&#x2F;&#x2F;Parent *pp &#x3D; new Parent(10);
	&#x2F;&#x2F;Parent *cp &#x3D; new Child(100, 200);


	Parent *pp &#x3D; new Child(100, 200);

	pp-&gt;func(10);&#x2F;&#x2F;Parent ？ Child
					&#x2F;&#x2F;如果调用一个普通函数，编译器根本就不会查找虚函数表。
					&#x2F;&#x2F;只有你调用的函数，是虚函数的时候，才会去查找虚函数表

	pp-&gt;func(10, 20, 30);

	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="E:\Computer\myblog\hexo\source_posts\C-基础\20220705191201.png" alt="20220705191201"></p>
<blockquote>
<p>说明:<br>1.通过虚函数表指针VPTR调用重写函数是在程序运行时进行的，因此需要通过寻址操作才能确定真正应该调用的函数。而普通成员函数是在编译时就确定了调用的函数。在效率上，虚函数的效率要低很多。<br>2.出于效率考虑，没有必要将所有成员函数都声明为虚函数.<br>3.C++编译器，执行run函数，不需要区分是子类对象还是父类对象,而是直接通过p的vPTR指针所指向的对象函数执行郎可。</p>
</blockquote>
<h4 id="证明vptr指针的存在"><a href="#证明vptr指针的存在" class="headerlink" title="证明vptr指针的存在"></a>证明vptr指针的存在</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;


using namespace std;

class Parent
&#123;
public:
	virtual void func()
	&#123;
		cout &lt;&lt; &quot;Parent::func()..&quot; &lt;&lt; endl;
	&#125;
	virtual void func(int a)
	&#123;
		cout &lt;&lt; &quot;Parent::func()..&quot; &lt;&lt; endl;
	&#125;
private:
	int a;
&#125;;


class Parent2
&#123;
public:
	void func()
	&#123;
		cout &lt;&lt; &quot;Parent2::func()..&quot; &lt;&lt; endl;
	&#125;
private:
	int a;
&#125;;
int main(void)
&#123;
	Parent p1;
	Parent2 p2;


	cout &lt;&lt; &quot;sizeof(p1) &quot; &lt;&lt; sizeof(p1) &lt;&lt; endl;&#x2F;&#x2F;多出来的4个字节就是vptr指针所占用的空间。
	cout &lt;&lt; &quot;sizeof(p2) &quot; &lt;&lt; sizeof(p2) &lt;&lt; endl;

	
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="构造函数中能否调用虚函数，实现多态？"><a href="#构造函数中能否调用虚函数，实现多态？" class="headerlink" title="构造函数中能否调用虚函数，实现多态？"></a>构造函数中能否调用虚函数，实现多态？</h4><ul>
<li>对象在创建的时,由编译器对VPTR指针进行初始化</li>
<li>只有当对象的构造完全结束后VPTR的指向才最终确定</li>
<li>父类对象的VPTR指向父类虚函数表</li>
<li>子类对象的VPTR指向子类虚函数表</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;


using namespace std;

class Parent
&#123;
public:
	Parent(int a)
	&#123;
		cout &lt;&lt; &quot;Parent(int ..)&quot; &lt;&lt; endl;
		this-&gt;a &#x3D; a;

		&#x2F;&#x2F;print();&#x2F;&#x2F;是调用父类的print（） 还是 子类的print（）？
				&#x2F;&#x2F;通过结果 此时调用的父类的print 并不是子类的print
	&#125;

	virtual void print()
	&#123;
		cout &lt;&lt; &quot;Parent::print()...a &#x3D; &quot;&lt;&lt;a &lt;&lt; endl;
	&#125;
private:
	int a;
&#125;;

class Child :public Parent
&#123;
public:
	Child(int a, int b) :Parent(a) &#x2F;&#x2F;在调用父类的构造器的时候，会将vptr指针当做父类来处理。
									&#x2F;&#x2F;此时会临时指向父类的虚函数表


	&#123;
		&#x2F;&#x2F;将子类对象的空间有编程子类对象处理，vptr指针就从指向父类的表 变成 指向子类的表

		cout &lt;&lt; &quot;Child (int ,int )&quot; &lt;&lt; endl;
		this-&gt;b &#x3D; b;
		print();&#x2F;&#x2F;此时vptr指针已经回到了 子类的表， 调用的是子类的print函数。

	&#125;

	virtual void print() &#123;
		cout &lt;&lt; &quot;Child ::Print()..b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;
	&#125;
private:
	int b;
&#125;;

int main(void)
&#123;
	Parent *pp &#x3D; new Child(10, 20);
	&#x2F;&#x2F;pp-&gt;print();&#x2F;&#x2F;发生多态

	delete pp;
	
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="父类指针和子类指针的步长"><a href="#父类指针和子类指针的步长" class="headerlink" title="父类指针和子类指针的步长"></a>父类指针和子类指针的步长</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;

using namespace std;


class Parent
&#123;
public:
	Parent(int a)
	&#123;
		this-&gt;a &#x3D; a;
	&#125;
	virtual void print()
	&#123;
		cout &lt;&lt; &quot;Parent::print a&#x3D;  &quot; &lt;&lt; a &lt;&lt; endl;
	&#125;

	int a;
&#125;;

class Child :public Parent
&#123;
public:
	Child(int a) :Parent(a)
	&#123;

	&#125;

	virtual void print()
	&#123;
		cout &lt;&lt; &quot;Child::print a&#x3D;  &quot; &lt;&lt; a &lt;&lt; endl;
	&#125;

	int b;
&#125;;


int main(void)
&#123;

	Child array[] &#x3D; &#123; Child(0), Child(1), Child(2) &#125;;
	
	Parent *pp &#x3D; &amp;array[0];
	Child *cp &#x3D; &amp;array[0];

	pp++;

	pp-&gt;print();
	cp-&gt;print();

#if 0
	pp++;&#x2F;&#x2F;pp +sizeof(Parent)
	cp++;&#x2F;&#x2F;cp +sizeof(Child)

	pp-&gt;print();
	cp-&gt;print();
#endif
	cout &lt;&lt; &quot;-----&quot; &lt;&lt; endl;

	int i &#x3D; 0;
	for (cp&#x3D; &amp;array[0], i &#x3D; 0; i &lt; 3; i++, cp++) &#123;
		cp-&gt;print();
	&#125;

	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="有关多态的理解"><a href="#有关多态的理解" class="headerlink" title="有关多态的理解"></a>有关多态的理解</h3><ul>
<li>多态的实现效果<ul>
<li>多态:同样的调用语句有多种不同的表现形态;</li>
</ul>
</li>
<li>多态实现的三个条件<ul>
<li>有继承、有virtual重写、有父类指针（引用)指向子类对象。</li>
</ul>
</li>
<li>多态的C++实现<ul>
<li>virtual关键字，告诉编译器这个函数要支持多态;不是根据指针类型判断如何调用;而是要根据指针所指向的实际对象类型来判断如何调用</li>
</ul>
</li>
<li>多态的理论基础<ul>
<li>动态联编PK静态联编。根据实际的对象类型来判断重写函数的调用。</li>
</ul>
</li>
<li>多态的重要意义<ul>
<li>设计模式的基础是框架的基石。</li>
</ul>
</li>
<li>多态原理探究<ul>
<li>虚函数表和vptr指针。</li>
</ul>
</li>
</ul>
<h3 id="虚函数和抽象类"><a href="#虚函数和抽象类" class="headerlink" title="虚函数和抽象类"></a>虚函数和抽象类</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li>纯虚函数是一个在基类中说明的虚函数，在基类中没有定义，要求任何派生类都定义自己的版本</li>
<li>纯虚函数为个派生类提供一个公共界面(接口的封装和设计、软件的模块功能划分)</li>
</ul>
<h4 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;


using namespace std;

&#x2F;&#x2F;面向抽象类编程（面向一套预先定义好的接口编程）
&#x2F;&#x2F;图形类
&#x2F;&#x2F;如果说一个类 拥有一个纯虚函数 
&#x2F;&#x2F;就称这个类是一个抽象类。
&#x2F;&#x2F;不管这个类中有没有成员属性，只要这个类有纯虚函数，就是一个抽象类， 抽象类就是不能够实例化的。
class Shape
&#123;
public:
	&#x2F;&#x2F;阅读一个统一的界面（接口），让子类使用，让子类必须去实现
	&#x2F;&#x2F;求图形面积的方法
	&#x2F;&#x2F;表示图形类声明一个方法getArea（），它是一个纯虚函数，没有函数的实现。
	virtual double getArea() &#x3D; 0;
&#125;;

&#x2F;&#x2F;三角形
class Tri :public Shape
&#123;
public:
	Tri(int a, int h)
	&#123;
		this-&gt;a &#x3D; a;
		this-&gt;h &#x3D; h;
	&#125;
	virtual double getArea() &#123;
		cout &lt;&lt; &quot;三角形求面价&quot; &lt;&lt; endl;
		return 0.5*a*h;
	&#125;

private:
	int a;
	int h;
&#125;;

&#x2F;&#x2F;正方形：
&#x2F;&#x2F;如果说一个普通类，继承拥有纯虚函数的类，如果说不重写纯虚函数，依然是一个抽象类。
&#x2F;&#x2F;依然不能被实例化， 如果想实例化， 必须要重写这个父类中所有纯虚函数
class Rect : public Shape
&#123;
public:
	Rect(int a) &#123;
		this-&gt;a &#x3D; a;
	&#125;
	virtual double getArea() &#123;
		cout &lt;&lt; &quot;正方形求面积&quot; &lt;&lt; endl;
		return a*a;
	&#125;
private:
	int a;&#x2F;&#x2F;正方形边长
&#125;;

class Circle :public Shape
&#123;
public:
	Circle(int r)
	&#123;
		this-&gt;r &#x3D; r;
	&#125;

	virtual double getArea()
	&#123;
		cout &lt;&lt; &quot;圆形求面积&quot; &lt;&lt; endl;

		return 3.14*r * 4;
	&#125;


private:
	int  r;
&#125;;


&#x2F;&#x2F;面向抽象类写一个架构函数
void printArea(Shape *sp)
&#123;
	sp-&gt;getArea();
&#125;

&#x2F;&#x2F;业务层  面向的抽象类编程
int main(void)
&#123;
	&#x2F;&#x2F;main 中所有使用的变量类型 都是 抽象类Shape的类型。
	Shape *sp1 &#x3D; new Rect(10);
	&#x2F;&#x2F;sp1-&gt;getArea();

	Shape *sp2 &#x3D; new Circle(20);
	&#x2F;&#x2F;sp2-&gt;getArea();

	Shape *sp3 &#x3D; new Tri(10, 20);
	&#x2F;&#x2F;sp3-&gt;getArea();


	printArea(sp1);
	printArea(sp2);
	printArea(sp3);

	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="抽象类在多继承中的应用"><a href="#抽象类在多继承中的应用" class="headerlink" title="抽象类在多继承中的应用"></a>抽象类在多继承中的应用</h4><ul>
<li>绝大多数面向对象语言都不支持多继承,绝大多数面向对象语言都支持接口的概念</li>
<li>C++中没有接口的概念,C++中可以使用纯虚函数实现接口</li>
<li>接口类中只有函数原型定义，没有任何数据的定义.</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
&#x2F;*
C++中没有接口的概念
C++中可以使用纯虚函数实现接口
接口类中只有函数原型定义，没有任何数据的定义。*&#x2F;
class Interface1 &#123;
public:
  virtual void print() &#x3D; 0;
  virtual int add(int a, int b) &#x3D; 0;
&#125;;
class Interface2 &#123;
public:
  virtual void print() &#x3D; 0;
  virtual int add(int a, int b) &#x3D; 0;
  virtual int sub(int a, int b) &#x3D; 0;
&#125;;
class parent &#123;
public:
  int a;
&#125;;
class Child : public parent,public Interface1,public Interface2 &#123;
public:
  void print() &#123; cout &lt;&lt; &quot;Child : :print&quot; &lt;&lt; endl; &#125;;
  int add(int a, int b) &#123; return a + b; &#125;
  int sub(int a, int b) &#123; return a - b; &#125;
&#125;;
int main() &#123;
  Child c;
  c.print();
  cout &lt;&lt; c.add(3,5) &lt;&lt; endl;
  cout &lt;&lt; c.sub(4,6) &lt;&lt; endl;
  Interface1 *i1 &#x3D; &amp;c;
  Interface2 *i2 &#x3D; &amp;c;
  cout &lt;&lt; i1-&gt;add(7,8) &lt;&lt; endl;
  cout &lt;&lt; i2-&gt;add(7,8) &lt;&lt; endl;
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="面向抽象类编程案例"><a href="#面向抽象类编程案例" class="headerlink" title="面向抽象类编程案例"></a>面向抽象类编程案例</h3><ul>
<li>动物园</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;animal.h
#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
using namespace std;

class Animal
&#123;
public:
	&#x2F;&#x2F;纯虚函数，让子类继承并且实现
	virtual void voice() &#x3D; 0;
	Animal();
	virtual ~Animal();
&#125;;


&#x2F;&#x2F;架构函数
&#x2F;&#x2F;让动物叫
void letAnimalCry(Animal *animal);

&#x2F;&#x2F;animal.cpp
#include &quot;Animal.h&quot;

Animal::Animal()
&#123;
	cout &lt;&lt; &quot;animal()..&quot; &lt;&lt; endl;
&#125;
Animal::~Animal()
&#123;
	cout &lt;&lt; &quot;~Animal()...&quot; &lt;&lt; endl;
&#125;

void letAnimalCry(Animal *animal)
&#123;
	animal-&gt;voice();

	if (animal !&#x3D; NULL) &#123;
		delete animal;
	&#125;
&#125;

&#x2F;&#x2F;dog.h
#pragma once
#include &quot;Animal.h&quot;
class Dog : public Animal
&#123;
public:
	Dog();
	~Dog();

	virtual void voice();
&#125;;

&#x2F;&#x2F;dog.cpp
#include &quot;Dog.h&quot;


Dog::Dog()
&#123;
	cout &lt;&lt; &quot;Dog()..&quot; &lt;&lt; endl;
&#125;


Dog::~Dog()
&#123;
	cout &lt;&lt; &quot;~Dog()..&quot; &lt;&lt; endl;
&#125;

void Dog::voice()
&#123;
	cout &lt;&lt; &quot;狗开始哭了， 555&quot; &lt;&lt; endl;
&#125;
&#x2F;&#x2F;cat.h
#pragma once
#include &quot;Animal.h&quot;


class Cat : public Animal
&#123;
public:
	Cat();
	~Cat();

	virtual void voice();
&#125;;

&#x2F;&#x2F;cat.cpp

#include &quot;Cat.h&quot;


Cat::Cat()
&#123;
	cout &lt;&lt; &quot;cat()..&quot; &lt;&lt; endl;

&#125;


Cat::~Cat()
&#123;
	cout &lt;&lt; &quot;~cat()..&quot; &lt;&lt; endl;

&#125;

void Cat::voice()
&#123;
	cout &lt;&lt; &quot;小猫开始哭了，66666&quot; &lt;&lt; endl;
&#125;
&#x2F;&#x2F;main.cpp
#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &quot;Animal.h&quot;
#include &quot;Dog.h&quot;
#include &quot;Cat.h&quot;


using namespace std;

int main(void)
&#123;
	letAnimalCry(new Dog);

	letAnimalCry(new Cat);

#if 0
	Animal *dog &#x3D; new Dog;
	letAnimalCry(dog);
	delete Dog;
#endif

	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>案例2 员工待遇</p>
<p>编写一个C++程序,计算程序员( pro grammer )工资<br>1要求筋计算出初级程序员( junior_ _programmer )中级程序员（mid_programmer )高级程序员( adv_pro grammer)的工资<br>2要求利用抽象类统一界面,方便程序的扩展，比如:新增，计算架构师(architect )的工资</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;


using namespace std;

class Programmer
&#123;
public:
	Programmer(double salary)
	&#123;
		this-&gt;salary &#x3D; salary;
	&#125;
	virtual void printMoney() &#x3D; 0;
	virtual ~Programmer() &#123;

	&#125;

protected:
	double salary;
&#125;;


class Junior_programmer :public Programmer
&#123;
public:
	Junior_programmer(double salary) :Programmer(salary) &#123;

	&#125;
	virtual void printMoney()&#123;
		cout &lt;&lt; &quot;初级程序员的工资是&quot; &lt;&lt; this-&gt;salary &lt;&lt; endl;
	&#125;
&#125;;

class Mid_programmer :public Programmer
&#123;
public:
	Mid_programmer(double salary) :Programmer(salary) &#123;

	&#125;
	virtual void printMoney()&#123;
		cout &lt;&lt; &quot;中级程序员的工资是&quot; &lt;&lt; this-&gt;salary &lt;&lt; endl;
	&#125;
&#125;;

class Adv_programmer :public Programmer
&#123;
public:
	Adv_programmer(double salary) :Programmer(salary) &#123;

	&#125;
	virtual void printMoney()&#123;
		cout &lt;&lt; &quot;高级程序员的工资是&quot; &lt;&lt; this-&gt;salary &lt;&lt; endl;
	&#125;
&#125;;





int main(void)
&#123;

	Programmer * pro1 &#x3D; new Junior_programmer(12000);

	pro1-&gt;printMoney();

	delete pro1;


	Programmer * pro2 &#x3D; new Mid_programmer(15000);
	pro2-&gt;printMoney();
	delete pro2;

	Programmer *pro3 &#x3D; new Adv_programmer(30000);
	pro3-&gt;printMoney();
	delete pro3;


	
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<blockquote>
<p>案例3 电脑组装案例，面向抽象层编程</p>
<p>组装电脑有3个抽象类，抽象的cpu，抽象的显卡，抽象的内存。现在要求组装两台电脑，一台是Intel的CPU，Intel的显卡和Intel的内存。另一台是Intel的CPU、Nvidia的显卡和Kingston的内存条。针对抽象层编程练习完成此题。</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;


using namespace std;

&#x2F;&#x2F;--------  抽象层---------
&#x2F;&#x2F;抽象CPU类
class CPU
&#123;
public:
	CPU();
	virtual void caculate() &#x3D; 0;
&#125;;

&#x2F;&#x2F;抽象的card类
class Card
&#123;
public:
	virtual void display() &#x3D; 0;
&#125;;

&#x2F;&#x2F;抽象的内存类
class Memory
&#123;
public:
	virtual void storage() &#x3D; 0;
&#125;;

&#x2F;&#x2F;架构类
class Computer
&#123;
public:
	Computer(CPU *cpu, Card *card, Memory *mem)
	&#123;
		this-&gt;cpu &#x3D; cpu;
		this-&gt;card &#x3D; card;
		this-&gt;mem &#x3D; mem;
	&#125;

	void work()
	&#123;
		this-&gt;cpu-&gt;caculate();
		this-&gt;card-&gt;display();
		this-&gt;mem-&gt;storage();
	&#125;

	~Computer() &#123;
		if (this-&gt;cpu !&#x3D; NULL) &#123;
			delete this-&gt;cpu;
		&#125;
		if (this-&gt;card !&#x3D; NULL) &#123;
			delete this-&gt;card;
		&#125;
		if (this-&gt;mem !&#x3D; NULL) &#123;
			delete this-&gt;mem;
		&#125;
	&#125;
private:
	CPU* cpu;
	Card*card;
	Memory *mem;
&#125;;
&#x2F;&#x2F; --------------------------

&#x2F;&#x2F;-----------实现层----------
&#x2F;&#x2F;具体的IntelCPU
class IntelCPU :public CPU
&#123;
public:
	virtual void caculate() &#123;
		cout &lt;&lt; &quot;Intel CPU开始计算了&quot; &lt;&lt; endl;
	&#125;
&#125;;

class IntelCard :public Card
&#123;
public:
	virtual void display() &#123;
		cout &lt;&lt; &quot;Intel Card开始显示了&quot; &lt;&lt; endl;

	&#125;
&#125;;

class IntelMem :public Memory &#123;
public:
	virtual void storage() &#123;
		cout &lt;&lt; &quot;Intel mem开始存储了&quot; &lt;&lt; endl;

	&#125;
&#125;;

class NvidiaCard :public Card
&#123;
public:
	virtual void display() &#123;
		cout &lt;&lt; &quot;Nvidia 显卡开始显示了&quot; &lt;&lt; endl;
	&#125;
&#125;;

class KingstonMem :public Memory &#123;
public:
	virtual void storage() &#123;
		cout &lt;&lt; &quot;KingstonMem 开始存储了&quot; &lt;&lt; endl;
	&#125;
&#125;;

&#x2F;&#x2F;--------------------------



&#x2F;&#x2F;--------业务层-------------------
int main(void)
&#123;
	&#x2F;&#x2F;1 组装第一台intel系列的电脑
#if 0
	CPU *intelCpu &#x3D; new IntelCPU;
	Card *intelCard &#x3D; new IntelCard;
	Memory *intelMem &#x3D; new IntelMem;

	Computer *com1 &#x3D; new Computer(intelCpu, intelCard, intelMem);

	com1-&gt;work();

	Card *nCard &#x3D; new NvidiaCard;
	Memory* kMem &#x3D; new KingstonMem;

	Computer *com2 &#x3D; new Computer(intelCpu, nCard, kMem);

	com2-&gt;work();

	delete intelCpu;
#endif
	Computer *com1 &#x3D; new Computer(new IntelCPU, new IntelCard, new IntelMem);
	com1-&gt;work();
	delete com1;


	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>案例四： 几何图形多态联系</p>
<p>​    设计一个基类Shape包含成员函数Show()，将Show()声明为纯虚函数。Shape类公有派生矩形类Square (正方形)和圆类Circle (圆形），<br>​    问题1∶分别定义Show()实现其主要集合元素的显示。使用抽象类Shape类型的指针，当它指向某个派生类的对象时，就可以通过访问该对象的虚函数成员Show()。<br>​    问题2∶用ShowArea()分别显示各种图形的面积.最后还要显示所有图形的各个面积。要求积累指针数组，数组的每个元素指向一个派生类对象。</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;


using namespace std;


&#x2F;&#x2F;抽象的图形类
class Shape
&#123;
public:
	&#x2F;&#x2F;打印出图形的基本的属性
	virtual void show() &#x3D; 0;
	&#x2F;&#x2F;得到图形的面积
	virtual double getArea() &#x3D; 0;

	virtual ~Shape() &#123;

	&#125;
&#125;;

&#x2F;&#x2F;圆类
class Circle :public Shape
&#123;
public:
	Circle(double r) &#123;
		this-&gt;r &#x3D; r;
	&#125;

	&#x2F;&#x2F;打印出图形的基本你属性
	virtual void show()  &#123;
		cout &lt;&lt; &quot;圆的半径是 &quot; &lt;&lt; r &lt;&lt; endl;
	&#125;
	&#x2F;&#x2F;得到图形的面积
	virtual double getArea()  &#123;
		cout &lt;&lt; &quot;获取圆的面积&quot; &lt;&lt; endl;
		return this-&gt;r*this-&gt;r *3.14;
	&#125;
	~Circle() &#123;
		cout &lt;&lt; &quot;圆的析构函数。。&quot; &lt;&lt; endl;
	&#125;
private:
	double r;
&#125;;

class Square :public Shape
&#123;
public:
	Square(double a) &#123;
		this-&gt;a &#x3D; a;
	&#125;

	&#x2F;&#x2F;打印出图形的基本你属性
	virtual void show() &#123;
		cout &lt;&lt; &quot;正方形的边长是&quot; &lt;&lt; this-&gt;a &lt;&lt; endl;
	&#125;
	&#x2F;&#x2F;得到图形的面积
	virtual double getArea() &#123;
		cout &lt;&lt; &quot;得到正方形的面积&quot; &lt;&lt; endl;
		return a*a;
	&#125;


	~Square() &#123;
		cout &lt;&lt; &quot;正方形的析构函数&quot; &lt;&lt; endl;
	&#125;
private:
	double a;
&#125;;



int main(void)
&#123;
	Shape *array[2] &#x3D; &#123; 0 &#125;;

	for (int i &#x3D; 0; i &lt; 2; i++) &#123;
		&#x2F;&#x2F;生成一个圆
		if (i &#x3D;&#x3D; 0) &#123;
			double r;
			cout &lt;&lt; &quot;请输入圆的半径&quot; &lt;&lt; endl;
			cin &gt;&gt; r;
			array[i] &#x3D; new Circle(r);
		&#125;
		&#x2F;&#x2F;生成一个正方形
		else &#123;
			double a;
			cout &lt;&lt; &quot;请输入正方形的边长&quot; &lt;&lt; endl;
			cin &gt;&gt; a;
			array[i] &#x3D; new Square(a);
		&#125;
	&#125;


	&#x2F;&#x2F;遍历这个array数组
	for (int i &#x3D; 0; i &lt; 2; i++) &#123;
		array[i]-&gt;show();
		cout &lt;&lt; array[i]-&gt;getArea() &lt;&lt; endl;

		delete array[i];
	&#125;

	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>




<blockquote>
<p>案例5 企业员工信息管理系统</p>
<p>一个小型公司的人员信息管理系统<br>某小型公司,主要有四类人员:经理、技术人员、销售经理和推销员。现在,需要存储这些人员的姓名、编号、级别、当月薪水.计算月薪总额并显示全部信息。<br>人员编号基数为1000,每输入一个人员信息编号顺序加1。<br>程序要有对所有人员提升级别的功能。本例中为简单起见,所有人员的初始级别均为1级。然后进行升级,经理升为4级,技术人员和销售经理升为3级,推销员仍为1级。<br>月薪计算办法是:经理拿固定月薪8000元;技术人员按每小时100元领取月薪;推销员的月薪按该推销员当月销售额的4%提成;销售经理既拿固定月薪也领取销售提成,固定月薪为5000元,销售提成为所管辖部门当月销售总额的5%</p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;Employee.h
#pragma once
#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;


&#x2F;&#x2F;抽象的员工 
class Employee
&#123;
public:
	Employee();
	virtual ~Employee();

	&#x2F;&#x2F;提供一个现实的初始化员工的函数
	virtual void init() &#x3D; 0;

	&#x2F;&#x2F;提供员工薪资的计算方法
	virtual void getPay() &#x3D; 0;
	&#x2F;&#x2F;显示员工的信息
	void displayStatus();
	&#x2F;&#x2F;提供修改员工级别的方法
	virtual void upLevel(int level) &#x3D; 0;

protected:
	string name;&#x2F;&#x2F;姓名
	int id;&#x2F;&#x2F;编号
	double salary;&#x2F;&#x2F;薪资
	int level;&#x2F;&#x2F;级别

	&#x2F;&#x2F;员工的编号基础值
	static int startNum;
&#125;;

&#x2F;&#x2F;Employee.cpp
#include &quot;Employee.h&quot;

int Employee::startNum &#x3D; 1000;


Employee::Employee()
&#123;
	cout &lt;&lt; &quot;Employee()...&quot; &lt;&lt; endl;
	id &#x3D; startNum++;
	level &#x3D; 1;
	salary &#x3D; 0.0;
&#125;


Employee::~Employee()
&#123;
	cout &lt;&lt; &quot;~Employee()..&quot; &lt;&lt; endl;
&#125;


void Employee::displayStatus()
&#123;
	cout &lt;&lt; &quot;员工姓名&quot; &lt;&lt; this-&gt;name &lt;&lt; endl;
	cout &lt;&lt; &quot;员工的级别&quot; &lt;&lt; this-&gt;level &lt;&lt; endl;
	cout &lt;&lt; &quot;员工的月薪 &quot; &lt;&lt; this-&gt;salary &lt;&lt; endl;
	cout &lt;&lt; &quot;员工的ID&quot; &lt;&lt; this-&gt;id &lt;&lt; endl;
&#125;
&#x2F;&#x2F;Manager.h
#pragma once
#include &quot;Employee.h&quot;


class Manager : virtual public Employee
&#123;
public:
	Manager();
	~Manager();

	&#x2F;&#x2F;提供一个现实的初始化员工的函数
	virtual void init();

	virtual void getPay();

	&#x2F;&#x2F;提供修改员工级别的方法
	virtual void upLevel(int level);

protected:
	double fixSalary;&#x2F;&#x2F;经理的固定工资
&#125;;

&#x2F;&#x2F;Manager.cpp
#include &quot;Manager.h&quot;


Manager::Manager()
&#123;
	cout &lt;&lt; &quot;Manager()..&quot; &lt;&lt; endl;

&#125;

void Manager::init()
&#123;
	cout &lt;&lt; &quot;请输入经理的姓名&quot; &lt;&lt; endl;
	cin &gt;&gt; name;
	this-&gt;fixSalary &#x3D; 8000;
&#125;



Manager::~Manager()
&#123;
	cout &lt;&lt; &quot;~Manager()..&quot; &lt;&lt; endl;
&#125;


void Manager::getPay()
&#123;
	&#x2F;&#x2F;计算薪水的方式
	this-&gt;salary &#x3D; this-&gt;fixSalary;
&#125;

&#x2F;&#x2F;提供修改员工级别的方法
void Manager::upLevel(int level) &#123;
	this-&gt;level +&#x3D; level;

	if (this-&gt;level &#x3D;&#x3D; 1) &#123;
		this-&gt;fixSalary &#x3D; 8000;
	&#125;
	else if(this-&gt;level &#x3D;&#x3D; 2)&#123;
		this-&gt;fixSalary &#x3D; 10000;
	&#125;
&#125;

&#x2F;&#x2F;SaleMan.h
#pragma once
#include &quot;Employee.h&quot;
class SalesMan : virtual public Employee
&#123;
public:
	SalesMan();
	~SalesMan();

	&#x2F;&#x2F;提供员工薪资的计算方法
	virtual void getPay();

	virtual void init();

	&#x2F;&#x2F;提供修改员工级别的方法
	virtual void upLevel(int level);

protected:
	&#x2F;&#x2F;当月的销售额
	int saleAmount;
	&#x2F;&#x2F;提成的比率
	double salePercent;
&#125;;

&#x2F;&#x2F;SaleMan.cpp
#include &quot;SalesMan.h&quot;


SalesMan::SalesMan()
&#123;
	cout &lt;&lt; &quot;SaleMan()...&quot; &lt;&lt; endl;

&#125;

 void SalesMan::init()
&#123;
	 cout &lt;&lt; &quot;请输入销售员工的姓名&quot; &lt;&lt; endl;
	 cin &gt;&gt; this-&gt;name;
	 this-&gt;salePercent &#x3D; 0.04;
&#125;

SalesMan::~SalesMan()
&#123;
	cout &lt;&lt; &quot;~SaleMan()..&quot; &lt;&lt; endl;
&#125;


&#x2F;&#x2F;提供员工薪资的计算方法
void SalesMan::getPay()
&#123;
	cout &lt;&lt; &quot;请输入当月的销售额&quot; &lt;&lt; endl;
	cin &gt;&gt; this-&gt;saleAmount;

	&#x2F;&#x2F;计算当月的月薪
	this-&gt;salary &#x3D; this-&gt;saleAmount *this-&gt;salePercent;
&#125;

&#x2F;&#x2F;提供修改员工级别的方法
void SalesMan::upLevel(int level)
&#123;
	this-&gt;level +&#x3D; level;
	if (this-&gt;level &#x3D;&#x3D; 1) &#123;
		this-&gt;salePercent &#x3D; 0.04;
	&#125;
&#125;
&#x2F;&#x2F;SalesManager.h
#pragma once
#include &quot;Manager.h&quot;
#include &quot;SalesMan.h&quot;

class SalesManager :public Manager, public SalesMan
&#123;
public:
	SalesManager();
	~SalesManager();

	virtual void init();

	&#x2F;&#x2F;提供员工薪资的计算方法
	virtual void getPay();

	&#x2F;&#x2F;提供修改员工级别的方法
	virtual void upLevel(int level);
&#125;;

&#x2F;&#x2F;SaleManager.cpp
#include &quot;SalesManager.h&quot;


SalesManager::SalesManager()
&#123;
	cout &lt;&lt; &quot;SalesManager()..&quot; &lt;&lt; endl;

&#125;

void SalesManager::init()
&#123;
	cout &lt;&lt; &quot;请输入销售经理的姓名&quot; &lt;&lt; endl;
	cin &gt;&gt; name;
	fixSalary &#x3D; 5000;
	salePercent &#x3D; 0.05;
&#125;



SalesManager::~SalesManager()
&#123;
	cout &lt;&lt; &quot;~SalesManager()...&quot; &lt;&lt; endl;
&#125;

&#x2F;&#x2F;提供员工薪资的计算方法
void SalesManager::getPay()
&#123;
	cout &lt;&lt; &quot;请输入当月的销售额&quot; &lt;&lt; endl;
	cin &gt;&gt; this-&gt;saleAmount;

	this-&gt;salary &#x3D; this-&gt;saleAmount*this-&gt;salePercent + this-&gt;fixSalary;
&#125;

&#x2F;&#x2F;提供修改员工级别的方法
 void SalesManager::upLevel(int level)
 &#123;
	 this-&gt;level +&#x3D; level;
&#125;

&#x2F;&#x2F;Technician.h
#pragma once
#include &quot;Employee.h&quot;


class Technician : public Employee
&#123;
public:
	Technician();
	~Technician();

	virtual void init();

	&#x2F;&#x2F;提供员工薪资的计算方法
	virtual void getPay();

	&#x2F;&#x2F;升级的方法
	virtual void upLevel(int level);
private:
	&#x2F;&#x2F;一个月工作了多少小时
	int workHour;
	&#x2F;&#x2F;每小时多钱
	double perHourMoney;
&#125;;

&#x2F;&#x2F;Technican.cpp
#include &quot;Technician.h&quot;


Technician::Technician()
&#123;
	cout &lt;&lt; &quot;Technician()..&quot; &lt;&lt; endl;

&#125;

void Technician::init()
&#123;
	cout &lt;&lt; &quot;请输入员工的姓名&quot; &lt;&lt; endl;
	cin &gt;&gt; name;
	perHourMoney &#x3D; 100;&#x2F;&#x2F;默认员工每小时赚100元
&#125;


Technician::~Technician()
&#123;
	cout &lt;&lt; &quot;~Technician()...&quot; &lt;&lt; endl;
&#125;

&#x2F;&#x2F;提供员工薪资的计算方法
void Technician::getPay()
&#123;
	cout &lt;&lt; &quot;请输入该员工 一共工作了多少小时&quot; &lt;&lt; endl;
	cin &gt;&gt; workHour;

	this-&gt;salary &#x3D; this-&gt;perHourMoney * this-&gt;workHour;
&#125;

&#x2F;&#x2F;升级的方法
void Technician::upLevel(int level)
&#123;
	this-&gt;level +&#x3D; level;

&#125;

&#x2F;&#x2F;main.cpp
#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;
#include &quot;Employee.h&quot;
#include &quot;Technician.h&quot;
#include &quot;Manager.h&quot;
#include &quot;SalesMan.h&quot;
#include &quot;SalesManager.h&quot;

using namespace std;

int main(void)
&#123;

#if 0
	Employee *em1 &#x3D; new Technician;

	em1-&gt;getPay();
	em1-&gt;upLevel(1);
	em1-&gt;displayStatus();

	delete em1;
#endif
#if 0
	Employee *em &#x3D; new Manager;
	em-&gt;upLevel(1);
	em-&gt;getPay();
	em-&gt;displayStatus();
	
	delete em;
#endif 
#if 0
	Employee *em &#x3D; new SalesMan;

	em-&gt;upLevel(0);
	em-&gt;getPay();
	em-&gt;displayStatus();

	delete em;
#endif
#if 0
	Employee *em &#x3D; new SalesManager;
	
	em-&gt;init();
	em-&gt;upLevel(1);
	em-&gt;getPay();
	em-&gt;displayStatus();

	delete em;
#endif
	Employee *person_array[] &#x3D; &#123;new Technician, new Manager, new SalesMan, new SalesManager&#125;;

	for (int i &#x3D; 0; i &lt; sizeof(person_array) &#x2F; sizeof(person_array[0]); i++) &#123;
		person_array[i]-&gt;init();
		person_array[i]-&gt;upLevel(0);
		person_array[i]-&gt;getPay();
		person_array[i]-&gt;displayStatus();
	&#125;

	for (int i &#x3D; 0; i &lt; sizeof(person_array) &#x2F; sizeof(person_array[0]); i++) &#123;
		delete person_array[i];
	&#125;



	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="http://qiniu.orangew.cn/img/20220705214630.png" alt="20220705214630"></p>
<h3 id="C语言中的面向接口编程"><a href="#C语言中的面向接口编程" class="headerlink" title="C语言中的面向接口编程"></a>C语言中的面向接口编程</h3><ul>
<li>函数三要素：名称、参数、返回值</li>
<li>如何定义一个数组类和一个数组指针</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;


using namespace std;

&#x2F;&#x2F;方法一： 直接定义一个数组类型
typedef int(ARRAY_INT_10)[10];


&#x2F;&#x2F;方法二：
typedef int(*ARRAY_INT_10_P)[10];

int main(void)
&#123;
	int array[10]; &#x2F;&#x2F;array 应该是一个指向int类型指针。

	&#x2F;&#x2F;方法一：
	&#x2F;&#x2F;ARRAY_INT_10 *array_10_p &#x3D; &amp;array; &#x2F;&#x2F;*array_10_p &#x3D;&#x3D;&#x3D; array

	&#x2F;&#x2F;方法二：
	ARRAY_INT_10_P array_10_p &#x3D; &amp;array;

	for (int i &#x3D; 0; i &lt; 10; i++) &#123;
		(*array_10_p)[i] &#x3D; i + 10;
	&#125;

	for (int i &#x3D; 0; i &lt; 10; i++) &#123;
		cout &lt;&lt; array[i] &lt;&lt; endl;
	&#125;

	&#x2F;&#x2F;方法三：
	int(*p)[10] &#x3D; &amp;array;

	cout &lt;&lt; &quot;------&quot; &lt;&lt; endl;
	for (int i &#x3D; 0; i &lt; 10; i++) &#123;
		cout &lt;&lt; (*p)[i] &lt;&lt; endl;
	&#125;

	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="函数类型语法基础"><a href="#函数类型语法基础" class="headerlink" title="函数类型语法基础"></a>函数类型语法基础</h4><ul>
<li>函数指针用于指向一个函数,函数名是函数体的入口地址<ul>
<li>可通过函数类型定义函数指针: FuncType* pointer;</li>
<li>也可以直接定义: type (*pointer)(parameter list);<ul>
<li>pointer为函数指针变量名</li>
<li>type为指向函数的返回值类型</li>
<li>parameter list为指向函数的参数类型列表</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;
typedef int(FUNC)(int); &#x2F;&#x2F;定义一个函数类型
int test(int i)         &#x2F;&#x2F; 定义一个函数
&#123;
  return i * i;
&#125;
void f() &#x2F;&#x2F; 定义一个函数
&#123;
  printf(&quot;Call f().. . \n&quot;);
&#125;
int main() &#123;
  FUNC *pt &#x3D; test;
  &#x2F;&#x2F; 定义一个指向函数的类型FUNC的指针pt，
  &#x2F;&#x2F;并初始化指向test函数
  printf(&quot;Function pointer call: %d\n&quot;, pt(3)); &#x2F;&#x2F;通过函数指针pt间接调用test
  void (*pf)() &#x3D; &amp;f; &#x2F;&#x2F;直接定义一个函数指针指向f
  pf();
  &#x2F;&#x2F;通过函数指针间接调用
  (*pf)();
  &#x2F;&#x2F; 通过函数指针间接调用等价于上述调用方法
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="函数指针做函数参数"><a href="#函数指针做函数参数" class="headerlink" title="函数指针做函数参数"></a>函数指针做函数参数</h4><ul>
<li>当函数指针做为函数的参数，传递给一个被调用函数，被调用函数就可以通过这个指针调用外部的函数，这就形成了回调。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;
int add(int a, int b);
int libfun(int (*pDis)(int a, int b));
int main(void) &#123;
  int (*pfun)(int a, int b); &#x2F;&#x2F;定义一个函数指针pfun 指向int ()(int, int)函数类型
  pfun &#x3D; add;
  libfun(pfun);
  return 0;
&#125;
int add(int a, int b) &#123; return a + b; &#125;
int libfun(int (*pDis)(int a, int b)) &#123;
  int a, b;
  a &#x3D; 1;
  b &#x3D; 2;
  add(1, 3);
  &#x2F;&#x2F; 直接调用add函数
  printf(&quot;%d&quot;, pDis(a, b)); &#x2F;&#x2F;通过函数指针做函数参数,间接调用add函数
  return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="函数指针的工程意义"><a href="#函数指针的工程意义" class="headerlink" title="函数指针的工程意义"></a>函数指针的工程意义</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;


using namespace std;

int func(int a, int b)
&#123;
	cout &lt;&lt; &quot; 1999 年写的 func&quot; &lt;&lt; endl;

	return 0;
&#125;

int func2(int a, int b)
&#123;
	cout &lt;&lt; &quot;1999 写的 func2&quot; &lt;&lt; endl;
	return 0;
&#125;

int func3(int a, int b) 
&#123;
	cout &lt;&lt; &quot;1999年 写的 func3 &quot; &lt;&lt; endl;
	return 0;
&#125;

&#x2F;&#x2F;2018想添加一个新的子业务
int new_func4(int a, int b)
&#123;
	cout &lt;&lt; &quot;2018 新写的子业务&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; &quot;, b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;
	return 0;
&#125;

&#x2F;&#x2F;方法一：  函数的返回值， 函数的参数列表（形参的个数，类型，顺序）
&#x2F;&#x2F;定义一个函数类型。

typedef int(FUNC)(int, int);

&#x2F;&#x2F;方法二：   定义一个函数指针
typedef int(*FUNC_P)(int, int);


&#x2F;&#x2F;定义一个统一的接口 将他们全部调用起来。

void my_funtion(int(*fp)(int, int), int a, int b)
&#123;
	cout &lt;&lt; &quot;1999年实现这个架构业务&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;固定业务1&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;固定业务2&quot; &lt;&lt; endl;

	fp(a, b);&#x2F;&#x2F;可变的业务

	cout &lt;&lt; &quot;固定业务3&quot; &lt;&lt; endl;

&#125;

int main(void)
&#123;
#if 0
	&#x2F;&#x2F;方法一：
	FUNC *fp &#x3D; NULL;

	fp &#x3D; func;
	fp(10, 20);

	FUNC_P fp2 &#x3D; NULL;

	fp2 &#x3D; func;

	fp2(100, 200);

	&#x2F;&#x2F;方法三：
	int(*fp3)(int, int)   &#x3D; NULL;
	fp3 &#x3D; func;
	fp3(1000, 3000);
#endif
	my_funtion(func, 10, 20);
	my_funtion(func2, 100, 200);
	my_funtion(func3, 1000, 2000);

	my_funtion(new_func4, 2000, 3000);
	
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<ul>
<li><p>回调函数的优点</p>
<ul>
<li>函数的调用和函数的实现有效的分离</li>
<li>类似C++的多态,可扩展</li>
</ul>
</li>
<li><p>现在这几个函数是在同一个文件当中</p>
</li>
<li><p><code>int libfun(int (*pDis)(int a, int b))</code></p>
</li>
<li><p>是一个库中的函数，就只有使用回调了，通过函数指针参数将外部函数地址传入来实现调用。</p>
</li>
<li><p>函数add的代码作了修改，也不必改动库的代码，就可以正常实现调用便于程序的维护和升级。</p>
</li>
<li><p>多态案例：诸葛亮的锦囊妙计</p>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include &lt;iostream&gt;


using namespace std;
&#x2F;&#x2F;-------------抽象层------------
&#x2F;&#x2F;定义拆开锦囊方法的类型。
typedef void(TIPS)(void);

&#x2F;&#x2F;定义锦囊
struct tip
&#123;
	char from[64]; &#x2F;&#x2F;谁写的
	char to[64];&#x2F;&#x2F;写给谁的。
	&#x2F;&#x2F;锦囊的内容
	TIPS *tp;&#x2F;&#x2F;相当于抽象类的 纯虚函数.
&#125;;

&#x2F;&#x2F;需要一个打开锦囊的架构函数
void open_tips(struct tip *tip_p)
&#123;
	cout &lt;&lt; &quot;打开了锦囊&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;此锦囊是由&quot; &lt;&lt; tip_p-&gt;from &lt;&lt; &quot;写给 &quot; &lt;&lt; tip_p-&gt;to &lt;&lt; &quot;的。&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;内容是&quot; &lt;&lt; endl;
	tip_p-&gt;tp(); &#x2F;&#x2F;此时就发生了多态现象。
&#125;

&#x2F;&#x2F;提供一个创建一个锦囊的方法
struct tip* create_tip(char*from, char *to, TIPS*tp)
&#123;
	struct tip *temp &#x3D; (struct tip*)malloc(sizeof(struct tip));
	if (temp &#x3D;&#x3D; NULL) &#123;
		return NULL;
	&#125;
	strcpy(temp-&gt;from, from);
	strcpy(temp-&gt;to, to);
	&#x2F;&#x2F;给一个回调函数赋值， 一般称 注册回调函数
	temp-&gt;tp &#x3D; tp;

	return temp;
&#125;

&#x2F;&#x2F;提供一个销毁锦囊的方法
void destory_tip(struct tip *tp)
&#123;
	if (tp !&#x3D; NULL) &#123;
		free(tp);
		tp &#x3D; NULL;
	&#125;
&#125;


&#x2F;&#x2F; ------------- 实现层------------
&#x2F;&#x2F;诸葛亮写了3个锦囊
void tip1_func(void)
&#123;
	cout &lt;&lt; &quot;一到东吴就拜会乔国老&quot; &lt;&lt; endl;
&#125;

void tip2_func(void)
&#123;
	cout &lt;&lt; &quot;如果主公乐不思蜀，就谎称曹贼来袭。赶紧回来 &quot; &lt;&lt; endl;
&#125;

void tip3_func(void)
&#123;
	cout &lt;&lt; &quot;如果被孙权追杀，向孙尚香求救&quot; &lt;&lt; endl;
&#125;

void tip4_func(void)
&#123;
	cout &lt;&lt; &quot;如果求救孙尚香都不灵，  你们去死了， 我是蜀国老大了&quot; &lt;&lt; endl;
&#125;


&#x2F;&#x2F;---------------  业务层-----------------
int main(void)
&#123;
	&#x2F;&#x2F;创建出3个锦囊
	struct tip *tip1 &#x3D; create_tip(&quot;孔明&quot;, &quot;赵云&quot;, tip1_func);
	struct tip *tip2 &#x3D; create_tip(&quot;孔明&quot;, &quot;赵云&quot;, tip2_func);
	struct tip *tip3 &#x3D; create_tip(&quot;孔明&quot;, &quot;赵云&quot;, tip3_func);
	struct tip *tip4 &#x3D; create_tip(&quot;庞统&quot;, &quot;赵云&quot;, tip4_func);

	&#x2F;&#x2F;由赵云进行拆锦囊。
	cout &lt;&lt; &quot;刚刚来到东吴， 赵云打开第一个锦囊&quot; &lt;&lt; endl;
	open_tips(tip1);
	cout &lt;&lt; &quot;-----------&quot; &lt;&lt; endl;

	cout &lt;&lt; &quot;刘备乐不思蜀， 赵云打开第二个锦囊&quot; &lt;&lt; endl;
	open_tips(tip2);
	cout &lt;&lt; &quot;-----------&quot; &lt;&lt; endl;

	cout &lt;&lt; &quot;孙权大军追杀，赵云打开第三个锦囊&quot; &lt;&lt; endl;
	open_tips(tip3);
	cout &lt;&lt; &quot;-----------&quot; &lt;&lt; endl;

	cout &lt;&lt; &quot;赵云发现，实在是杀不动了， 打开了第四个锦囊&quot; &lt;&lt; endl;
	open_tips(tip4);

	destory_tip(tip1);
	destory_tip(tip2);
	destory_tip(tip3);
	destory_tip(tip4);
	
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><ul>
<li>泛型(Generic Programming)即是指具有在多种数据类型上皆可操作的含意。泛型编程的代表作品STL是一种高效、泛型、可交互操作的软件组件。</li>
<li>泛型编程最初诞生于C++中,目的是为了实现C++的STL(标准模板库)。其语言支持机制就是模板(Templates)。模板的精神其实很简单:参数化类型。换句话说,把一个原本特定于某个类型的算法或类当中的类型信息抽掉,抽出来做成模板参数T。</li>
<li>所谓函数模板，实际上是建立一个通用函数，其函数类型和形参类型不具体指定，用一个虚拟的类型来代表。这个通用函数就称为函数模板。</li>
<li><img src="http://qiniu.orangew.cn/img/20220705223315.png" alt="20220705223315"></li>
</ul>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><h4 id="函数重载实现的泛型"><a href="#函数重载实现的泛型" class="headerlink" title="函数重载实现的泛型"></a>函数重载实现的泛型</h4><ul>
<li>写n个函数，交换char类型、int类型变量的值。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
void myswap(int &amp;a,int &amp;b) &#123;
  int t &#x3D; a;
  a &#x3D; b;
  b &#x3D; t;
&#125;
void myswap(char &amp;a, char &amp;b) &#123;
  char t &#x3D; a;
  a &#x3D; b;
  b &#x3D; t;
&#125;
int main(void) &#123;
  int x &#x3D; 1;
  int y &#x3D; 2;
  myswap(x, y);
  cout &lt;&lt; &quot;x: &quot; &lt;&lt; x &lt;&lt; &quot;, y:&quot; &lt;&lt; y &lt;&lt; endl;
  char a &#x3D; &#39;c&#39;;
  char b &#x3D; &#39;b&#39;;
  myswap(a, b);
  cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; &quot;, b:&quot; &lt;&lt; b &lt;&lt; endl;
  return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="函数模板的引入"><a href="#函数模板的引入" class="headerlink" title="函数模板的引入"></a>函数模板的引入</h4><ul>
<li>语法格式</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;
template&lt;class T&gt;
template&lt;typename 类型参数表&gt;
返回类型 函数模板名 (函数参数列表)&#123;
函数模板定义体
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>template是语义是模板的意思,尖括号中先写关键字typename或是class ,后面跟一个类型T,此类即是虚拟的类型。至于为什么用T,用的人多了,也就是T了。</li>
</ul>
<h4 id="函数模板的实例"><a href="#函数模板的实例" class="headerlink" title="函数模板的实例"></a>函数模板的实例</h4><ul>
<li>调用过程是这样的,先将函数模板实再化为函数,然后再发生函数调用。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
template &lt;typename T&gt; 
void myswap(T &amp;a,T &amp;b) &#123;
  T t &#x3D; a;
  a &#x3D; b;
  b &#x3D; t;
&#125;
int main(void) &#123;
  int x &#x3D; 1;
  int y &#x3D; 2;
  myswap(x, y);
  cout &lt;&lt; &quot;x: &quot; &lt;&lt; x &lt;&lt; &quot;, y:&quot; &lt;&lt; y &lt;&lt; endl;
  myswap&lt;int&gt;(x, y);
  cout &lt;&lt; &quot;x: &quot; &lt;&lt; x &lt;&lt; &quot;, y: &quot; &lt;&lt; y &lt;&lt; endl;
  char a &#x3D; &#39;a&#39;;
  char b &#x3D; &#39;b&#39;;
  myswap(a, b);
  cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; &quot;, b: &quot; &lt;&lt; b &lt;&lt; endl;
  myswap&lt;char&gt;(a, b);
  cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; &quot;, b: &quot; &lt;&lt; b &lt;&lt; endl;
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>函数模板,只适用于i函数的参数个数相同而类型不同,且函数体相同的情况。如果个数不同,则不能用函数模板。</li>
<li>练习写一个之化的排序程序，用femPlateT来通用基本类型</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T&gt;
void sortArray(T *array , int num) ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h4 id="函数模板与函数重载"><a href="#函数模板与函数重载" class="headerlink" title="函数模板与函数重载"></a>函数模板与函数重载</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
template &lt;typename T&gt; void myswap(T &amp;a, T &amp;b) &#123;
  T t;
  t &#x3D; a;
  a &#x3D; b;
  b &#x3D; t;
  cout &lt;&lt; &quot;myswap模板函数do&quot; &lt;&lt; endl;
&#125;
void myswap(char &amp;a, int &amp;b) &#123;
  int t;
  t &#x3D; a;
  a &#x3D; b;
  b &#x3D; t;
  cout &lt;&lt; &quot;myswap普通函数do&quot; &lt;&lt; endl;
&#125;
int main() &#123;
  char cData &#x3D; &#39;a&#39;;
  int iData &#x3D; 2;
  &#x2F;&#x2F;编译不通过
  myswap(cData, iData);
  myswap(iData, cData);
  &#x2F;&#x2F; 普通函数会进行隐士的数据类型转换 
   myswap&lt;int&gt;(cData,iData);
  &#x2F;&#x2F; 函数模板不提供隐式的数据类型转换必须是严格的匹配 
  return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>普通函数会进行隐士的数据类型转换,函数模板不提供隐式的数据类型转换必须是严格的匹配。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
int Max(int a, int b) &#123;
  cout &lt;&lt; &quot;int Max(int a, int b)&quot; &lt;&lt; endl;
  return a &gt; b ? a : b;
&#125;
template &lt;typename T&gt; T Max(T a, T b) &#123;
  cout &lt;&lt; &quot;T Max(T a,T b)&quot; &lt;&lt; endl;
  return a &gt; b ? a : b;
&#125;
template &lt;typename T&gt; T Max(T a, T b, T c) &#123;
  cout &lt;&lt; &quot;T Max(T a,T b, T c)&quot; &lt;&lt; endl;
  return Max(Max(a, b), c);
&#125;
int main() &#123;
  int a &#x3D; 1;
  int b &#x3D; 2;
  cout &lt;&lt; Max(a, b) &lt;&lt; endl; &#x2F;&#x2F;当函数模板和普通函数都符合调用时,优先选择普通函数
  cout &lt;&lt; Max&lt;&gt;(a, b) &lt;&lt; endl; &#x2F;&#x2F;若显示使用函数模板,则使用&lt;&gt;类型列表
  cout &lt;&lt; Max(3.0, 4.0) &lt;&lt; endl; &#x2F;&#x2F;如果函数模板产生更好的匹配使用函数模板
  cout &lt;&lt; Max(5.0, 6.0, 7.0) &lt;&lt; endl; &#x2F;&#x2F;重载
  cout &lt;&lt; Max(&#39;a&#39;, 100) &lt;&lt; endl; &#x2F;&#x2F;调用普通函数可以隐式类型转换
  return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>1.当函数模板和普通函数都符合调用时,优先选择普通函数</p>
<p>2.若显示使用函数模板,则使用&lt;&gt;类型列表</p>
<p>3.如果函数模板产生更好的匹配使用函数模板</p>
</blockquote>
<h4 id="编译器对模板机制剖析"><a href="#编译器对模板机制剖析" class="headerlink" title="编译器对模板机制剖析"></a>编译器对模板机制剖析</h4><ul>
<li><p>简析编译器的编译过程</p>
</li>
<li><p><img src="http://qiniu.orangew.cn/img/20220705225904.png" alt="20220705225904"></p>
</li>
<li><blockquote>
<p>g++ -E hello.c -o hello.i（预处理)</p>
<p>g++ -S hello.i -o hello.s(编译)</p>
<p>g++ -c hello.s -o hello.o （汇编)</p>
<p>g++ hello.o -o hello（链接)</p>
<p>以上四个步骤，可合成一个步骤<br>g++ hello.c -o hello （直接编译链接成可执行目标文件)</p>
</blockquote>
</li>
<li><p>test.cpp</p>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
template &lt;class T&gt; 
void mySwap(T &amp;a,T &amp;b) &#123;
  T c &#x3D; a;
  a &#x3D; b;
  b &#x3D; c;
&#125;
int main(void) &#123;
  int x &#x3D; 10;
  int y &#x3D; 20;
  mySwap&lt;int&gt;(x,y);
  cout &lt;&lt; &quot;x: &quot; &lt;&lt; x &lt;&lt; &quot;, y: &quot; &lt;&lt; y &lt;&lt; endl;
  char a &#x3D; &#39;a &#39;;
  char b &#x3D; &#39;b&#39;;
  mySwap&lt;char&gt;(a,b);
  cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; &quot;, b: &quot; &lt;&lt; b &lt;&lt; endl;
  return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p><code>g++ -E test.cpp -o test.s</code></p>
</li>
<li><p>test.s</p>
</li>
</ul>
<pre class="line-numbers language-assembly" data-language="assembly"><code class="language-assembly">	.file	&quot;test.c++&quot;
	.section .rdata,&quot;dr&quot;
__ZStL19piecewise_construct:
	.space 1
.lcomm __ZStL8__ioinit,1,1
	.def	___main;	.scl	2;	.type	32;	.endef
LC0:
	.ascii &quot;x: \0&quot;
LC1:
	.ascii &quot;, y: \0&quot;
LC2:
	.ascii &quot;a: \0&quot;
LC3:
	.ascii &quot;, b: \0&quot;
	.text
	.globl	_main
	.def	_main;	.scl	2;	.type	32;	.endef
_main:
LFB1446:
	.cfi_startproc
	leal	4(%esp), %ecx
	.cfi_def_cfa 1, 0
	andl	$-16, %esp
	pushl	-4(%ecx)
	pushl	%ebp
	.cfi_escape 0x10,0x5,0x2,0x75,0
	movl	%esp, %ebp
	pushl	%esi
	pushl	%ebx
	pushl	%ecx
	.cfi_escape 0xf,0x3,0x75,0x74,0x6
	.cfi_escape 0x10,0x6,0x2,0x75,0x7c
	.cfi_escape 0x10,0x3,0x2,0x75,0x78
	subl	$44, %esp
	call	___main
	movl	$10, -28(%ebp)
	movl	$20, -32(%ebp)
	leal	-32(%ebp), %eax
	movl	%eax, 4(%esp)
	leal	-28(%ebp), %eax
	movl	%eax, (%esp)
	call	__Z6mySwapIiEvRT_S1_
	movl	-32(%ebp), %ebx
	movl	-28(%ebp), %esi
	movl	$LC0, 4(%esp)
	movl	$__ZSt4cout, (%esp)
	call	__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
	movl	%esi, (%esp)
	movl	%eax, %ecx
	call	__ZNSolsEi
	subl	$4, %esp
	movl	$LC1, 4(%esp)
	movl	%eax, (%esp)
	call	__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
	movl	%ebx, (%esp)
	movl	%eax, %ecx
	call	__ZNSolsEi
	subl	$4, %esp
	movl	$__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_, (%esp)
	movl	%eax, %ecx
	call	__ZNSolsEPFRSoS_E
	subl	$4, %esp
	movb	$32, -33(%ebp)
	movb	$98, -34(%ebp)
	leal	-34(%ebp), %eax
	movl	%eax, 4(%esp)
	leal	-33(%ebp), %eax
	movl	%eax, (%esp)
	call	__Z6mySwapIcEvRT_S1_
	movzbl	-34(%ebp), %eax
	movsbl	%al, %ebx
	movzbl	-33(%ebp), %eax
	movsbl	%al, %esi
	movl	$LC2, 4(%esp)
	movl	$__ZSt4cout, (%esp)
	call	__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
	movl	%esi, 4(%esp)
	movl	%eax, (%esp)
	call	__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_c
	movl	$LC3, 4(%esp)
	movl	%eax, (%esp)
	call	__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc
	movl	%ebx, 4(%esp)
	movl	%eax, (%esp)
	call	__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_c
	movl	$__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_, (%esp)
	movl	%eax, %ecx
	call	__ZNSolsEPFRSoS_E
	subl	$4, %esp
	movl	$0, %eax
	leal	-12(%ebp), %esp
	popl	%ecx
	.cfi_restore 1
	.cfi_def_cfa 1, 0
	popl	%ebx
	.cfi_restore 3
	popl	%esi
	.cfi_restore 6
	popl	%ebp
	.cfi_restore 5
	leal	-4(%ecx), %esp
	.cfi_def_cfa 4, 4
	ret
	.cfi_endproc
LFE1446:
	.section	.text$_Z6mySwapIiEvRT_S1_,&quot;x&quot;
	.linkonce discard
	.globl	__Z6mySwapIiEvRT_S1_
	.def	__Z6mySwapIiEvRT_S1_;	.scl	2;	.type	32;	.endef
__Z6mySwapIiEvRT_S1_:
LFB1654:
	.cfi_startproc
	pushl	%ebp
	.cfi_def_cfa_offset 8
	.cfi_offset 5, -8
	movl	%esp, %ebp
	.cfi_def_cfa_register 5
	subl	$16, %esp
	movl	8(%ebp), %eax
	movl	(%eax), %eax
	movl	%eax, -4(%ebp)
	movl	12(%ebp), %eax
	movl	(%eax), %edx
	movl	8(%ebp), %eax
	movl	%edx, (%eax)
	movl	12(%ebp), %eax
	movl	-4(%ebp), %edx
	movl	%edx, (%eax)
	nop
	leave
	.cfi_restore 5
	.cfi_def_cfa 4, 4
	ret
	.cfi_endproc
LFE1654:
	.section	.text$_Z6mySwapIcEvRT_S1_,&quot;x&quot;
	.linkonce discard
	.globl	__Z6mySwapIcEvRT_S1_
	.def	__Z6mySwapIcEvRT_S1_;	.scl	2;	.type	32;	.endef
__Z6mySwapIcEvRT_S1_:
LFB1658:
	.cfi_startproc
	pushl	%ebp
	.cfi_def_cfa_offset 8
	.cfi_offset 5, -8
	movl	%esp, %ebp
	.cfi_def_cfa_register 5
	subl	$16, %esp
	movl	8(%ebp), %eax
	movzbl	(%eax), %eax
	movb	%al, -1(%ebp)
	movl	12(%ebp), %eax
	movzbl	(%eax), %edx
	movl	8(%ebp), %eax
	movb	%dl, (%eax)
	movl	12(%ebp), %eax
	movzbl	-1(%ebp), %edx
	movb	%dl, (%eax)
	nop
	leave
	.cfi_restore 5
	.cfi_def_cfa 4, 4
	ret
	.cfi_endproc
LFE1658:
	.text
	.def	___tcf_0;	.scl	3;	.type	32;	.endef
___tcf_0:
LFB1882:
	.cfi_startproc
	pushl	%ebp
	.cfi_def_cfa_offset 8
	.cfi_offset 5, -8
	movl	%esp, %ebp
	.cfi_def_cfa_register 5
	subl	$8, %esp
	movl	$__ZStL8__ioinit, %ecx
	call	__ZNSt8ios_base4InitD1Ev
	leave
	.cfi_restore 5
	.cfi_def_cfa 4, 4
	ret
	.cfi_endproc
LFE1882:
	.def	__Z41__static_initialization_and_destruction_0ii;	.scl	3;	.type	32;	.endef
__Z41__static_initialization_and_destruction_0ii:
LFB1881:
	.cfi_startproc
	pushl	%ebp
	.cfi_def_cfa_offset 8
	.cfi_offset 5, -8
	movl	%esp, %ebp
	.cfi_def_cfa_register 5
	subl	$24, %esp
	cmpl	$1, 8(%ebp)
	jne	L8
	cmpl	$65535, 12(%ebp)
	jne	L8
	movl	$__ZStL8__ioinit, %ecx
	call	__ZNSt8ios_base4InitC1Ev
	movl	$___tcf_0, (%esp)
	call	_atexit
L8:
	nop
	leave
	.cfi_restore 5
	.cfi_def_cfa 4, 4
	ret
	.cfi_endproc
LFE1881:
	.def	__GLOBAL__sub_I_main;	.scl	3;	.type	32;	.endef
__GLOBAL__sub_I_main:
LFB1883:
	.cfi_startproc
	pushl	%ebp
	.cfi_def_cfa_offset 8
	.cfi_offset 5, -8
	movl	%esp, %ebp
	.cfi_def_cfa_register 5
	subl	$24, %esp
	movl	$65535, 4(%esp)
	movl	$1, (%esp)
	call	__Z41__static_initialization_and_destruction_0ii
	leave
	.cfi_restore 5
	.cfi_def_cfa 4, 4
	ret
	.cfi_endproc
LFE1883:
	.section	.ctors,&quot;w&quot;
	.align 4
	.long	__GLOBAL__sub_I_main
	.ident	&quot;GCC: (MinGW.org GCC-6.3.0-1) 6.3.0&quot;
	.def	__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc;	.scl	2;	.type	32;	.endef
	.def	__ZNSolsEi;	.scl	2;	.type	32;	.endef
	.def	__ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_;	.scl	2;	.type	32;	.endef
	.def	__ZNSolsEPFRSoS_E;	.scl	2;	.type	32;	.endef
	.def	__ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_c;	.scl	2;	.type	32;	.endef
	.def	__ZNSt8ios_base4InitD1Ev;	.scl	2;	.type	32;	.endef
	.def	__ZNSt8ios_base4InitC1Ev;	.scl	2;	.type	32;	.endef
	.def	_atexit;	.scl	2;	.type	32;	.endef
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>1.编译器并不是把函数模板处理成能够处理任意类的函数</p>
<p>2.编译器从函数模板通过具体类型产生不同的函数</p>
<p>3.编译器会对函数模板进行两次编译,在声明的地方对模板代码本身进行编译;</p>
<p>在调用的地方对参数替换后的代码进行编译。</p>
</blockquote>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><h4 id="类模板定义"><a href="#类模板定义" class="headerlink" title="类模板定义"></a>类模板定义</h4><ul>
<li><p>类模板与函数模板的定义和使用类似，我们已经进行了介绍。有时，有两个或多个类，其功能是相同的，仅仅是数据类型不同，所以将类中的类型进行泛化。</p>
</li>
<li><blockquote>
<p>template<typename T>class A<br>{<br>}</p>
</blockquote>
</li>
</ul>
<h4 id="简单的模板类"><a href="#简单的模板类" class="headerlink" title="简单的模板类"></a>简单的模板类</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
template &lt;typename T&gt;
&#x2F;&#x2F;定义类模板要在类的头部之前加入template&lt;typename T&gt;或者template &lt;class T&gt;
class A &#123;
public:
  A(T t) &#123; this-&gt;t &#x3D; t; &#125;
  T &amp;getT() &#123; return t; &#125;

public:
  T t;
&#125;;
int main(void) &#123;
  &#x2F;&#x2F;在定义一个对象的时候，要明确此类所泛化的具体类型
  A&lt;int&gt; a(100);
  cout &lt;&lt; a.getT() &lt;&lt; endl;
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="模板类的诞生"><a href="#模板类的诞生" class="headerlink" title="模板类的诞生"></a>模板类的诞生</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
template &lt;class T&gt;
class A
&#123;
public:
  A(T a) &#123; this-&gt;a &#x3D; a; &#125;

protected:
  T a;
&#125;;
&#x2F;&#x2F;模板类派生普通类
&#x2F;&#x2F;结论:子类从模板类继承的时候,需要让编译器知道父类的数据类型具体是什么(数据类型的本质:固定大小内存块的别名)A&lt;int&gt;
class B : public A&lt;int&gt;
&#123;
public:
  B(int a, int b) : A&lt;int&gt;(a) &#123; this-&gt;b &#x3D; b; &#125;
  void printB() &#123; cout &lt;&lt; &quot;b:&quot; &lt;&lt; b &lt;&lt; endl; &#125;

private:
  int b;
&#125;;
&#x2F;&#x2F;模板类派生模板类
template &lt;class T&gt;
class C : public A&lt;T&gt;
&#123;
public:
  C(T a, T c) : A&lt;T&gt;(a) &#123; this-&gt;c &#x3D; c; &#125;
  void printc() &#123; cout &lt;&lt; &quot;C : &quot; &lt;&lt; c &lt;&lt; endl; &#125;

private:
  T c;
&#125;;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="模板类的实现"><a href="#模板类的实现" class="headerlink" title="模板类的实现"></a>模板类的实现</h3><h4 id="函数体写在类中"><a href="#函数体写在类中" class="headerlink" title="函数体写在类中"></a>函数体写在类中</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
template &lt;class T&gt;
class Complex
&#123;
  friend ostream &amp;operator&lt;&lt;(ostream &amp;os, Complex &amp;c)
  &#123;
    os &lt;&lt; &quot;(&quot; &lt;&lt; c.a &lt;&lt; &quot; + &quot; &lt;&lt; c.b &lt;&lt; &quot;i&quot;
       &lt;&lt; &quot;)&quot;;
    return os;
  &#125;

public:
  Complex()
  &#123;
  &#125;
  complex(T a, T b)
  &#123;
    this-&gt;a &#x3D; a;
    this-&gt;b &#x3D; b;
  &#125;
  void printComplex()
  &#123;
    cout
        &lt;&lt; &quot;( &quot; &lt;&lt; a &lt;&lt; &quot; + &quot; &lt;&lt; b &lt;&lt; &quot;i&quot;
        &lt;&lt; &quot; )&quot; &lt;&lt; endl;
  &#125;
  Complex operator+(Complex &amp;another)
  &#123;
    Complex temp(a + another.a, b + another.b);
    return temp;
  &#125;

private:
  T a;
  T b;
&#125;;
int main(void)
&#123;
  Complex&lt;int&gt; a(10, 20); &#x2F;&#x2F;让模板类具体化是为了告诉编译具体的大小，分配内存
  Complex&lt;int&gt; b(3, 4);
  a.printComplex();
  Complex&lt;int&gt; c;
  c &#x3D; a + b; &#x2F;&#x2F; complex c.operator+(Complex &amp; another)
  c.printComplex();
  cout &lt;&lt; c &lt;&lt; endl;
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="函数体写在类外（在一个CPP中）"><a href="#函数体写在类外（在一个CPP中）" class="headerlink" title="函数体写在类外（在一个CPP中）"></a>函数体写在类外（在一个CPP中）</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
template &lt;class T&gt;
class Complex;

template &lt;class T&gt;
Complex&lt;T&gt; mySub(Complex&lt;T&gt; &amp;one, Complex&lt;T&gt; &amp;another);

template &lt;class T&gt;
class Complex
&#123;
public:
  friend ostream &amp; operator&lt;&lt; &lt;T&gt;(ostream &amp;os, Complex&lt;T&gt; &amp;c);
  &#x2F;&#x2F;在模板类中如果有友元重载操作符&lt;&lt;或者&gt;&gt;需要在operator&lt;&lt;和参数列表之间
  &#x2F;&#x2F;加入&lt;T&gt;
  &#x2F;&#x2F;滥用友元函数，本来可以当成员函数, 却要用友元函数
  &#x2F;&#x2F;如果说是非&lt;&lt;&gt;&gt;在模板类中当友元函数
  &#x2F;&#x2F;在这个模板类之前声明这个函数
  friend Complex&lt;T&gt; mySub&lt;T&gt;(Complex&lt;T&gt; &amp;one, Complex&lt;T&gt; &amp;another);
  &#x2F;&#x2F;最终的结论，模板类不要轻易写友元函数，要写的就写&lt;&lt;和&gt;&gt;。
  Complex();
  Complex(T a, T b);
  Complex operator+(Complex &amp;another);
  Complex operator-(Complex &amp;another);
  void printComplex();

private:
  T a;
  T b;
&#125;;
template &lt;class T&gt;
Complex&lt;T&gt;::Complex()
&#123;
&#125;
template &lt;class T&gt;
Complex&lt;T&gt;::Complex(T a, T b)
&#123;
  this-&gt;a &#x3D; a;
  this-&gt;b &#x3D; b;
&#125;
template &lt;class T&gt;
void Complex&lt;T&gt;::printComplex()
&#123;
  cout
      &lt;&lt; &quot;( &quot;
      &lt;&lt; a
      &lt;&lt; &quot; + &quot;
      &lt;&lt; b
      &lt;&lt; &quot;i&quot;
      &lt;&lt; &quot;)&quot;
      &lt;&lt; endl;
&#125;
template &lt;class T&gt;
Complex&lt;T&gt; Complex&lt;T&gt;::operator+(Complex&lt;T&gt; &amp;another)
&#123;
  Complex temp(a + another.a, b + another.b);
  return temp;
&#125;
template &lt;class T&gt;
Complex&lt;T&gt; Complex&lt;T&gt;::operator-(Complex&lt;T&gt; &amp;another)
&#123;
  Complex temp(this-&gt;a - another.a, this-&gt;b &#x3D; another.b);
  return temp;
&#125;
&#x2F;&#x2F; 友元函数 template &lt;class T&gt;
ostream &amp;operator&lt;&lt;(ostream &amp;os, Complex&lt;T&gt; &amp;c)
&#123;
  os &lt;&lt; &quot;( &quot; &lt;&lt; c.a &lt;&lt; &quot; + &quot; &lt;&lt; c.b &lt;&lt; &quot;i&quot;
     &lt;&lt; &quot;)&quot;;
  return os;
&#125;
template &lt;class T&gt;
Complex&lt;T&gt; mySub(Complex&lt;T&gt; &amp;one,Complex&lt;T&gt; &amp;another)
&#123;
  Complex&lt;T&gt; temp(one.a - another.a,one.b - another.b);
  return temp;
&#125;
int main(void)
&#123;
  Complex&lt;int&gt; a(10,20); &#x2F;&#x2F;让模板类具体化是为了告诉编译具体的大小，分配内存
  Complex&lt;int&gt; b(3，4);
  a.printComplex();
  Complex&lt;int&gt; c;
  c &#x3D; a + b;
  c.printComplex();
  cout &lt;&lt; c &lt;&lt; endl;
  c &#x3D; mySub(a, b);
  cout &lt;&lt; c &lt;&lt; endl;
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>模板类不要轻易使用友元函数</li>
</ul>
<h4 id="函数体写在类外-在-h和-cpp中"><a href="#函数体写在类外-在-h和-cpp中" class="headerlink" title="函数体写在类外(在.h和.cpp中)"></a>函数体写在类外(在.h和.cpp中)</h4><ul>
<li>complex.h</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#pragma once
#include &lt;iostream&gt;
using namespace std;
template &lt;class T&gt;
class Complex;

template &lt;class T&gt;
Complex&lt;T&gt; mySub(Complex&lt;T&gt; &amp;one, Complex&lt;T&gt; &amp;another);

template &lt;class T&gt;
ostream &amp; operator&lt;&lt;(ostream &amp;os,Complex&lt;T&gt; &amp;c)

template &lt;class T&gt;
class Complex
&#123;

  friend ostream &amp;operator&lt;&lt; &lt;T&gt;(ostream &amp;os, Complex&lt;T&gt; &amp;c);
  &#x2F;&#x2F;在模板类中如果有友元重载操作符&lt;&lt;或者&gt;&gt;需要在operator&lt;&lt;和参数列表之间
  &#x2F;&#x2F;加入&lt;T&gt;
  &#x2F;&#x2F;滥用友元函数，本来可以当成员函数, 却要用友元函数
  &#x2F;&#x2F;如果说是非&lt;&lt;&gt;&gt;在模板类中当友元函数
  &#x2F;&#x2F;在这个模板类之前声明这个函数
  friend Complex&lt;T&gt; mySub&lt;T&gt;(Complex&lt;T&gt; &amp;one, Complex&lt;T&gt; &amp;another);
  &#x2F;&#x2F;最终的结论，模板类不要轻易写友元函数，要写的就写&lt;&lt;和&gt;&gt;。
   public:
  Complex();
  Complex(T a, T b);
  Complex operator+(Complex &amp;another);
  Complex operator-(Complex &amp;another);
  void printComplex();

private:
  T a;
  T b;
&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>complex.cpp</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;Complex.h&quot;
template &lt;class T&gt;
Complex&lt;T&gt;::Complex()
&#123;
&#125;
template &lt;class T&gt;
Complex&lt;T&gt;::Complex(T a, T b)
&#123;
  this-&gt;a &#x3D; a;
  this-&gt;b &#x3D; b;
&#125;
template &lt;class T&gt;
void Complex&lt;T&gt;::printComplex()
&#123;
  cout
      &lt;&lt; &quot;( &quot;
      &lt;&lt; a
      &lt;&lt; &quot; + &quot;
      &lt;&lt; b
      &lt;&lt; &quot;i&quot;
      &lt;&lt; &quot;)&quot;
      &lt;&lt; endl;
&#125;
template &lt;class T&gt;
Complex&lt;T&gt; Complex&lt;T&gt;::operator+(Complex&lt;T&gt; &amp;another)
&#123;
  Complex temp(a + another.a, b + another.b);
  return temp;
&#125;
template &lt;class T&gt;
Complex&lt;T&gt; Complex&lt;T&gt;::operator-(Complex&lt;T&gt; &amp;another)
&#123;
  Complex temp(this-&gt;a - another.a, this-&gt;b &#x3D; another.b);
  return temp;
&#125;
&#x2F;&#x2F; 友元函数 template &lt;class T&gt;
ostream &amp;operator&lt;&lt;(ostream &amp;os, Complex&lt;T&gt; &amp;c)
&#123;
  os &lt;&lt; &quot;( &quot; &lt;&lt; c.a &lt;&lt; &quot; + &quot; &lt;&lt; c.b &lt;&lt; &quot;i&quot;
     &lt;&lt; &quot;)&quot;;
  return os;
&#125;
template &lt;class T&gt;
Complex&lt;T&gt; mySub(Complex&lt;T&gt; &amp;one, Complex&lt;T&gt; &amp;another)
&#123;
  Complex&lt;T&gt; temp(one.a - another.a, one.b - another.b);
  return temp;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>main.cpp</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&quot;Complex.h&quot;
#include&quot;Complex.cpp&quot;
using namespace std;
int main(void)
&#123;
  Complex&lt;int&gt; a(10, 20); &#x2F;&#x2F;让模板类具体化是为了告诉编译具体的大小，分配内存
  Complex&lt;int&gt; b(3，4);
  a.printComplex();
  Complex&lt;int&gt; c;
  c &#x3D; a + b;
  c.printComplex();
  cout &lt;&lt; c &lt;&lt; endl;
  c &#x3D; mySub(a, b);
  cout &lt;&lt; c &lt;&lt; endl;
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>由于二次编译，模板类在.h在第一次编译之后，并没有最终确定类的具体实现，只是编译器的词法校验和分析。在第二次确定类的具体实现后，是在.cpp文件生成的最后的具体类，所以main函数需要引入.cpp文件。</li>
<li>综上:引入cpp文件一说也是曲线救国之计，所以实现模板方法建议在同一个文件.h中完成</li>
</ul>
<h4 id="类模板中的static"><a href="#类模板中的static" class="headerlink" title="类模板中的static"></a>类模板中的static</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
template &lt;class T&gt;
class A
&#123;
public:
  static T s_value;
&#125;;
&#x2F;&#x2F;静态变量需要在类的外部初始化
template &lt;class T&gt;
T A&lt;T&gt;::s_value &#x3D; 0;
&#x2F;*
当编译器看见 A&lt;int&gt;被调用，将执行二次编译，生成如下的类A
class A
&#123;
public:
static int s_value;
&#125;;
int A: :s_value &#x3D; 0;*&#x2F;
int main(void)
&#123;
  A&lt;int&gt; a1, a2, a3;  &#x2F;&#x2F; class A&lt;int&gt;家族的对象
  A&lt;char&gt; b1, b2, b3; &#x2F;&#x2F; class A &lt;char&gt;家族的对象
  a1.s_value &#x3D; 10;
  b1.s_value &#x3D; &#39;a &#39;;
  cout &lt;&lt; a1.s_value &lt;&lt; endl;
  cout &lt;&lt; b1.s_value &lt;&lt; endl;
  &#x2F;&#x2F;打印出a1.s_value &#x3D; 10，b1.s_value &#x3D; &#39;a’说明两个s_value在两个类中是不同的
  a1.s_value++;
  cout &lt;&lt; a2.s_value &lt;&lt; endl; &#x2F;&#x2F; 11
  cout &lt;&lt; a3.s_value &lt;&lt; endl; &#x2F;&#x2F; 11
  b1.s_value++;
  cout &lt;&lt; b2.s_value &lt;&lt; endl; &#x2F;&#x2F;&#39; b&#39;
  cout &lt;&lt; b3.s_value &lt;&lt; endl; &#x2F;&#x2F;&#39; b&#39;
  &#x2F;&#x2F;通过以上结果，说明a1，a2，a3是属于A&lt;int&gt;家族的他们共享Aint&gt; ::s_value;
  &#x2F;&#x2F; b1,b2，b3 是属于A&lt;char&gt;家族的他们共享A&lt;char&gt; ::s_value;
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>练习 实现一个模板数组类</li>
</ul>
<blockquote>
<p>请设计一个数组模板类(MyVector) ，完成对int、char、Teacher类型元素的管理。<br>需要实现构造函数拷贝构造函数 &lt;&lt; [ ] 重载=操作符。</p>
</blockquote>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="类型转换的名称和语法"><a href="#类型转换的名称和语法" class="headerlink" title="类型转换的名称和语法"></a>类型转换的名称和语法</h3><ul>
<li>类型转换有c风格的,当然还有c++风格的。c风格的转换的格式很简单(TYPE)EXPRESSION,但是c风格的类型转换有不少的缺点,有的时候用c风格的转换是不合适的,因为它可以在任意类型之间转换,比如你可以把一个指向const对象的指针转换成指向非const对象的指针,把一个指向基类对象的指针转换成指向一个派生类对象的指针,这两种转换之间的差别是巨大的,但是传统的c语言风格的类型转换没有区分这些。还有一个缺点就是,c风格的转换不容易查找,他由一个括号加上一个标识符组成,而这样的东西在c++程序里一大堆。所以c++为了克服这些缺点,引进了4新的类型转换操作符。</li>
<li>C风格的强制类型转换（Type Cast）</li>
<li><code>TYPE b = (TYPE)a</code></li>
<li>C++提供了四种类型转换，分别处理不同的场合应用</li>
</ul>
<blockquote>
<p>static_cast    静态类型转换。<br>reinterpreter_cast    重新解释类型转换。<br>dynamic_cast    子类和父类之间的多态类型转换。<br>const_cast    去掉const属性转换。</p>
</blockquote>
<h3 id="转换方式"><a href="#转换方式" class="headerlink" title="转换方式"></a>转换方式</h3><h4 id="static-cast-静态类型转换"><a href="#static-cast-静态类型转换" class="headerlink" title="static_cast 静态类型转换"></a>static_cast 静态类型转换</h4><p><code>static_cast&lt;目标类型&gt;(标识符)</code></p>
<ul>
<li>所谓的静态,即在编译期内即可决定其类型的转换,用的也是最多的一种。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
int main(void)
&#123;
  double dPi &#x3D; 3.1415926;
  int num1 &#x3D; (int)dPi;
  &#x2F;&#x2F; c语言的旧式类型转换
  int num2 &#x3D; dPi;
  &#x2F;&#x2F;隐式类型转换
  &#x2F;&#x2F;静态的类型转换:
  &#x2F;&#x2F;在编译的时进行基本类型的转换能替代c风格的类型转换可以进行一部分检查
  int num3 &#x3D; static_cast&lt;int&gt;(dPi); &#x2F;&#x2F; c++的新式的类型转换运算符
  cout &lt;&lt; &quot;num1:&quot; &lt;&lt; num1 &lt;&lt; &quot; num2:&quot; &lt;&lt; num2 &lt;&lt; &quot; num3:&quot; &lt;&lt; num3 &lt;&lt; endl;
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="dynamic-cast-子类和父类之间的多态"><a href="#dynamic-cast-子类和父类之间的多态" class="headerlink" title="dynamic_cast 子类和父类之间的多态"></a>dynamic_cast 子类和父类之间的多态</h4><p><code>dynamic_cast&lt;目标类型&gt;(标识符)</code></p>
<ul>
<li>用于多态中父子类之间的强制转化</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class Animal
&#123;
public:
  virtual void cry() &#x3D; 0;
&#125;;
class Dog : public Animal
&#123;
public:
  virtual void cry()
  &#123;
    cout &lt;&lt; &quot;旺旺~ &quot; &lt;&lt; endl;
  &#125;
  void doHome()
  &#123;
    cout &lt;&lt; &quot;看家&quot; &lt;&lt; endl;
  &#125;
&#125; class cat : public Animal
&#123;
public:
  virtual voidcry()
  &#123;
    cout &lt;&lt;“&quot;瞄瞄~ &quot; &lt;&lt; endl;
  &#125;
  void doHome()
  &#123;
    cout &lt;&lt; &quot;抓老鼠&quot; &lt;&lt; endl;
  &#125;
  int main(void)
  &#123;
    Animal *base &#x3D; NULL;
    base &#x3D; new Cat();
    base-&gt;cry();                           &#x2F;&#x2F;此时父类指针指向猫&#x2F;&#x2F;用于将父类指针转换成子类，
    Dog *pDog &#x3D; dynamic_cast&lt;Dog *&gt;(base); &#x2F;&#x2F;转换之后讲父类指针转换成子类狗指针
    &#x2F;&#x2F;但是由于父类指针此时指向的对象是猫，&#x2F;&#x2F;所以转换狗是失败的
    if (pDog !&#x3D; NULL)
    &#x2F;&#x2F;如果转换失败则返回 NULL
    &#123;
      pDog-&gt;cry();
      pDog-&gt;doHome();
    &#125;
    cat *pCat &#x3D; dynamic_cast&lt;Cat *&gt;(base); &#x2F;&#x2F;转换之后讲父类指针转换成子类猫指针
    &#x2F;&#x2F;向下转换
    if (pcat !&#x3D; NULL)
    &#123;
      pcat-&gt;cry();
      pcat-&gt;doHome();
      return 0;
    &#125;
  &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="const-cast-去掉const属性转换"><a href="#const-cast-去掉const属性转换" class="headerlink" title="const_cast 去掉const属性转换"></a>const_cast 去掉const属性转换</h4><p><code>const_cast&lt;目标类型&gt; (标识符)  //目标类型只能是指针或者是引用</code></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
struct A
&#123;
  int data;
&#125;;
int main()
&#123;
  const A a &#x3D; &#123;200&#125;;
  &#x2F;&#x2F; A a1 &#x3D; const_cast&lt;A&gt;(a);
  &#x2F;&#x2F; a1.data &#x3D; 300;
  A &amp;a2 &#x3D; const_cast&lt;A &amp;&gt;(a);
  a2.data &#x3D; 300;
  cout &lt;&lt; a.data &lt;&lt; &quot; &quot; &lt;&lt; a2.data &lt;&lt; endl; &#x2F;&#x2F; 300 300
  cout &lt;&lt; &amp;a &lt;&lt; &quot; &quot; &lt;&lt; &amp;a2 &lt;&lt; endl;
  A *a3 &#x3D; const_cast&lt;A *&gt;(&amp;a);
  a3-&gt;data &#x3D; 400;
  cout &lt;&lt; a.data &lt;&lt; &quot; &quot; &lt;&lt; a3-&gt;data &lt;&lt; endl; &#x2F;&#x2F; 400 400
  cout &lt;&lt; &amp;a &lt;&lt; &quot; &quot; &lt;&lt; a3 &lt;&lt; endl;
  const int x &#x3D; 3;
   
  x1 &#x3D; 300;
  cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; x1 &lt;&lt; endl; &#x2F;&#x2F; 3 300
  cout&lt;&lt;&amp;x&lt;&lt;&quot; &quot;&lt;&lt;&amp;x1&lt;&lt;endl;
  int *x2 &#x3D; const_cast&lt;int *&gt;(&amp;x);
  *x2 &#x3D; 400;
  cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; *x2 &lt;&lt; endl; &#x2F;&#x2F; 3 400
  cout&lt;&lt;&amp;x&lt;&lt;&quot; &quot;&lt;&lt;x2&lt;&lt;endl;
  return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src="http://qiniu.orangew.cn/img/20220706120736.png" alt="20220706120736"></p>
<h4 id="reinterpret-cast-重新解释类型转换"><a href="#reinterpret-cast-重新解释类型转换" class="headerlink" title="reinterpret_cast 重新解释类型转换"></a>reinterpret_cast 重新解释类型转换</h4><p><code>reinterpret_cast&lt;目标类型&gt;(标识符)</code></p>
<ul>
<li>interpret是解释的意思,reinterpret即为重新解释,此标识符的意思即为数据的二进制形式重新解释,但是不改变其值。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class Animal
&#123;
public:
  virtual void cry() &#x3D; 0;
&#125;;
class Dog : public Animal
&#123;
public:
  virtual void cry()
  &#123;
    cout
        &lt;&lt; &quot;旺旺~ &quot; &lt;&lt; endl;
  &#125;
  void doHome()
  &#123;
    cout &lt;&lt; &quot;看家&quot; &lt;&lt; endl;
  &#125;
&#125;;
class Cat : public Animal
&#123;
public:
  virtual void cry()
  &#123;
    cout &lt;&lt; &quot;哺瞄~&quot; &lt;&lt; endl;
  &#125;
  void doHome()
  &#123;
    cout &lt;&lt; &quot;抓老鼠&quot; &lt;&lt; endl;
  &#125;
&#125;;
class Book
&#123;
public:
  void printP()
  &#123;
    cout &lt;&lt; &quot;book&quot; &lt;&lt; endl;
  &#125;
&#125;;
int main(void)
&#123;
  Animal *base &#x3D; NULL;
  &#x2F;&#x2F; 1可以把子类指针赋给父类指针但是反过来是不可以的需要如下转换
  &#x2F;&#x2F;Dog *pdog &#x3D; base;
  Dog *pDog &#x3D; static_cast&lt;Dog *&gt;(base);
  &#x2F;&#x2F; 2把base转换成其他非动物相关的err
  &#x2F;&#x2F; Book *book&#x3D; static_cast&lt;Book *&gt; (base);
  &#x2F;&#x2F; 3 reinterpret_cast可以强制类型转换
  Book *book &#x3D; reinterpret_cast&lt;Book *&gt;(base);
  return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>建议1:<br>程序员要清除的知道:要转的变量，类型转换前是什么类型，类型转换后是什么类型。转换后有什么后果。<br>建议2:<br>一般情况下，不建议进行类型转换。</p>
</blockquote>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ol>
<li>异常是一种程序控制机制，与函数机制独立和互补<ul>
<li>函数是一种以栈结构展开的上下函数衔接的程序控制系统,异常是另一种控制结构,它依附于栈结构,却可以同时设置多个异常类型作为网捕条件,从而以类型匹配在栈机制中跳跃回馈.</li>
</ul>
</li>
<li>异常设计目的:<ul>
<li>栈机制是一种高度节律性控制机制,面向对象编程却要求对象之间有方向、有目的的控制传动,从一开始，异常就是冲着改变程序控制结构，以适应面向对象程序更有效地工作这个主题，而不是仅为了进行错误处理。</li>
</ul>
</li>
<li>异常设计出来之后，却发现在错误处理方面获得了最大的好处。</li>
</ol>
<h3 id="异常处理的基本思想"><a href="#异常处理的基本思想" class="headerlink" title="异常处理的基本思想"></a>异常处理的基本思想</h3><h4 id="传统的错误处理机制"><a href="#传统的错误处理机制" class="headerlink" title="传统的错误处理机制"></a>传统的错误处理机制</h4><ul>
<li>通过函数返回值来处理错误</li>
</ul>
<h4 id="异常的错误处理机制"><a href="#异常的错误处理机制" class="headerlink" title="异常的错误处理机制"></a>异常的错误处理机制</h4><p><img src="http://qiniu.orangew.cn/img/20220706150023.png" alt="20220706150023"></p>
<ol>
<li>C++的异常处理机制使得异常的引发和异常的处理不必在同一个函数中，这样底层的函数可以着重解决具体问题，而不必过多的考虑异常的处理。上层调用者可以再适当的位置设计对不同类型异常的处理。</li>
<li>异常是专门针对抽象编程中的一系列错误处理的，C++中不能借助函数机制，因为栈结构的本质是先进后出，依次访问，无法进行跳跃，但错误处理的特征却是遇到错误信息就想要转到若干级之上进行重新尝试，如图</li>
</ol>
<p><img src="http://qiniu.orangew.cn/img/20220706150249.png" alt="20220706150249"></p>
<ol start="3">
<li>异常超脱于函数机制，决定了其对函数的跨越式回跳。</li>
<li>异常跨越函数</li>
</ol>
<h3 id="C-异常处理的实现"><a href="#C-异常处理的实现" class="headerlink" title="C++异常处理的实现"></a>C++异常处理的实现</h3><h4 id="异常的基本语法"><a href="#异常的基本语法" class="headerlink" title="异常的基本语法"></a>异常的基本语法</h4><p><img src="http://qiniu.orangew.cn/img/20220706150604.png" alt="20220706150604"></p>
<ol>
<li>若有异常则通过throw操作创建一个异常对象并抛掷。</li>
<li>将可能抛出异常的程序段嵌在try块之中。控制通过正常的顺序执行到达try语句，然后执行try块内的保护段。</li>
<li>如果在保护段执行期间没有引起异常，那么跟在try块后的catch子句就不执行。程序从try块后跟随的最后一个catch子句后面的语句继续执行下去。</li>
<li>catch子句按其在try块后出现的顺序被检查。匹配的catch子句将捕获并处理异常（或继续抛掷异常)。</li>
<li>如果匹配的处理器未找到，则运行函数terminate将被自动调用，其缺省功能是调用abort终止程序。</li>
<li>处理不了的异常，可以在catch的最后一个分支，使用throw语法，向上扔。</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
int divide( int x, int y )&#123;
if (y &#x3D;&#x3D;0)&#123;
throw x;
&#125;
return x&#x2F;y;
&#125;
int main(void)&#123;
try&#123;
cout &lt;&lt; &quot;8&#x2F;2 &#x3D; &quot; &lt;&lt; divide(8,2) &lt;&lt; endl;
cout &lt;&lt; &quot;10&#x2F;0 &#x3D;&quot; &lt;&lt; divide(10,0) &lt;&lt; endl;
&#125;
catch (int e)&#123;
cout &lt;&lt; &quot;e&quot; &lt;&lt; &quot; is divided by zero! &quot; &lt;&lt; endl;
&#125;
catch( ...)&#123;
cout &lt;&lt;&quot;未知异常&quot;&lt;&lt; endl;
&#125;
return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="栈解旋（unwinding）"><a href="#栈解旋（unwinding）" class="headerlink" title="栈解旋（unwinding）"></a>栈解旋（unwinding）</h4><ul>
<li>异常被抛出后，从进入try块起，到异常被抛掷前，这期间在栈上的构造的所有对象，都会被自动析构。析构的顺序与构造的顺序相反。这一过程称为栈的解旋(unwinding)。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
class MyException
&#123;
&#125;;
class Test
&#123;
public:
  Test(int a &#x3D; 0, int b &#x3D; 0)
  &#123;
    this-&gt;a &#x3D; a;
    this-&gt;b &#x3D; b;
    cout &lt;&lt; &quot;Test构造函数执行&quot;
         &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b: &quot; &lt;&lt; b &lt;&lt; endl;
  &#125;
  void printT()
  &#123;
    cout
        &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt; &quot; b: &quot; &lt;&lt; b &lt;&lt; endl;
  &#125;
  ~Test()
  &#123;
    cout &lt;&lt; &quot;Test析构函数执行&quot;
         &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b: &quot; &lt;&lt; b &lt;&lt; endl;
  &#125;

private:
  int a;
  int b;
&#125;;
void myFunc() throw(MyException)
&#123;
  Test t1;
  Test t2;
  cout &lt;&lt; &quot;定义了两个栈变量,异常抛出后测试栈变量的如何被析构&quot; &lt;&lt; endl;
  throw MyException();
&#125;
int main(void)
&#123;
  &#x2F;&#x2F; 异常被抛出后，从进入try块起，到异常被抛掷前，这期间在栈上的构造的所有对象 &gt;，
  &#x2F;&#x2F;都会被自动析构。析构的顺序与构造的顺序相反。
  &#x2F;&#x2F;这一过程称为栈的解旋(unwinding)
  try
  &#123;
    myFunc();
  &#125;
  catch (MyException &amp;e)
  &#x2F;&#x2F; catch (MyException) &#x2F;&#x2F;这里不能访问异常对象
  &#123;
    cout
        &lt;&lt; &quot;接收到MyException类型异常&quot; &lt;&lt; endl;
  &#125;
  catch (...)
  &#123;
    cout
        &lt;&lt; &quot;未知类型异常&quot; &lt;&lt; endl;
  &#125;
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="异常接口声明"><a href="#异常接口声明" class="headerlink" title="异常接口声明"></a>异常接口声明</h4><ol>
<li>为了加强程序的可读性，可以在函数声明中列出可能抛出的所有异常类型，例如︰<br>void func() throw(A, B,C，D);//这个函数func ()）能够且只能抛出类型ABCD及其子类型的异常。</li>
<li>如果在函数声明中没有包含异常接口声明，则次函数可以抛掷任何类型的异常，例如︰<br>void func();</li>
<li>一个不抛掷任何类型异常的函数可以声明为∶<br>void func() throw();</li>
<li>如果一个函数抛出了它的异常接口声明所不允许抛出的异常，unexpected函数会被调用，该函数默认行为调用terminate函数中止程序。</li>
</ol>
<h4 id="异常类型和异常变量的生命周期"><a href="#异常类型和异常变量的生命周期" class="headerlink" title="异常类型和异常变量的生命周期"></a>异常类型和异常变量的生命周期</h4><ol>
<li>throw的异常是有类型的，可以使，数字、字符串、类对象。</li>
<li>throw的异常是有类型的，catch严格按照类型进行匹配。</li>
<li>注意异常对象的内存模型。</li>
</ol>
<ul>
<li>传统的错误模型处理</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
&#x2F;&#x2F;传统的错误处理机制
int my_strcpy(char *to,char *from)
&#123;
  if (from &#x3D;&#x3D; NULL)
  &#123;
    return 1;
  &#125;
  if (to &#x3D;&#x3D; NULL)
  &#123;
    return 2;
  &#125;
  &#x2F;&#x2F; copy是的场景检查if(*from &#x3D;&#x3D; &#39;a &#39;)
  &#123;
    return 3;
    &#x2F;&#x2F; copy时出错
  &#125;
  while (*from !&#x3D; &#39;\0&#39;)
  &#123;
    *to &#x3D; *from;
    to++;
    from++;
  &#125;
  *to &#x3D; &#39;\0&#39;;
  return 0;
&#125;
int main(void)
&#123;
  int ret &#x3D; 0;
  char buf1[] &#x3D; &quot;zbcdefg&quot;;
  char buf2[1024] &#x3D; &#123;0&#125;;
  ret &#x3D; my_strcpy(buf2, buf1);
  if (ret !&#x3D; 0)
  &#123;
    switch (ret)
    &#123;
    case 1:
      printf(&quot;源buf出错! \n&quot;);
      break;
    case 2:
      printf(&quot;目的buf出错! \n&quot;);
      break;
    case 3:
      printf(&quot;copy过程出错! \n&quot;);
      break;
    default:
      printf(&quot;未知错误! \n&quot;);
      break;
    &#125;
  &#125;
  printf(&quot;buf2:%s \n&quot;, buf2);
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>抛出普通类型异常</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; throw int类型异常
void my_strcpy1(char *to, char *from)
&#123;
  if (from &#x3D;&#x3D; NULL)
  &#123;
    throw 1;
  &#125;
  if (to &#x3D;&#x3D; NULL)
  &#123;
    throw 2;
  &#125;
  &#x2F;&#x2F; copy是的场景检查
  if (*from &#x3D;&#x3D; &#39;a&#39;)
  &#123;
    throw 3;
    &#x2F;&#x2F; copy时出错
  &#125;
  while (*from !&#x3D; &#39;\0&#39;)
  &#123;
    *to &#x3D; *from;
    to++;
    from++;
  &#125;
  *to &#x3D; &#39;\0&#39;;
&#125;
&#x2F;&#x2F; throw char * 类型异常
void my_strcpy2(char *to, char *from)
&#123;
  if (from &#x3D;&#x3D; NULL)
  &#123;
    throw &quot;源buf出错 &quot;;
  &#125;
  if (to &#x3D;&#x3D; NULL)
  &#123;
    throw &quot;目的buf出错&quot;;
  &#125;
  &#x2F;&#x2F; copy是的场景检查
  if (*from &#x3D;&#x3D; &#39;a &#39;)
  &#123;
    throw &quot;copy过程出错&quot;;
    &#x2F;&#x2F; copy时出错
  &#125;
  while (*from !&#x3D; &#39;\0&#39;)
  &#123;
    *to &#x3D; *from;
    to++;
    from++;
  &#125;
  *to &#x3D; &#39;\0&#39;;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>抛出自定义类型异常</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class BadSrcType
&#123;
&#125;;
class BadDestType
&#123;
&#125;;
class BadProcessType
&#123;
public:
  BadProcessType()
  &#123;
    cout &lt;&lt; &quot;BadProcessType构造函数do \n&quot;;
  &#125;
  BadProcessType(const BadProcessType &amp;obj)
  &#123;
    cout &lt;&lt; &quot;BadProcessType copy构造函数do \n&quot;;
  &#125;
  ~BadProcessType()
  &#123;
    cout &lt;&lt; &quot;BadProcessType析构函数do \n&quot;;
  &#125;
&#125;;
&#x2F;&#x2F; throw类对象类型异常
void my_strcpy3(char *to, char *from)
&#123;
  if (from &#x3D;&#x3D; NULL)
  &#123;
    throw BadSrcType();
  &#125;
  if (to &#x3D;&#x3D; NULL)
  &#123;
    throw BadDestType();
  &#125;
  &#x2F;&#x2F; copy是的场景检查
  if (*from &#x3D;&#x3D; &#39;a&#39;)
  &#123;
    printf(&quot;开始BadProcessType类型异常\n&quot;);
    throw BadProcessType();
  &#125;
  if (*from &#x3D;&#x3D; &#39;b&#39;)
  &#123;
    throw &amp;(BadProcessType());
  &#125;
  if (*from &#x3D;&#x3D; &#39;c&#39;)
  &#123;
    throw new BadProcessType;
  &#125;
  while (*from !&#x3D; &#39;\0 &#39;)
  &#123;
    *to &#x3D; *from;
    to++;
    from++;
  &#125;
  *to &#x3D; &#39;\0&#39;;
&#125;
int main(void)
&#123;
  int ret &#x3D; 0;
  char buf1[] &#x3D; &quot;cbbcdefg&quot;;
  char buf2[1024] &#x3D; &#123;&#125;;
  try
  &#123;
    &#x2F;&#x2F; my_strcpy1(buf2， buf1);l&#x2F;my_strcpy2( buf2， buf1);
    my_strcpy3(buf2, buf1);
  &#125;
  catch (int e) &#x2F;&#x2F; e可以写也可以不写
  &#123;
    cout &lt;&lt; e &lt;&lt; &quot; int类型异常&quot; &lt;&lt; endl;
  &#125;
  catch (char *e)
  &#123;
    cout &lt;&lt; e &lt;&lt; &quot; char*类型异常&quot; &lt;&lt; endl;
  &#125;
  &#x2F;&#x2F; ---
  catch (BadSrcType e)
  &#123;
    cout &lt;&lt; &quot; BadSrcType类型异常&quot; &lt;&lt; endl;
  &#125;
  catch (BadDestType e)
  &#123;
    cout &lt;&lt; &quot; BadDestType类型异常&quot; &lt;&lt; endl;
  &#125;
  &#x2F;&#x2F;结论1:如果接受异常的时候使用一个异常变量,则copy构造异常变量.
  &#x2F;*
  catch( BadProcessType e)&#123;
  cout &lt;&lt; &quot; BadProcessType类型异常&quot;&lt;&lt;endl;&#125;
  *&#x2F;
  &#x2F;&#x2F;结论2:使用引用的话会使用throw时候的那个对象
  &#x2F;&#x2F; catch( BadProcessType &amp;e)
  &#x2F;&#x2F;&#123;
  &#x2F;&#x2F; cout &lt;&lt;&quot; BadProcessType类型异常&quot;&lt;&lt;endl;&#x2F; &#x2F; &#125;
  &#x2F;&#x2F;结论3:指针可以和引用&#x2F;元素写在一块但是引用&#x2F;元素不能写在一块
  catch (BadProcessType *e)
  &#123;
    cout &lt;&lt; &quot; BadProcessType类型异常&quot; &lt;&lt; endl;
    delete e;
  &#125;
  &#x2F;&#x2F;结论4:类对象时，使用引用比较合适 &#x2F; &#x2F; 一 catch (...)
  &#123;
    cout &lt;&lt; &quot;未知类型异常&quot; &lt;&lt; endl;
  &#125;
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="异常的层次结构"><a href="#异常的层次结构" class="headerlink" title="异常的层次结构"></a>异常的层次结构</h4><ul>
<li>设计一个数组类MyArray，重载[]操作，数组初始化时，对数组的个数进行有效检查<ol>
<li>index&lt;O抛出异常eNegative</li>
<li>index =0抛出异常eZero</li>
<li>index&gt;1000抛出异常eTooBig</li>
<li>index&lt;10抛出异常eTooSmall</li>
<li>eSize类是以上类的父类，实现有参数构造、并定义virtual voidprintErr()输出错误。</li>
</ol>
</li>
</ul>
<h3 id="标准程序库异常"><a href="#标准程序库异常" class="headerlink" title="标准程序库异常"></a>标准程序库异常</h3><p><img src="http://qiniu.orangew.cn/img/20220706200150.png" alt="20220706200150"></p>
<ul>
<li><p>每个类所在的头文件在图下方标识出来.</p>
</li>
<li><p>标准异常类的成员∶</p>
<ol>
<li>在上述继承体系中，每个类都有提供了构造函数、复制构造函数、和赋值操作符重载。</li>
<li>logic_error类及其子类、runtime_error类及其子类，它们的构造函数是接受一个string类型的形式参数，用于异常信息的描述﹔</li>
<li>所有的异常类都有一个what()方法，返回const char*类型（C风格字符串）的值，描述异常信息。</li>
</ol>
</li>
<li><p><img src="http://qiniu.orangew.cn/img/20220706200318.png" alt="20220706200318"></p>
</li>
<li><p>案例1</p>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
#include &lt;stdexcept&gt;
class Teacher
&#123;
public:
  Teacher(int age) &#x2F;&#x2F;构造函数，通过异常机制处理错误
  &#123;
    if (age &gt; 100)
    &#123;
      throw out_of_range(&quot;年龄太大&quot;);
    &#125;
    this-&gt;age &#x3D; age;
  &#125;

protected:
private:
  int age;
&#125;;
int main()
&#123;
  try
  &#123;
    Teacher t1(102);
  &#125;
  catch (out_of_range e)
  &#123;
    cout &lt;&lt; e.what() &lt;&lt; endl;
  &#125;
  return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>案例2</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
using namespace std;
class Dog
&#123;
public:
  Dog()
  &#123;
    parr &#x3D; new int[1024 * 1024 * 100]; &#x2F;&#x2F; 4MB
  &#125;

private:
  int *parr;
&#125;;
int main()
&#123;
  Dog *pDog;
  try
  &#123;
    for (int i &#x3D; 1; i &lt; 1024; i++) &#x2F;&#x2F; 40GB!
    &#123;
      pDog &#x3D; new Dog();
      cout &lt;&lt; i &lt;&lt; &quot;: new Dog成功.&quot; &lt;&lt; endl;
    &#125;
  &#125;
  catch (bad_alloc err)
  &#123;
    cout &lt;&lt; &quot;new Dog失败:&quot; &lt;&lt; err.what() &lt;&lt; endl;
  &#125;
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="输入输出流"><a href="#输入输出流" class="headerlink" title="输入输出流"></a>输入输出流</h2><h3 id="I-O流的概念和流类库的结构"><a href="#I-O流的概念和流类库的结构" class="headerlink" title="I/O流的概念和流类库的结构"></a>I/O流的概念和流类库的结构</h3><ul>
<li>程序的输入指的是从输入文件将数据传送给程序，程序的输出指的是从程序将数据传送给输出文件。</li>
<li>C++输入输出包含以下三个方面的内容∶<ul>
<li>对系统指定的标准设备的输入和输出。即从键盘输入数据，输出到显示器屏幕。这种输入输出称为标准的输入输出，简称标准I/O。</li>
<li>以外存磁盘文件为对象进行输入和输出，即从磁盘文件输入数据，数据输出到磁盘文件。以外存文件为对象的输入输出称为文件的输入输出，简称文件l/0。</li>
<li>对内存中指定的空间进行输入和输出。通常指定一个字符数组作为存储空间(实际上可以利用该空间存储任何信息)。这种输入和输出称为字符串输入输出，简称串I/O。</li>
</ul>
</li>
<li>C++的I/o对c的发展–类型安全和可扩展性</li>
<li>在c语言中，用printf和scanf进行输入输出，往往不能保证所输入输出的数据是可靠的安全的。在C++的输入输出中，编译系统对数据类型进行严格的检查，凡是类型不正确的数据都不可能通过编译。因此C++的I/o操作是类型安全(type safe)的。C++的I/o操作是可扩展的，不仅可以用来输入输出标准类型的数据，也可以用于用户自定义类型的数据。</li>
<li>C++通过I/o类库来实现丰富的I/o功能。这样使C++的输人输出明显地优于c语言中的printf和scanf，但是也为之付出了代价，C++的I/o系统变得比较复杂，要掌握许多细节。</li>
<li>C++编译系统提供了用于输入输出的iostream类库。iostream这个单词是由3个部分组成的，即i-o-stream，意为输入输出流。在iostream类库中包含许多用于输入输出的类。常用的见表</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/20220706200943.png" alt="20220706200943"></p>
<ul>
<li><p>ios是抽象基类，由它派生出istream类和ostream类，两个类名中第1个字母i和o分别代表输入(input)和输出(output)。istream类支持输入操作，ostream类支持输出操作，iostream类支持输入输出操作。iostream类是从istream类和ostream类通过多重继承而派生的类。其继承层次见上图表示。</p>
</li>
<li><p>C++对文件的输入输出需要用ifstream和ofstream类，两个类名中第1个字母i和o分别代表输入和输出，第2个字母f代表文件(file)。ifstream支持对文件的输入操作，ofstream支持对文件的输出操作。类ifstream继承了类istream，类ofstream继承了类ostream，类fstream继承了类iostream。见图</p>
</li>
<li><p><img src="http://qiniu.orangew.cn/img/20220706201058.png" alt="20220706201058"></p>
</li>
<li><p>I/o类库中还有其他一些类，但是对于一般用户来说，以上这些已能满足需要了。<br>与iostream类库有关的头文件</p>
</li>
<li><p>iostream类库中不同的类的声明被放在不同的头文件中，用户在自己的程序中用#include命令包含了有关的头文件就相当于在本程序中声明了所需要用到的类。可以换—种说法∶头文件是程序与类库的接口，iostream类库的接口分别由不同的头文件来实现。常用的有</p>
</li>
<li><p>iostream包含了对输入输出流进行操作所需的基本信息。</p>
</li>
<li><p>fstream用于用户管理的文件的I/O操作。</p>
</li>
<li><p>strstream用于字符串流I/O。</p>
</li>
<li><p>stdiostream用于混合使用C和C＋+的I/O机制时，例如想将C程序转变为C++程序。</p>
</li>
<li><p>.iomanip在使用格式化I/O时应包含此头文件。</p>
</li>
<li><p>在iostream头文件中定义的流对象</p>
</li>
<li><p>在iostream头文件中定义的类有ios，istream，ostream，iostream,istream _withassign，ostream_withassign，iostream_withassign等。</p>
</li>
<li><p>在iostream头文件中重载运算符<br>“&lt;&lt;”和”&gt;&gt;”本来在C++中是被定义为左位移运算符和右位移运算符的，由于在iostream头文件中对它们进行了重载，使它们能用作标准类型数据的输入和输出运算符。所以，在用它们的程序中必须用#include命令把iostream包含到程序中。<br>#include <iostream></p>
<ul>
<li><code>&gt;&gt;a</code>表示将数据放入a对象中。</li>
<li><code>&gt;&gt;a</code>表示将a对象中存储的数据拿出。</li>
</ul>
</li>
</ul>
<h3 id="标准I-O流"><a href="#标准I-O流" class="headerlink" title="标准I/O流"></a>标准I/O流</h3><ul>
<li>标准I/O对象:cin , cout , cerr , clog</li>
<li>cout流对象</li>
<li>cout是console output的缩写，意为在控制台（终端显示器）的输出。强调几点。<ol>
<li>cout不是C++预定义的关键字，它是ostream流类的对象，在iostream中定义。顾名思义，流是流动的数据，cout流是流向显示器的数据。cout流中的数据是用流插入运算符“&lt;&lt;”顺序加入的。如果有<br>cout&lt;&lt;”I “&lt;&lt;”study C++ “&lt;&lt;”very hard.&lt;&lt; “wang bao ming “;按顺序将字符串”I “, “study C++ “, “very hard.”插人到cout流中，cout就将它们送到显示器，在显示器上输出字符串”I study C++ very hard.”。cout流是容纳数据的载体，它并不是一个运算符。人们关心的是cout流中的内容，也就是向显示器输出什么。</li>
<li>用“cout&lt;&lt;”输出基本类型的数据时，可以不必考虑数据是什么类型，系统会判断数据的类型，并根据其类型选择调用与之匹配的运算符重载函数。这个过程都是自动的，用户不必干预。如果在C语言中用prinf函数输出不同类型的数据，必须分别指定相应的输出格式符，十分麻烦，而且容易出错。C+＋的I/O机制对用户来说，显然是方便而安全的。</li>
<li>cout流在内存中对应开辟了一个缓冲区，用来存放流中的数据，当向cout流插人一个endl时，不论缓冲区是否已满，都立即输出流中所有数据，然后插入一个换行符，并刷新流（清空缓冲区)。注意如果插人一个换行符”\n“(如cout&lt;&lt;a&lt;&lt;”\n” )，则只输出和换行，而不刷新cout流(但并不是所有编译系统都体现出这一区别)。</li>
<li>在iostream中只对”&lt;&lt;”和”&gt;&gt;”运算符用于标准类型数据的输入输出进行了重载，但未对用户声明的类型数据的输入输出进行重载。如果用户声明了新的类型，并希望用”&lt;&lt;”和”&gt;&gt;”运算符对其进行输入输出，按照重运算符重载来<br>做。</li>
</ol>
</li>
<li>cerr流对象<ul>
<li>cerr流对象是标准错误流，cerr流已被指定为与显示器关联。cerr的作用是向标准错误设备(standard error device)输出有关出错信息。cerr与标准输出流cout的作用和用法差不多。但有一点不同:cout流通常是传送到显示器输出，但也可以被重定向输出到磁盘文件，而cerr流中的信息只能在显示器输出。当调试程序时，往往不希望程序运行时的出错信息被送到其他文件，而要求在显示器上及时输出，这时应该用cerr。cerr流中的信息是用户根据需要指定的</li>
</ul>
</li>
<li>clog流对象<ul>
<li>clog流对象也是标准错误流，它是console log的缩写。它的作用和cerr相同，都是在终端显示器上显示出错信息。区别: cerr是不经过缓冲区，直接向显示器上输出有关信息，而clog中的信息存放在缓冲区中，缓冲区满后或遇endl时向显示器输出。</li>
</ul>
</li>
</ul>
<h4 id="标准的输入流"><a href="#标准的输入流" class="headerlink" title="标准的输入流"></a>标准的输入流</h4><ul>
<li>cin.get()//一次只能读取一个字符</li>
<li>cin.get(一个参数)//读一个字符</li>
<li>cin.get(三个参数)//可以读字符串</li>
<li>cin.getline()</li>
<li>cin.ignore()</li>
<li>cin.putback()</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
&#x2F;&#x2F; 2输入字符串 你 好 遇见空格,停止接受输入
int main()
&#123;
  char YourName[50];
  int myInt;
  long myLong;
  double myDouble;
  float myFloat;
  unsigned int myUnsigned;
  cout &lt;&lt; &quot;请输入一个Int: &quot;;
  cin &gt;&gt; myInt;
  cout &lt;&lt; &quot;请输入一个Long: &quot;;
  cin &gt;&gt; myLong;
  cout &lt;&lt; &quot;请输入一个Double: &quot;;
  cin &gt;&gt; myDouble;
  cout &lt;&lt; &quot;请输入你的姓名:&quot;;
  cin &gt;&gt; YourName;
  cout &lt;&lt; &quot;\n \n你输入的数是︰&quot; &lt;&lt; endl;
  cout &lt;&lt; &quot; Int : \t &quot; &lt;&lt; myInt &lt;&lt; endl;
  cout &lt;&lt; &quot; Long : \t &quot; &lt;&lt; myLong &lt;&lt; endl;
  cout &lt;&lt; &quot; Double : lt &quot; &lt;&lt; myDouble &lt;&lt; endl;
  cout &lt;&lt; &quot;姓名 :\t &quot; &lt;&lt; YourName &lt;&lt; endl;
  cout
      &lt;&lt; endl
      &lt;&lt; endl;
  return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
using namespace std;
&#x2F;&#x2F;输入英文 ok
&#x2F;&#x2F;ctrl z 会产生一个 EOF(-1)
int main()&#123;
    char;
    while((ch&#x3D;cin.get())!&#x3D;EOF)&#123;
        cout&lt;&lt;&quot;字符：&quot;&lt;&lt;ch&lt;&lt;endl;
        cout&lt;&lt;&quot;\n结束.\n&quot;;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
&#x2F;&#x2F;演示:读一个字符链式编程
int main(void)
&#123;
  char a, b, c;
  cin.get(a);
  cin.get(b);
  cin.get(c);
  cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; endl;
  cout &lt;&lt; &quot;开始链式编程&quot; &lt;&lt; endl;
  cin.get(a).get(b).get(c);
  cout &lt;&lt; a &lt;&lt; b &lt;&lt; c &lt;&lt; endl;
  return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
&#x2F;&#x2F;演示cin.getline()可以接受空格
int main(void)
&#123;
char buf1[256];
char buf2[256];
cout &lt;&lt; &quot;\n请输入你的字符串不超过256&quot;;
cin.getline(buf1,256,&#39;\n &#39;);
cout &lt;&lt; buf1 &lt;&lt; endl;
&#x2F;&#x2F;
cout &lt;&lt;&quot;注意: cin.getline()和cin &gt;&gt; buf2的区别,能不能带空格&quot; &lt;&lt; endl;
cin &gt;&gt; buf2 ;&#x2F;&#x2F;流提取操作符遇见空格停止提取输入流
cout &lt;&lt; buf2 &lt;&lt; endl;
return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
&#x2F;&#x2F;缓冲区实验
&#x2F;*
1输入&quot;aa bb cc dd&quot;字符串入缓冲区2通过cin &gt;&gt; buf1;提走了aa
3不需要输入可以再通过cin.getline()把剩余的缓冲区数据提走*&#x2F;
int main()
&#123;
  char buf1[256];
  char buf2[256];
  cout &lt;&lt; &quot;请输入带有空格的字符串,测试缓冲区&quot; &lt;&lt; endl;
  cin &gt;&gt; buf1;
  cout &lt;&lt; &quot;buf1:&quot; &lt;&lt; buf1 &lt;&lt; endl;
  cout &lt;&lt; &quot;请输入数据...&quot; &lt;&lt; endl;
  &#x2F;&#x2F;缓冲区没有数据,就等待;缓冲区如果有数据直接从缓冲区中拿走数据cin.getline( buf2，256);
  cout &lt;&lt; &quot;buf2: &quot; &lt;&lt; buf2 &lt;&lt; endl;
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
using namespace std;
&#x2F;&#x2F;案例:输入的整数和字符串分开处理
int main()
&#123;
  cout &lt;&lt; &quot;Please, enter a number or a word: &quot;;
  char c &#x3D; cin.get();
  if ((c &gt;&#x3D; &#39;0&#39;) &amp;&amp; (c &lt;&#x3D; &#39;9&#39;)) &#x2F;&#x2F;输入的整数和字符串分开处理
  &#123;
    int n; &#x2F;&#x2F;整数不可能中间有空格使用cin &gt;&gt;n
    cin.putback(c);
    cin &gt;&gt; n;
    cout &lt;&lt; &quot;You entered a number: &quot; &lt;&lt; n &lt;&lt; &#39;\n&#39;;
  &#125;
  else
  &#123;
    string str;
    cin.putback(c);
    getline(cin, str); &#x2F;&#x2F;&#x2F;&#x2F;字符串中间可能有空格使用cin.getline();
    cout &lt;&lt; &quot;You entered a word: &quot; &lt;&lt; str &lt;&lt; &#39;\n &#39;;
  &#125;
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="标准的输出流"><a href="#标准的输出流" class="headerlink" title="标准的输出流"></a>标准的输出流</h4><ul>
<li>cout.put()</li>
<li>cout.write()</li>
<li>cout.width()</li>
<li>cout.fill()</li>
<li>cout.setf(标记)</li>
</ul>
<ul>
<li>操作符、控制符</li>
<li>flush</li>
<li>endl</li>
<li> oct</li>
<li>dec</li>
<li>hex</li>
<li>setbase</li>
<li>setw</li>
<li>setfill</li>
<li>setprecision</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;
int main(void)
&#123;
  cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;
  cout.put(&#39;h&#39;).put(&#39;e &#39;).put(&#39;l &#39;).put(&#39; \n &#39;);
  cout.write(&quot;hello world&quot;, 4); &#x2F;&#x2F;输出的长度
  char buf[] &#x3D; &quot;hello world&quot;;
  printf(&quot; \n&quot;);
  cout.write(buf, strlen(buf));
  printf(&quot; \n&quot;);
  cout.write(buf, strlen(buf) - 6);
  printf(&quot; \n&quot;);
  return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;
&#x2F;&#x2F;使用cout.setf()控制符
int main(void)
&#123;
  &#x2F;&#x2F;使用类成员函数
  cout &lt;&lt; &quot;&lt;start&gt;&quot;;

  cout.width(30);
  cout.fill(&#39;*&#39;);
  cout.setf(ios::showbase); &#x2F;&#x2F;#include &lt;iomanip&gt;
  cout.setf(ios::internal); &#x2F;&#x2F;设置
  cout &lt;&lt; hex &lt;&lt; 123 &lt;&lt; &quot;&lt;End&gt; \n&quot;;
  cout &lt;&lt; endl;
  cout &lt;&lt; endl;
  &#x2F;&#x2F;使用操作符、控制符
  cout &lt;&lt; &quot;&lt;Start&gt;&quot;
       &lt;&lt; setw(30)
       &lt;&lt; setfill.(&#39;*&#39;)
       &lt;&lt; setiosflags(ios::showbase) &#x2F;&#x2F;基数
       &lt;&lt; setiosflags(ios::internal)
       &lt;&lt; hex
       &lt;&lt; 123
       &lt;&lt; &quot;&lt;End&gt; \n&quot;
       &lt;&lt; endl;
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="输出格式化"><a href="#输出格式化" class="headerlink" title="输出格式化"></a>输出格式化</h4><ul>
<li><p>在输出数据时，为简便起见，往往不指定输出的格式，由系统根据数据的类型采取默认的格式，但有时希望数据按指定的格式输出，如要求以十六进制或八进制形式输出一个整数，对输出的小数只保留两位小数等。有两种方法可以达到此目的。</p>
<ol>
<li>使用控制符的方法;</li>
<li>使用流对象的有关成员函数。分别叙述如下。</li>
</ol>
<p><img src="http://qiniu.orangew.cn/img/20220706212923.png" alt="20220706212923"></p>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;
int main()
&#123;
  int a;
  cout &lt;&lt; &quot;input a: &quot;;
  cin &gt;&gt; a;
  cout &lt;&lt; &quot;dec : &quot; &lt;&lt; dec &lt;&lt; a &lt;&lt; endl;           &#x2F;&#x2F;以十进制形式输出整数
  cout &lt;&lt; &quot;hex : &quot; &lt;&lt; hex &lt;&lt; a &lt;&lt; endl;           &#x2F;&#x2F;以十六进制形式输出整数a
  cout &lt;&lt; &quot;oct: &quot; &lt;&lt; setbase(8) &lt;&lt; a &lt;&lt; endl;     &#x2F;&#x2F;以八进制形式输出整数a
  const char *pt &#x3D; &quot;China&quot;;                       &#x2F;&#x2F; pt指向字符串&quot;china&quot;
  cout &lt;&lt; setw(10) &lt;&lt; pt &lt;&lt; endl;                 &#x2F;&#x2F;指定域宽为,输出字符串
  cout &lt;&lt; setfill(&#39;*&#39;) &lt;&lt; setw(10) &lt;&lt; pt &lt;&lt; endl; &#x2F;&#x2F;指定域宽,输出字符串,空白处以&#39;*&#39;填&gt;充
  double pi&#x3D;22.0&#x2F;7.0;&#x2F;&#x2F;计算pi值
  &#x2F;&#x2F;按指数形式输出,8位小数
  cout &lt;&lt; setiosflags(ios::scientific) &lt;&lt; setprecision(8);
  cout &lt;&lt; &quot;pi&#x3D;&quot; &lt;&lt; pi &lt;&lt; endl;                    &#x2F;&#x2F;输出pi值
  cout &lt;&lt; &quot;pi&#x3D;&quot; &lt;&lt; setprecision(4) &lt;&lt; pi &lt;&lt; endl; &#x2F;&#x2F;改为位小数
  return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double a&#x3D;123.456789012345;&#x2F;&#x2F;对a赋初值 
cout&lt;&lt;a;&#x2F;&#x2F;输出:123.456
cout&lt;&lt;setprecision(9)&lt;&lt;a;&#x2F;&#x2F;输出:123.456789 
cout&lt;&lt;setprecision(6);&#x2F;&#x2F;恢复默认格式(精度为6)
cout&lt;&lt; setiosflags(ios::fixed);&#x2F;&#x2F;输出:123.456789
cout&lt;&lt;setiosflags(ios::fixed)&lt;&lt;setprecision(8)&lt;&lt;a;&#x2F;&#x2F;输出:123.45678901
cout&lt;&lt;setiosflags(ios::scientific)&lt;&lt;a;&#x2F;&#x2F;输出:1.234568e+02 cout&lt;&lt;setiosflags(ios::scientific)&lt;&lt;setprecision(4)&lt;&lt;a;&#x2F;&#x2F;输出:1.2346e02


int b&#x3D;123456;&#x2F;&#x2F;对b赋初值1) 
cout&lt;&lt;b;&#x2F;&#x2F;输出: 123456
cout&lt;&lt;hex&lt;&lt;b;&#x2F;&#x2F;输出:1e240
cout&lt;&lt;setiosflags(ios:: uppercase)&lt;&lt;b;&#x2F;&#x2F;输出:1E2404) 
cout&lt;&lt;setw(10)&lt;&lt;b&lt;&lt;&#39;， &#39;&lt;&lt;b;&#x2F;&#x2F;输出:123456，1234565) 
cout&lt;&lt;setfill(&#39;*&#39;)&lt;&lt;setw(10)&lt;&lt;b;&#x2F;&#x2F;输出:****1234566) 
cout&lt;&lt;setiosflags(ios::showpos)&lt;&lt;b;&#x2F;&#x2F;输出:+123456
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>如果在多个cout语句中使用相同的setw(n)，并使用setiosflags(ios::right)，可以实现各行数据右对齐，如果指定相同的精度，可以实现上下小数点对齐。</li>
<li><img src="http://qiniu.orangew.cn/img/20220706213015.png" alt="20220706213015"></li>
<li><img src="http://qiniu.orangew.cn/img/20220706213034.png" alt="20220706213034"></li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;
int main()
&#123;
  int a &#x3D; 21;
  cout.setf(ios::showbase);      &#x2F;&#x2F;显示基数符号(Ox或)
  cout &lt;&lt; &quot;dec : &quot; &lt;&lt; a &lt;&lt; endl; &#x2F;&#x2F;默认以十进制形式输出a
  cout.unsetf(ios::dec);         &#x2F;&#x2F;终止十进制的格式设置
  cout.setf(ios::hex);           &#x2F;&#x2F;设置以十六进制输出的状态
  cout &lt;&lt; &quot;hex: &quot; &lt;&lt; a &lt;&lt; endl;  &#x2F;&#x2F;以十六进制形式输出a
  cout.unsetf(ios::hex);         &#x2F;&#x2F;终止十六进制的格式设置
  cout.setf(ios::oct);           &#x2F;&#x2F;设置以八进制输出的状态
  cout &lt;&lt; &quot;oct: &quot; &lt;&lt; a &lt;&lt; endl;  &#x2F;&#x2F;以八进制形式输出a
  cout.unsetf(ios::oct);
  const char *pt &#x3D; &quot;China&quot;;     &#x2F;&#x2F; pt指向字符串&quot;China&quot;
  cout.width(10);               &#x2F;&#x2F;指定域宽为
  cout &lt;&lt; pt &lt;&lt; endl;           &#x2F;&#x2F;输出字符串
  cout.width(10);               &#x2F;&#x2F;指定域宽为
  cout.fi11(&#39;*&#39;);               &#x2F;&#x2F;指定空白处以&#39;*&#39;填充
  cout &lt;&lt; pt &lt;&lt; endl;           &#x2F;&#x2F;输出字符串
  double pi &#x3D; 22.0 &#x2F; 7.6;       &#x2F;&#x2F;输出pi值
  cout.setf(ios::scientific);   &#x2F;&#x2F;指定用科学记数法输出
  cout &lt;&lt; &quot;pi&#x3D;&quot;;                &#x2F;&#x2F;输出&quot;pi&#x3D;&quot;
  cout.width(14);               &#x2F;&#x2F;指定域宽为
  cout &lt;&lt; pi &lt;&lt; endl;           &#x2F;&#x2F;输出pi值
  cout.unsetf(ios::scientific); &#x2F;&#x2F;终止科学记数法状态
  cout.setf(ios::fixed);        &#x2F;&#x2F;指定用定点形式输出
  cout.width(12);               &#x2F;&#x2F;指定域宽为
  cout.setf(ios::showpos);      &#x2F;&#x2F;正数输出“+”号
  cout.setf(ios::internal);     &#x2F;&#x2F;数符出现在左侧
  cout.precision(6);            &#x2F;&#x2F;保留位小数
  cout &lt;&lt; pi &lt;&lt; endl;           &#x2F;&#x2F;输出pi,注意数符“+”的位置
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>对程序的几点说明</p>
</li>
<li><p>成员函数width(n)和控制符setw(n)只对其后的第一个输出项有效。如∶cout. width(6);<br>cout &lt;&lt;20&lt;&lt;3.14&lt;&lt;endl;<br>输出结果为203.14</p>
</li>
<li><p>在输出第一个输出项20时，域宽为6，因此在20前面有4个空格，在输出3.14时，width (6)已不起作用，此时按系统默认的域宽输出（按数据实际长度输出)。如果要求在输出数据时都按指定的同一域宽n输出，不能只调用一次width(n)，而必须在输出每一项前都调用一次width(n&gt;，上面的程序中就是这样做的。</p>
</li>
<li><p>在表13.5中的输出格式状态分为5组，每一组中同时只能选用一种（例如dec、hex和oct中只能选一，它们是互相排斥的)。在用成员函数setf和控制符setiosflags设置输出格式状态后，如果想改设置为同组的另一状态，应当调用成员函数unsetf (对应于成员函数self )或resetiosflags (对应于控制符setiosflags )，先终止原来设置的状态。然后再设置其他状态，大家可以从本程序中看到这点。程序在开始虽然没有用成员函数self和控制符setiosflags设置用dec输出格式状态，但系统默认指定为dec，因此要改变为hex或oct，也应当先用unsetf 函数终止原来设置。如果删去程序中的第7行和第10行，虽然在第8行和第11行中用成员函数setf设置了hex和oct格式，由于未终止dec格式，因此hex和oct的设置均不起作用，系统依然以十进制形式输出。</p>
</li>
<li><p>同理，程序倒数第8行的unsetf 函数的调用也是不可缺少的。</p>
</li>
<li><p>用setf 函数设置格式状态时，可以包含两个或多个格式标志，由于这些格式标志在ios类中被定义为枚举值，每一个格式标志以一个二进位代表，因此可以用位或运算符“|”组合多个格式标志。如倒数第5、第6行可以用下面一行代替∶</p>
</li>
<li><p>cout.setf(ios:internal | iosshowpos);//包含两个状态标志，用””组合</p>
</li>
<li><p>可以看到:对输出格式的控制，既可以用控制符(如例13.2)，也可以用cout流的有关成员函数(如例13.3)，二者的作用是相同的。控制符是在头文件</p>
</li>
<li><p>iomanip中定义的，因此用控制符时，必须包含iomanip头文件。cout流的成员函数是在头文件iostream中定义的，因此只需包含头文件iostream，不必包含iomanip。许多程序人员感到使用控制符方便简单，可以在一个cout输出语句中连续使用多种控制符。</p>
</li>
</ul>
<h3 id="文件I-O"><a href="#文件I-O" class="headerlink" title="文件I/O"></a>文件I/O</h3><h4 id="文件流类和文件流对象"><a href="#文件流类和文件流对象" class="headerlink" title="文件流类和文件流对象"></a>文件流类和文件流对象</h4><ul>
<li>输入输出是以系统指定的标准设备(输入设备为键盘，输出设备为显示器）为对象的。在实际应用中，常以磁盘文件作为对象。即从磁盘文件读取数据，将数据输出到磁盘文件。<br>和文件有关系的输入输出类主要在fstream.h这个头文件中被定义，在这个头文件中主要被定义了三个类，由这三个类控制对文件的各种输入输出操作，他们分别是ifstream、ofstream、fstream，其中fstream类是由iostream类派生而来，他们之间的继承关系见下图所示。</li>
<li><img src="http://qiniu.orangew.cn/img/20220706213719.png" alt="20220706213719"></li>
</ul>
<h4 id="文件的打开与关闭"><a href="#文件的打开与关闭" class="headerlink" title="文件的打开与关闭"></a>文件的打开与关闭</h4><ul>
<li><p>打开文件</p>
<ul>
<li><p>所谓打开(open)文件是一种形象的说法，如同打开房门就可以进入房间活动一样。打开文件是指在文件读写之前做必要的准备工作，包括:</p>
<ul>
<li><p>为文件流对象和指定的磁盘文件建立关联，以便使文件流流向指定的磁盘文件。</p>
</li>
<li><p>指定文件的工作方式，如，该文件是作为输入文件还是输出文件，是ASCII文件还是二进制文件等。<br>以上工作可以通过两种不同的方法实现。</p>
<ol>
<li><p>调用文件流的成员函数open。如</p>
<ul>
<li><p>ofstream outfile;/定义ofstream类(输出文件流类)对象outfile</p>
</li>
<li><p>outfile.open(“f1.dat”,ios::out);//使文件流与f1.dat文件建立关联</p>
</li>
<li><p>第2行是调用输出文件流的成员函数open打开磁盘文件f1.dat，并指定它为输出文件，文件流对象outfile将向磁盘文件f1.dat输出数据。ios:.out是l/O模式的一种，表示以输出方式打开一个文件。或者简单地说，此时f1.dat是一个输出文件，接收从内存输出的数据。</p>
</li>
<li><p>调用成员函数open的一般形式为︰</p>
</li>
<li><p>文件流对象.open(磁盘文件名,输入输出方式);</p>
</li>
<li><p>磁盘文件名可以包括路径，如”c:\new\f1.dat”，如缺省路径，则默认为当前目录下的文件</p>
</li>
</ul>
</li>
<li><p>在定义文件流对象时指定参数</p>
<ul>
<li><p>在声明文件流类时定义了带参数的构造函数，其中包含了打开磁盘文件的功能。因此，可以在定义文件流对象时指定参数，调用文件流类的构造函数来实现打开文件的功能。如</p>
</li>
<li><p>ostream outfile(“f1.dat”,ios:out);一般多用此形式，比较方便。作用与open函数相同。</p>
</li>
<li><p>输入输出方式是在ios类中定义的，它们是枚举常量，有多种选择，见表</p>
</li>
<li><p><img src="http://qiniu.orangew.cn/img/20220706214222.png" alt="20220706214222"></p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>几点说明</p>
<ol>
<li>新版本的I/O类库中不提供ios:nocreate和ios:noreplace。</li>
<li>每一个打开的文件都有一个文件指针，该指针的初始位置由I/O方式指定，每次读写都从文件指针的当前位置开始。每读入一个字节，指针就后移一个字节。当文件指针移到最后，就会遇到文件结束EOF(文件结束符也占一个字节，其值为-1)，此时流对象的成员函数eof的值为非0值(一般设为1)，表示文件结束了</li>
<li>可以用“位或”运算符“|”对输入输出方式进行组合，如表13.6中最后3行所示那样。还可以举出下面一些例子∶<ul>
<li>iosin | ios:: noreplace //打开一个输入文件，若文件不存在则返回打开失败的信息</li>
<li>ios:app | ios:nocreate //打开一个输出文件，在文件尾接着写数据，若文件不存在，则返回打开失败的信息</li>
<li>ios:out l ios:noreplace //打开一个新文件作为输出文件，如果文件已存在则返回打开失败的信</li>
<li>ios:in l ios:out I ios:binary l/打开一个二进制文件，可读可写</li>
<li>但不能组合互相排斥的方式，如ios:nocreate l ios:noreplace。</li>
</ul>
</li>
<li>如果打开操作失败，open函数的返回值为O(假)，如果是用调用构造函数的方式打开文件的，则流对象的值为0。可以据此测试打开是否成功。如<ul>
<li>if(outfile.open(“f1.bat”,ios:app)==O)<br>cout &lt;&lt;”open error”;</li>
<li>if( !outfile.open(“f1.bat”,ios:app))cout &lt;&lt;”open error”;</li>
</ul>
</li>
</ol>
</li>
<li><p>关闭文件</p>
<ul>
<li>在对已打开的磁盘文件的读写操作完成后，应关闭该文件。关闭文件用成员函数close。如</li>
<li>outfile.close( );//将输出文件流所关联的磁盘文件关闭</li>
<li>所谓关闭，实际上是解除该磁盘文件与文件流的关联，原来设置的工作方式也失效，这样，就不能再通过文件流对该文件进行输入或输出。此时可以将文件流与其他磁盘文件建立关联，通过文件流对新的文件进行输入或输出。如</li>
<li>outfile.open(“f2.dat”,ios::app| ios::nocreate);</li>
<li>此时文件流outfile与f2.dat建立关联，并指定了f2.dat的工作方式。</li>
</ul>
</li>
</ul>
<h4 id="C-对ASCII文件的读写操作"><a href="#C-对ASCII文件的读写操作" class="headerlink" title="C++对ASCII文件的读写操作"></a>C++对ASCII文件的读写操作</h4><ul>
<li>如果文件的每一个字节中均以ASCIl代码形式存放数据,即一个字节存放一个字符,这个文件就是AScll文件(或称字符文件)。程序可以从ASCII文件中读入若干个字符,也可以向它输出一些字符。</li>
<li>用流插入运算符”&lt;&lt;”和流提取运算符”&gt;&gt;”输入输出标准类型的数据。”&lt;&lt;’和”&gt;&gt;”都巳在iostream中被重载为能用于ostream和istream类对象的标准类型的输入输出。由于ifstream和ofstream分别是ostream和istream类的派生类﹔因此它们从ostream和istream类继承了公用的重载函数，所以在对磁盘文件的操作中，可以通过文件流对象和流插入运算符“&lt;&lt;”及流提取运算符“&gt;&gt;”实现对磁盘文件的读写，如同用cin、cout和&lt;&lt;、&gt;&gt;对标准设备进行读写一样。</li>
<li>用文件流的put、get、geiline等成员函数进行字符的输入输出，︰用C++流成员函数put输出单个字符、C++ get()函数读入一个字符和C++ getline()函数读入一行字符。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;
int main(void)
&#123;
  char *fname &#x3D; &quot;c:&#x2F;aaaa.txt&quot;;
  ofstream fout(fname, ios::app); &#x2F;&#x2F;建一个输出流对象和文件关联;
  if (!fout)
  &#123;
    cout &lt;&lt; &quot;打开文件失败&quot; &lt;&lt; endl;
    return;
  &#125;
  fout &lt;&lt; &quot;hello.. ..111&quot; &lt;&lt; endl;
  fout &lt;&lt; &quot;hello. . ..222&quot; &lt;&lt; endl;
  fout &lt;&lt; &quot;hello.. . .333&quot; &lt;&lt; endl;
  fout.close();
  &#x2F;&#x2F;读文件
  ifstream fin(fname); &#x2F;&#x2F;建立一个输入流对象和文件关联
  char ch;
  while (fin.get(ch))
  &#123;
    cout &lt;&lt; ch;
  &#125;
  fin.close();
  return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="C-对二进制文件的读写操作"><a href="#C-对二进制文件的读写操作" class="headerlink" title="C++对二进制文件的读写操作"></a>C++对二进制文件的读写操作</h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;
#include &lt;fstream&gt;
using namespace std;
class Teacher
&#123;
public:
  Teacher()
  &#123;
    age &#x3D; 33;
    strcpy(name, &quot;&quot;);
  &#125;
  Teacher(int _age, const char *_name)
  &#123;
    age &#x3D; _age;
    strcpy(name, _name);
  &#125;
  void printT()
  &#123;
    cout &lt;&lt; &quot;age: &quot; &lt;&lt; age &lt;&lt; &quot;name : &quot; &lt;&lt; name &lt;&lt; endl;
  &#125;

protected:
private:
  int age;
  char name[32];
&#125;;
int main()
&#123;
  const char *fname &#x3D; &quot;.&#x2F; 11a.dat&quot;;
  ofstream fout(fname, ios::binary); &#x2F;&#x2F; 建一个输出流对象和文件关联;
  if (!fout)
  &#123;
    cout &lt;&lt; &quot;打开文件失败 &quot; &lt;&lt; endl;
    return -1;
  &#125;
  Teacher t1(31, &quot;t31&quot;);
  Teacher t2(32, &quot;t32&quot;);
  fout.write((char *)&amp;t1, sizeof(Teacher));
  fout.write((char *)&amp;t2, sizeof(Teacher));
  fout.close();
  &#x2F;&#x2F;
  ifstream fin(fname);
  &#x2F;&#x2F; 建立一个输入流对象和文件关联
  Teacher tmp;
  fin.read((char *)&amp;tmp, sizeof(Teacher));
  tmp.printT();

  fin.read((char *)&amp;tmp, sizeof(Teacher));
  tmp.printT();
  fin.close();
  return 0;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/c/" rel="tag"><i class="fa fa-tag"></i> c++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/01/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B%E6%95%B4%E7%90%86/" rel="prev" title="C++基础教程整理">
      <i class="fa fa-chevron-left"></i> C++基础教程整理
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/07/06/C-STL/" rel="next" title="C++STL">
      C++STL <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%BC%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">综述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%AF%B9C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8A%A0%E5%BC%BA"><span class="nav-number">3.</span> <span class="nav-text">C++对C语言的加强</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#namespace%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="nav-number">3.1.</span> <span class="nav-text">namespace命名空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%9F%BA%E6%9C%AC%E5%B8%B8%E8%AF%86"><span class="nav-number">3.1.1.</span> <span class="nav-text">C++命名空间基本常识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%AE%9A%E4%B9%89%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.2.</span> <span class="nav-text">C++命名空间定义以及使用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5"><span class="nav-number">3.1.3.</span> <span class="nav-text">C++命名空间编程实践</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA"><span class="nav-number">3.1.4.</span> <span class="nav-text">结论</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E7%94%A8%E6%80%A7%E5%A2%9E%E5%BC%BA"><span class="nav-number">3.2.</span> <span class="nav-text">实用性增强</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E6%A3%80%E6%B5%8B%E5%A2%9E%E5%BC%BA"><span class="nav-number">3.3.</span> <span class="nav-text">变量检测增强</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#struct-%E7%B1%BB%E5%9E%8B%E5%A2%9E%E5%BC%BA"><span class="nav-number">3.4.</span> <span class="nav-text">struct 类型增强</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E4%B8%AD%E6%89%80%E6%9C%89%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0%E9%83%BD%E5%BF%85%E9%A1%BB%E6%9C%89%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.5.</span> <span class="nav-text">C++中所有变量和函数都必须有类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%B0%E5%A2%9Ebool%E7%B1%BB%E5%9E%8B%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">3.6.</span> <span class="nav-text">新增bool类型关键字</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E5%8A%9F%E8%83%BD%E5%A2%9E%E5%BC%BA"><span class="nav-number">3.7.</span> <span class="nav-text">三目运算符功能增强</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#const%E5%A2%9E%E5%BC%BA"><span class="nav-number">3.8.</span> <span class="nav-text">const增强</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#const%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="nav-number">3.8.1.</span> <span class="nav-text">const基础知识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E2%80%9C%E5%86%92%E7%89%8C%E8%B4%A7%E2%80%9D"><span class="nav-number">3.8.2.</span> <span class="nav-text">C语言中的“冒牌货”</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const-%E5%92%8C-define%E7%9A%84%E7%9B%B8%E5%90%8C"><span class="nav-number">3.8.3.</span> <span class="nav-text">const 和#define的相同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const%E5%92%8C-define%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-number">3.8.4.</span> <span class="nav-text">const和#define的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9C%9F%E6%AD%A3%E7%9A%84%E6%9E%9A%E4%B8%BE"><span class="nav-number">3.9.</span> <span class="nav-text">真正的枚举</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C-%E5%AF%B9C%E8%AF%AD%E8%A8%80%E7%9A%84%E6%8B%93%E5%B1%95"><span class="nav-number">4.</span> <span class="nav-text">C++对C语言的拓展</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">4.1.</span> <span class="nav-text">引用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E9%87%8F%E5%90%8D"><span class="nav-number">4.1.1.</span> <span class="nav-text">变量名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">4.1.2.</span> <span class="nav-text">引用的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%84%E5%88%99"><span class="nav-number">4.1.3.</span> <span class="nav-text">规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">4.1.4.</span> <span class="nav-text">引用作为函数参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">4.1.5.</span> <span class="nav-text">引用的意义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="nav-number">4.1.6.</span> <span class="nav-text">引用的本质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%88%E5%BC%95%E7%94%A8%E5%BD%93%E5%B7%A6%E5%80%BC%EF%BC%89"><span class="nav-number">4.1.7.</span> <span class="nav-text">引用作为函数的返回值（引用当左值）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E9%92%88%E5%BC%95%E7%94%A8"><span class="nav-number">4.1.8.</span> <span class="nav-text">指针引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const%E5%BC%95%E7%94%A8"><span class="nav-number">4.1.9.</span> <span class="nav-text">const引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const%E5%BC%95%E7%94%A8%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">4.1.10.</span> <span class="nav-text">const引用的原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#inline%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-number">4.2.</span> <span class="nav-text">inline内联函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">4.2.1.</span> <span class="nav-text">内联函数基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0VS%E5%AE%8F%E5%87%BD%E6%95%B0"><span class="nav-number">4.2.2.</span> <span class="nav-text">内联函数VS宏函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0%E6%80%BB%E7%BB%93"><span class="nav-number">4.2.3.</span> <span class="nav-text">内联函数总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%92%8C%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0"><span class="nav-number">4.3.</span> <span class="nav-text">默认参数和占位参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E4%B8%AA%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="nav-number">4.3.1.</span> <span class="nav-text">单个默认参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E4%B8%AA%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="nav-number">4.3.2.</span> <span class="nav-text">多个默认参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E8%A7%84%E5%88%99"><span class="nav-number">4.3.3.</span> <span class="nav-text">默认参数规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%A0%E4%BD%8D%E5%8F%82%E6%95%B0"><span class="nav-number">4.3.4.</span> <span class="nav-text">占位参数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="nav-number">4.4.</span> <span class="nav-text">函数重载</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E8%A7%84%E5%88%99"><span class="nav-number">4.4.1.</span> <span class="nav-text">函数重载规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B0%83%E7%94%A8%E5%87%86%E5%88%99"><span class="nav-number">4.4.2.</span> <span class="nav-text">调用准则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.4.3.</span> <span class="nav-text">重载的底层实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E4%B8%8E%E5%87%BD%E6%95%B0%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="nav-number">4.4.4.</span> <span class="nav-text">函数重载与函数默认参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E4%B8%8E%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9B%B8%E7%BB%93%E5%90%88"><span class="nav-number">4.4.5.</span> <span class="nav-text">函数重载与函数指针相结合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">4.4.6.</span> <span class="nav-text">函数指针基本语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E6%80%BB%E7%BB%93"><span class="nav-number">4.4.7.</span> <span class="nav-text">函数重载总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.</span> <span class="nav-text">类和对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">5.1.</span> <span class="nav-text">基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.1.1.</span> <span class="nav-text">类与对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E4%B8%8E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">5.1.2.</span> <span class="nav-text">成员变量与成员函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-number">5.2.</span> <span class="nav-text">封装与访问控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8Estruct%E8%AF%B4%E8%B5%B7"><span class="nav-number">5.2.1.</span> <span class="nav-text">从struct说起</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%81%E8%A3%85%E7%9A%84%E8%AE%BF%E9%97%AE%E5%B1%9E%E6%80%A7"><span class="nav-number">5.2.2.</span> <span class="nav-text">封装的访问属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8class%E5%8E%BB%E5%B0%81%E8%A3%85%E5%B8%A6%E8%A1%8C%E4%B8%BA%E7%9A%84%E7%B1%BB"><span class="nav-number">5.2.3.</span> <span class="nav-text">用class去封装带行为的类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E6%A1%88%E4%BE%8B%E7%BB%83%E4%B9%A0"><span class="nav-number">5.3.</span> <span class="nav-text">面向对象编程案例练习</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B1%82%E5%9C%86%E7%9A%84%E5%91%A8%E9%95%BF%E5%92%8C%E9%9D%A2%E7%A7%AF"><span class="nav-number">5.3.1.</span> <span class="nav-text">求圆的周长和面积</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C%E8%AF%AD%E8%A8%80%E5%92%8CC-%E8%AF%AD%E8%A8%80%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">5.3.2.</span> <span class="nav-text">C语言和C++语言的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%BC%E5%90%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90"><span class="nav-number">5.3.3.</span> <span class="nav-text">综合面向对象案例分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84"><span class="nav-number">5.4.</span> <span class="nav-text">对象的构造和析构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">5.4.1.</span> <span class="nav-text">如果没有构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">5.4.2.</span> <span class="nav-text">构造函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">5.4.3.</span> <span class="nav-text">析构函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%88%86%E7%B1%BB%E5%8F%8A%E8%B0%83%E7%94%A8"><span class="nav-number">5.4.4.</span> <span class="nav-text">构造函数的分类及调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%A7%84%E5%88%99"><span class="nav-number">5.4.5.</span> <span class="nav-text">构造函数规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="nav-number">5.4.6.</span> <span class="nav-text">浅拷贝和深拷贝</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8"><span class="nav-number">5.4.7.</span> <span class="nav-text">构造函数初始化列表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%BA%E5%8C%96%E8%AE%AD%E7%BB%83"><span class="nav-number">5.4.8.</span> <span class="nav-text">强化训练</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E5%8A%A8%E6%80%81%E5%BB%BA%E7%AB%8B%E5%92%8C%E9%87%8A%E6%94%BEnew%E5%92%8Cdelete"><span class="nav-number">5.5.</span> <span class="nav-text">对象动态建立和释放new和delete</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">5.6.</span> <span class="nav-text">静态成员变量和成员函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="nav-number">5.6.1.</span> <span class="nav-text">静态成员变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">5.6.2.</span> <span class="nav-text">静态成员函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-number">5.7.</span> <span class="nav-text">编译器对属性和方法的处理机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8D%A0%E5%A4%9A%E5%A4%A7"><span class="nav-number">5.7.1.</span> <span class="nav-text">静态成员占多大</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-number">5.7.2.</span> <span class="nav-text">处理机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#this%E6%8C%87%E9%92%88"><span class="nav-number">5.7.3.</span> <span class="nav-text">this指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E4%B8%8E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-number">5.7.4.</span> <span class="nav-text">全局函数与成员函数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%BA%E5%8C%96%E7%BB%83%E4%B9%A0"><span class="nav-number">5.8.</span> <span class="nav-text">强化练习</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8B%E5%85%83"><span class="nav-number">5.9.</span> <span class="nav-text">友元</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="nav-number">5.9.1.</span> <span class="nav-text">友元函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E5%AF%B9%E8%B1%A1"><span class="nav-number">5.9.2.</span> <span class="nav-text">友元对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%BA%E5%8F%8B%E5%85%83"><span class="nav-number">5.9.3.</span> <span class="nav-text">论友元</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">5.9.4.</span> <span class="nav-text">运算符重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E9%87%8D%E8%BD%BD"><span class="nav-number">5.9.5.</span> <span class="nav-text">友元重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E9%87%8D%E8%BD%BD"><span class="nav-number">5.9.6.</span> <span class="nav-text">成员重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E8%A7%84%E5%88%99"><span class="nav-number">5.9.7.</span> <span class="nav-text">重载规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8C%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">5.9.8.</span> <span class="nav-text">双目运算符重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E7%9B%AE%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">5.9.9.</span> <span class="nav-text">单目运算符重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="nav-number">5.9.10.</span> <span class="nav-text">输入输出运算符重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E8%BF%98%E6%98%AF%E6%88%90%E5%91%98"><span class="nav-number">5.9.11.</span> <span class="nav-text">友元还是成员</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E6%8F%90%E9%AB%98"><span class="nav-number">5.9.12.</span> <span class="nav-text">运算符重载提高</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%87%8D%E8%BD%BDnew%E5%92%8Cdelete%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-number">5.9.13.</span> <span class="nav-text">重载new和delete运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%BC%95%E7%94%A8%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-number">5.9.14.</span> <span class="nav-text">解引用与智能指针</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%B4%BE%E7%94%9F"><span class="nav-number">6.</span> <span class="nav-text">继承派生</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%92%8C%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">6.1.</span> <span class="nav-text">类和类之间的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%A7%E6%89%BF"><span class="nav-number">6.2.</span> <span class="nav-text">什么是继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="nav-number">6.3.</span> <span class="nav-text">继承的方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95"><span class="nav-number">6.3.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#protected%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-number">6.3.2.</span> <span class="nav-text">protected访问控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%88%90%E5%91%98%E7%9A%84%E6%A0%87%E8%AF%86%E5%92%8C%E8%AE%BF%E9%97%AE"><span class="nav-number">6.3.3.</span> <span class="nav-text">派生类成员的标识和访问</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84"><span class="nav-number">6.4.</span> <span class="nav-text">继承中的构造和析构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7%E5%8E%9F%E5%88%99"><span class="nav-number">6.4.1.</span> <span class="nav-text">类型兼容性原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">6.4.2.</span> <span class="nav-text">继承中的对象模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E6%9E%90%E6%9E%84%E8%B0%83%E7%94%A8%E5%8E%9F%E5%88%99"><span class="nav-number">6.4.3.</span> <span class="nav-text">继承中构造析构调用原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E5%92%8C%E7%BB%84%E5%90%88%E5%B9%B6%E5%AD%98%EF%BC%8C%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E5%8E%9F%E5%88%99"><span class="nav-number">6.4.4.</span> <span class="nav-text">继承和组合并存，构造和析构原则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E5%90%8C%E5%90%8D%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="nav-number">6.4.5.</span> <span class="nav-text">继承中同名成员变量处理方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%AD%E7%9A%84static%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">6.4.6.</span> <span class="nav-text">派生类中的static关键字</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="nav-number">6.5.</span> <span class="nav-text">多继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95-1"><span class="nav-number">6.5.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B2%99%E5%8F%91%E5%BA%8A%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.5.2.</span> <span class="nav-text">沙发床实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF"><span class="nav-number">6.6.</span> <span class="nav-text">虚继承</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%AD%E4%BA%8C%E4%B9%89%E6%80%A7%E9%97%AE%E9%A2%98"><span class="nav-number">6.6.1.</span> <span class="nav-text">多继承中二义性问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BFvirtual"><span class="nav-number">6.6.2.</span> <span class="nav-text">虚继承virtual</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A4%9A%E6%80%81"><span class="nav-number">7.</span> <span class="nav-text">多态</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81"><span class="nav-number">7.1.</span> <span class="nav-text">什么是多态</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%85%E6%9E%90%E5%A4%9A%E6%80%81%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">7.1.1.</span> <span class="nav-text">浅析多态的意义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%8B%E5%80%BC%E5%85%BC%E5%AE%B9%EF%BC%88%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%89%8D%E6%8F%90%EF%BC%89"><span class="nav-number">7.1.2.</span> <span class="nav-text">赋值兼容（多态实现的前提）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%96%B0%E9%9C%80%E6%B1%82"><span class="nav-number">7.1.3.</span> <span class="nav-text">面向对象新需求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">7.1.4.</span> <span class="nav-text">解决方案</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E5%B7%A5%E7%A8%8B%E7%9A%84%E6%84%8F%E4%B9%89"><span class="nav-number">7.1.5.</span> <span class="nav-text">多态工程的意义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E6%88%90%E7%AB%8B%E7%9A%84%E6%9D%A1%E4%BB%B6"><span class="nav-number">7.1.6.</span> <span class="nav-text">多态成立的条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E8%81%94%E7%BC%96%E5%92%8C%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96"><span class="nav-number">7.1.7.</span> <span class="nav-text">静态联编和动态联编</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">7.2.</span> <span class="nav-text">虚析构函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%87%8D%E8%BD%BD%E3%80%81%E9%87%8D%E5%86%99%E3%80%81%E9%87%8D%E5%AE%9A%E4%B9%89"><span class="nav-number">7.3.</span> <span class="nav-text">重载、重写、重定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-number">7.4.</span> <span class="nav-text">多态的实现原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%92%8Cvptr%E6%8C%87%E9%92%88"><span class="nav-number">7.4.1.</span> <span class="nav-text">虚函数表和vptr指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%81%E6%98%8Evptr%E6%8C%87%E9%92%88%E7%9A%84%E5%AD%98%E5%9C%A8"><span class="nav-number">7.4.2.</span> <span class="nav-text">证明vptr指针的存在</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E8%83%BD%E5%90%A6%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%A4%9A%E6%80%81%EF%BC%9F"><span class="nav-number">7.4.3.</span> <span class="nav-text">构造函数中能否调用虚函数，实现多态？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%88%B6%E7%B1%BB%E6%8C%87%E9%92%88%E5%92%8C%E5%AD%90%E7%B1%BB%E6%8C%87%E9%92%88%E7%9A%84%E6%AD%A5%E9%95%BF"><span class="nav-number">7.4.4.</span> <span class="nav-text">父类指针和子类指针的步长</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9C%89%E5%85%B3%E5%A4%9A%E6%80%81%E7%9A%84%E7%90%86%E8%A7%A3"><span class="nav-number">7.5.</span> <span class="nav-text">有关多态的理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">7.6.</span> <span class="nav-text">虚函数和抽象类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="nav-number">7.6.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="nav-number">7.6.2.</span> <span class="nav-text">纯虚函数和抽象类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%9C%A8%E5%A4%9A%E7%BB%A7%E6%89%BF%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="nav-number">7.6.3.</span> <span class="nav-text">抽象类在多继承中的应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%BC%96%E7%A8%8B%E6%A1%88%E4%BE%8B"><span class="nav-number">7.7.</span> <span class="nav-text">面向抽象类编程案例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B"><span class="nav-number">7.8.</span> <span class="nav-text">C语言中的面向接口编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80"><span class="nav-number">7.8.1.</span> <span class="nav-text">函数类型语法基础</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%81%9A%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="nav-number">7.8.2.</span> <span class="nav-text">函数指针做函数参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E5%B7%A5%E7%A8%8B%E6%84%8F%E4%B9%89"><span class="nav-number">7.8.3.</span> <span class="nav-text">函数指针的工程意义</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF"><span class="nav-number">8.</span> <span class="nav-text">模板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="nav-number">8.1.</span> <span class="nav-text">函数模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="nav-number">8.1.1.</span> <span class="nav-text">函数重载实现的泛型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%BC%95%E5%85%A5"><span class="nav-number">8.1.2.</span> <span class="nav-text">函数模板的引入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="nav-number">8.1.3.</span> <span class="nav-text">函数模板的实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E4%B8%8E%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="nav-number">8.1.4.</span> <span class="nav-text">函数模板与函数重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%99%A8%E5%AF%B9%E6%A8%A1%E6%9D%BF%E6%9C%BA%E5%88%B6%E5%89%96%E6%9E%90"><span class="nav-number">8.1.5.</span> <span class="nav-text">编译器对模板机制剖析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="nav-number">8.2.</span> <span class="nav-text">类模板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E5%AE%9A%E4%B9%89"><span class="nav-number">8.2.1.</span> <span class="nav-text">类模板定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="nav-number">8.2.2.</span> <span class="nav-text">简单的模板类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%9A%84%E8%AF%9E%E7%94%9F"><span class="nav-number">8.2.3.</span> <span class="nav-text">模板类的诞生</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A8%A1%E6%9D%BF%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">8.3.</span> <span class="nav-text">模板类的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BD%93%E5%86%99%E5%9C%A8%E7%B1%BB%E4%B8%AD"><span class="nav-number">8.3.1.</span> <span class="nav-text">函数体写在类中</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BD%93%E5%86%99%E5%9C%A8%E7%B1%BB%E5%A4%96%EF%BC%88%E5%9C%A8%E4%B8%80%E4%B8%AACPP%E4%B8%AD%EF%BC%89"><span class="nav-number">8.3.2.</span> <span class="nav-text">函数体写在类外（在一个CPP中）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E4%BD%93%E5%86%99%E5%9C%A8%E7%B1%BB%E5%A4%96-%E5%9C%A8-h%E5%92%8C-cpp%E4%B8%AD"><span class="nav-number">8.3.3.</span> <span class="nav-text">函数体写在类外(在.h和.cpp中)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%AD%E7%9A%84static"><span class="nav-number">8.3.4.</span> <span class="nav-text">类模板中的static</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">9.</span> <span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%90%8D%E7%A7%B0%E5%92%8C%E8%AF%AD%E6%B3%95"><span class="nav-number">9.1.</span> <span class="nav-text">类型转换的名称和语法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E6%96%B9%E5%BC%8F"><span class="nav-number">9.2.</span> <span class="nav-text">转换方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#static-cast-%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">9.2.1.</span> <span class="nav-text">static_cast 静态类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dynamic-cast-%E5%AD%90%E7%B1%BB%E5%92%8C%E7%88%B6%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E5%A4%9A%E6%80%81"><span class="nav-number">9.2.2.</span> <span class="nav-text">dynamic_cast 子类和父类之间的多态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#const-cast-%E5%8E%BB%E6%8E%89const%E5%B1%9E%E6%80%A7%E8%BD%AC%E6%8D%A2"><span class="nav-number">9.2.3.</span> <span class="nav-text">const_cast 去掉const属性转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#reinterpret-cast-%E9%87%8D%E6%96%B0%E8%A7%A3%E9%87%8A%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-number">9.2.4.</span> <span class="nav-text">reinterpret_cast 重新解释类型转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8"><span class="nav-number">10.</span> <span class="nav-text">异常</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="nav-number">10.1.</span> <span class="nav-text">异常处理的基本思想</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BC%A0%E7%BB%9F%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-number">10.1.1.</span> <span class="nav-text">传统的错误处理机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="nav-number">10.1.2.</span> <span class="nav-text">异常的错误处理机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">10.2.</span> <span class="nav-text">C++异常处理的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="nav-number">10.2.1.</span> <span class="nav-text">异常的基本语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%88%E8%A7%A3%E6%97%8B%EF%BC%88unwinding%EF%BC%89"><span class="nav-number">10.2.2.</span> <span class="nav-text">栈解旋（unwinding）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8E"><span class="nav-number">10.2.3.</span> <span class="nav-text">异常接口声明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%82%E5%B8%B8%E5%8F%98%E9%87%8F%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">10.2.4.</span> <span class="nav-text">异常类型和异常变量的生命周期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">10.2.5.</span> <span class="nav-text">异常的层次结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E7%A8%8B%E5%BA%8F%E5%BA%93%E5%BC%82%E5%B8%B8"><span class="nav-number">10.3.</span> <span class="nav-text">标准程序库异常</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">11.</span> <span class="nav-text">输入输出流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O%E6%B5%81%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E6%B5%81%E7%B1%BB%E5%BA%93%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">11.1.</span> <span class="nav-text">I&#x2F;O流的概念和流类库的结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%87%E5%87%86I-O%E6%B5%81"><span class="nav-number">11.2.</span> <span class="nav-text">标准I&#x2F;O流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E7%9A%84%E8%BE%93%E5%85%A5%E6%B5%81"><span class="nav-number">11.2.1.</span> <span class="nav-text">标准的输入流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E5%87%86%E7%9A%84%E8%BE%93%E5%87%BA%E6%B5%81"><span class="nav-number">11.2.2.</span> <span class="nav-text">标准的输出流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F%E5%8C%96"><span class="nav-number">11.2.3.</span> <span class="nav-text">输出格式化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6I-O"><span class="nav-number">11.3.</span> <span class="nav-text">文件I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E6%B5%81%E7%B1%BB%E5%92%8C%E6%96%87%E4%BB%B6%E6%B5%81%E5%AF%B9%E8%B1%A1"><span class="nav-number">11.3.1.</span> <span class="nav-text">文件流类和文件流对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E7%9A%84%E6%89%93%E5%BC%80%E4%B8%8E%E5%85%B3%E9%97%AD"><span class="nav-number">11.3.2.</span> <span class="nav-text">文件的打开与关闭</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E5%AF%B9ASCII%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="nav-number">11.3.3.</span> <span class="nav-text">C++对ASCII文件的读写操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C-%E5%AF%B9%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C"><span class="nav-number">11.3.4.</span> <span class="nav-text">C++对二进制文件的读写操作</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="OrangeW"
      src="/images/orange.png">
  <p class="site-author-name" itemprop="name">OrangeW</p>
  <div class="site-description" itemprop="description">demo_study record</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


<!-- CloudCalendar -->
<div class="widget-wrap" style="width: 90%;margin-left: auto;margin-right: auto; opacity: 0.97;">
	<div class="widget" id="CloudCalendar"></div>
</div>
      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OrangeW</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">837k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">25:22</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
<!-- calendar widget -->

    <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-calendar/calendar.min.js"></script>
    <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-calendar/languages.min.js"></script>
    <script>
    $(function() {
        $('#CloudCalendar').aCalendar('zh-CN',
            $.extend(
                '', {
                    single:true,
                    root:'/calendar/'
                }
            )
        );
    });
    </script>


</body>
</html>
