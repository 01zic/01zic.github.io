<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/orange.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/orange.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/orange.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"01zic.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="第一章 STL理论基础">
<meta property="og:type" content="article">
<meta property="og:title" content="C++STL">
<meta property="og:url" content="https://01zic.github.io/2022/07/06/C-STL/index.html">
<meta property="og:site_name" content="orangeWBlog">
<meta property="og:description" content="第一章 STL理论基础">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsDDAB.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsDDAC.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsDDBC.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsDDCD.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsDDCE.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsDDCF.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsDDE0.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsDDF0.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsDDF1.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsDDF2.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsDE03.tmp.png">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsDE04.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsDE05.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsDE15.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsDE16.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsDE17.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsDE28.tmp.jpg">
<meta property="og:image" content="http://qiniu.orangew.cn/img/wpsDE39.tmp.jpg">
<meta property="article:published_time" content="2022-07-06T14:41:53.000Z">
<meta property="article:modified_time" content="2022-07-07T09:15:47.221Z">
<meta property="article:author" content="OrangeW">
<meta property="article:tag" content="c++">
<meta property="article:tag" content="STL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://qiniu.orangew.cn/img/wpsDDAB.tmp.jpg">

<link rel="canonical" href="https://01zic.github.io/2022/07/06/C-STL/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++STL | orangeWBlog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">orangeWBlog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://01zic.github.io/2022/07/06/C-STL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/orange.png">
      <meta itemprop="name" content="OrangeW">
      <meta itemprop="description" content="demo_study record">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="orangeWBlog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++STL
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-06 22:41:53" itemprop="dateCreated datePublished" datetime="2022-07-06T22:41:53+08:00">2022-07-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-07 17:15:47" itemprop="dateModified" datetime="2022-07-07T17:15:47+08:00">2022-07-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index"><span itemprop="name">c++</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>56k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:41</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="第一章-STL理论基础"><a href="#第一章-STL理论基础" class="headerlink" title="第一章 STL理论基础"></a><strong>第一章 STL理论基础</strong></h2><h3 id="1-1本章学习重点"><a href="#1-1本章学习重点" class="headerlink" title="1.1本章学习重点"></a><strong>1.1本章学习重点</strong></h3><ul>
<li>STL基本概念</li>
<li>理解容器的概念</li>
<li>理解迭代器的概念</li>
<li>理解算法的概念</li>
</ul>
<h3 id="1-2-STL基本概念"><a href="#1-2-STL基本概念" class="headerlink" title="1.2 STL基本概念"></a><strong>1.2 STL基本概念</strong></h3><ul>
<li><p>STL(Standard Template Library,标准模板库)，是惠普实验室开发的一系列软件的统称。现在主要出现在c++中，但是在引入c++之前该技术已经存在很长时间了。</p>
</li>
<li><p>STL从广义上分为: 容器(container) 算法(algorithm) 迭代器(iterator),容器和算法之间通过迭代器进行无缝连接。STL几乎所有的代码都采用了模板类或者模板函数，这相比传统的由函数和类组成的库来说提供了更好的代码重用机会。</p>
</li>
<li><p>STL(Standard Template Library)标准模板库,在我们c++标准程序库中隶属于STL的占到了80%以上。</p>
</li>
</ul>
<p>在c++标准中，STL被组织成以下13个头文件：</p>
<ul>
<li><p><algorithm>、<deque>、<functional>、<iterator>、<vector>、<list>、<map>、<memory>、<numeric>、<queue>、<set>、<stack> 和<utility></p>
</li>
<li><p>那么说了这么多，STL还有什么优点呢？</p>
</li>
<li><p>STL是C++的一部分，因此不用额外安装什么，它被内建在你的编译器之内。</p>
</li>
<li><p>STL的一个重要特点是数据结构和算法的分离。尽管这是个简单的概念，但是这种分离确实使得STL变得非常通用。例如:在STL的vector容器中，可以放入元素、基础数据类型变量、元素的地址；STL的sort() 排序函数可以用来操作vector,list等容器。</p>
</li>
<li><p>程序员可以不用思考STL具体的实现过程，只要能够熟练使用STL就OK了。这样他们就可以把精力放在程序开发的别的方面。</p>
</li>
<li><p>STL具有高可重用性，高性能，高移植性，跨平台的优点。</p>
<ul>
<li>高可重用性：STL中几乎所有的代码都采用了模板类和模版函数的方式实现，这相比于传统的由函数和类组成的库来说提供了更好的代码重用机会。关于模板的知识，已经给大家介绍了。</li>
<li>高性能：如map可以高效地从十万条记录里面查找出指定的记录，因为map是采用红黑树的变体实现的。(红黑树是平横二叉树的一种)</li>
<li>高移植性：如在项目A上用STL编写的模块，可以直接移植到项目B上。</li>
<li>跨平台：如用windows的Visual Studio编写的代码可以在Mac OS的XCode上直接编译。</li>
</ul>
</li>
</ul>
<h3 id="1-3-STL三大组件介绍"><a href="#1-3-STL三大组件介绍" class="headerlink" title="1.3 STL三大组件介绍"></a><strong>1.3 STL三大组件介绍</strong></h3><h4 id="1-3-1容器概念介绍"><a href="#1-3-1容器概念介绍" class="headerlink" title="1.3.1容器概念介绍"></a><strong>1.3.1容器概念介绍</strong></h4><ul>
<li>STL中容器是指存储有限数据元素的一种数据结构。比如栈(stack)，队列(queue)…那么什么是数据结构，我们研究把数据按照特定的方式排列起来，便于我们查找 删除 排序或者其他一些目的，这种不同的排列方式我们就可以叫数据结构。</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wpsDDAB.tmp.jpg" alt="img"> </p>
<ul>
<li><p>教室中包含了很多学生，教室就是一个容器，学生就是容器中存储的一个元素，教学楼包含了很多教室，教学楼就是一个容器，教室就是容器中的一个元素。</p>
</li>
<li><p>这里面还包含了一层含义：容器可以包含容器(教学楼和教室都是容器，但是教学楼里可以放教室)</p>
</li>
<li><p>比如拿教室这个容器来举例：我们怎么能快速定位教室中某个人的位置，是不是需要我们教室中的所有人按照一定的规则排序，这样我就能快速定位一个学生的坐在那里，那么依据我们的需求，让学生按照不同的规则排列，这种不同的排列就叫做数据结构。</p>
</li>
<li><p>在我们STL中容器分为：序列式容器和关联式容器。</p>
<ul>
<li>序列式容器就是根据学生进入教室的时间和地点来决定学生在那个位置，跟学生是谁没关系。</li>
<li>关联式容器是指我教室的座位按照一定规则确定好了，每个学生进来，比如根据学生出生年月，从小到大排列，学生坐在那个位置，必须由我的规则来规定。</li>
</ul>
</li>
</ul>
<h4 id="1-3-2迭代器介绍"><a href="#1-3-2迭代器介绍" class="headerlink" title="1.3.2迭代器介绍"></a><strong>1.3.2迭代器介绍</strong></h4><ul>
<li><p>迭代器是一种抽象出来的概念，现实中不容易找出来某项事物与之对应，所以较难理解。</p>
</li>
<li><p>但是在我们程序中，比如我们写的数据，我们通过[]操作符遍历取值，那么[]就是一个迭代器，也必须说我们经常用的指针，他也是一种迭代器。</p>
</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wpsDDAC.tmp.jpg" alt="img"> </p>
<ul>
<li>迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。迭代器修改了常规指针的接口，所谓迭代器是一种概念上的抽象：那些行为上像迭代器的东西都可以叫做迭代器，也就是说迭代器就是对我们普通的指针做了一层封装，其行为也类似指针。我们现在呢？可以单纯得把迭代器理解为，它就是一个指针，用来指向不同的元素,既然是指针，那么指针的一些基本运算操作，比如*、++、==、!=、=,迭代器也可以进行这样的操作。</li>
</ul>
<h4 id="1-3-3算法介绍"><a href="#1-3-3算法介绍" class="headerlink" title="1.3.3算法介绍"></a><strong>1.3.3算法介绍</strong></h4><ul>
<li><p>以有限的步骤，解决逻辑或者数学上的问题，这门学科我们就叫做算法。一般来说，我们每天都在写各种各样的算法，比如我们写的每一个函数，它被用来解决或大或小的问题。</p>
</li>
<li><p>在我们工作中，我们要写一个算法来解决一个问题的时候，那么需要考虑你写的算法需要消耗的计算机资源，包括时间和空间，如果你写一个算法需要消耗1G内存来解决这个问题，那么你这个算法也就没有什么价值了。</p>
</li>
<li><p>STL为我们的提供的算法，都很高效，而且还有个最大的特点，可复用性。那么我们学习算法，就很简单了，我们只需要去熟悉并且能熟练应用STL为我们提供的常用算法就OK了。</p>
</li>
<li><p>STL提供了大约100个实现算法的模版函数，比如算法for_each将为指定序列中的每一个元素调用指定的函数等。这样一来，只要我们熟悉了STL之后，许多代码可以被大大的化简，只需要通过调用一两个算法函数，就可以完成所需要的功能并大大地提升效率</p>
</li>
</ul>
<h4 id="1-3-4案例"><a href="#1-3-4案例" class="headerlink" title="1.3.4案例"></a><strong>1.3.4案例</strong></h4><h5 id="1-3-4-1-案例一-STL入门hello-world"><a href="#1-3-4-1-案例一-STL入门hello-world" class="headerlink" title="1.3.4.1 案例一: STL入门hello world"></a><strong>1.3.4.1 案例一: STL入门hello world</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS

#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;

using namespace std;


&#x2F;&#x2F;STL中的容器 算法 迭代器
void test01()&#123;
	
	vector&lt;int&gt; v;  &#x2F;&#x2F;STL中的标准容器之一 ：动态数组
	v.push_back(1); &#x2F;&#x2F;vector容器提供的插入数据的方法
	v.push_back(5);
	v.push_back(3);
	v.push_back(7);


	&#x2F;&#x2F;迭代器
	vector&lt;int&gt;::iterator pStart &#x3D; v.begin(); &#x2F;&#x2F;vector容器提供了begin()方法 返回指向第一个元素的迭代器
	vector&lt;int&gt;::iterator pEnd &#x3D; v.end(); &#x2F;&#x2F;vector容器提供了end()方法 返回指向最后一个元素下一个位置的迭代器

	&#x2F;&#x2F;通过迭代器遍历
	while (pStart !&#x3D; pEnd)&#123;
		cout &lt;&lt; *pStart &lt;&lt; &quot; &quot;;
		pStart++;
	&#125;
	cout &lt;&lt; endl;

	&#x2F;&#x2F;算法 count算法 用于统计元素的个数
	int n &#x3D; count(pStart, pEnd, 5);
	cout &lt;&lt; &quot;n:&quot; &lt;&lt; n &lt;&lt; endl;

&#125;

&#x2F;&#x2F;STL容器不单单可以存储基础数据类型，也可以存储类对象
class  Teacher
&#123;
public:
	Teacher(int age) :age(age)&#123;&#125;;
	~Teacher()&#123;&#125;;
public:
	int age;
&#125;;

void test02()&#123;

	vector&lt;Teacher&gt; v; &#x2F;&#x2F;存储Teacher类型数据的容器
	Teacher t1(10), t2(20), t3(30);
	v.push_back(t1);
	v.push_back(t2);
	v.push_back(t3);

	vector&lt;Teacher&gt;::iterator pStart &#x3D; v.begin();
	vector&lt;Teacher&gt;::iterator pEnd &#x3D; v.end();

	&#x2F;&#x2F;通过迭代器遍历
	while (pStart !&#x3D; pEnd)&#123;
		cout &lt;&lt; pStart-&gt;age &lt;&lt; &quot; &quot;;
		pStart++;
	&#125;
	cout &lt;&lt; endl;

&#125;

&#x2F;&#x2F;存储Teacher类型指针
void test03()&#123;
	
	vector&lt;Teacher*&gt; v; &#x2F;&#x2F;存储Teacher类型指针
	Teacher* t1 &#x3D; new Teacher(10);
	Teacher* t2 &#x3D; new Teacher(20);
	Teacher* t3 &#x3D; new Teacher(30);

	v.push_back(t1);
	v.push_back(t2);
	v.push_back(t3);

	&#x2F;&#x2F;拿到容器迭代器
	vector&lt;Teacher*&gt;::iterator pStart &#x3D; v.begin();
	vector&lt;Teacher*&gt;::iterator pEnd &#x3D; v.end();

	&#x2F;&#x2F;通过迭代器遍历
	while (pStart !&#x3D; pEnd)&#123;
		cout &lt;&lt; (*pStart)-&gt;age &lt;&lt; &quot; &quot;;
		pStart++;
	&#125;
	cout &lt;&lt; endl;

&#125;
 
&#x2F;&#x2F;容器嵌套容器  难点(不理解，可以跳过)
void test04()&#123;
	
	vector&lt;vector&lt;int&gt;&gt; v; &#x2F;&#x2F;容器中存储容器
	vector&lt;int&gt; v1,v2,v3;
	v1.push_back(1);
	v1.push_back(2);

	v2.push_back(10);

	v3.push_back(100);
	v3.push_back(200);

	v.push_back(v1);
	v.push_back(v2);
	v.push_back(v3);

	&#x2F;&#x2F;拿到容器迭代器
	vector&lt;vector&lt;int&gt;&gt;::iterator pStart &#x3D; v.begin();
	vector&lt;vector&lt;int&gt;&gt;::iterator pEnd &#x3D; v.end();

	&#x2F;&#x2F;通过迭代器遍历
	while (pStart !&#x3D; pEnd)&#123;
		vector&lt;int&gt; vTemp &#x3D; *pStart; &#x2F;&#x2F;获得迭代器当前指向的容器

		vector&lt;int&gt;::iterator tmpStart &#x3D; vTemp.begin();
		vector&lt;int&gt;::iterator tmpEnd &#x3D; vTemp.end();
		for (; tmpStart !&#x3D; tmpEnd;tmpStart++)&#123;
			cout &lt;&lt; *tmpStart &lt;&lt; &quot; &quot;;
		&#125;
		cout &lt;&lt; endl;
		pStart++; 
	&#125;
&#125;

int main()&#123;

	&#x2F;&#x2F;test01();
	&#x2F;&#x2F;test02();
	&#x2F;&#x2F;test03();
	test04();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="13-4-2-案例二-容器算法迭代器实现基本原理"><a href="#13-4-2-案例二-容器算法迭代器实现基本原理" class="headerlink" title="13.4.2 案例二: 容器算法迭代器实现基本原理"></a><strong>13.4.2 案例二: 容器算法迭代器实现基本原理</strong></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS

#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
&#x2F;&#x2F;算法
int mycount(int* start, int* end, int val)&#123;
	int n &#x3D; 0;
	for (int* it &#x3D; start; it !&#x3D; end;it++)&#123;
		if (*it &#x3D;&#x3D; val)&#123;
			n++;
		&#125;	
	&#125;
	return n;
&#125;
int main()&#123;

	&#x2F;&#x2F;容器&#x3D;&gt;数组
	int arr[] &#x3D; &#123; 1, 2, 3, 5,4, 5, 6 &#125;;
	&#x2F;&#x2F;迭代器 [] int*p []也是一种迭代器
	int* pStart &#x3D; arr;  &#x2F;&#x2F;开始迭代器
	int* pEnd &#x3D; &amp;(arr[sizeof(arr) &#x2F; sizeof(int)]);  &#x2F;&#x2F;结束迭代器
	&#x2F;&#x2F;p++;
	&#x2F;&#x2F;cout &lt;&lt; *p &lt;&lt; endl;
	&#x2F;&#x2F;p++;
	&#x2F;&#x2F;cout &lt;&lt; *p &lt;&lt; endl;
	&#x2F;&#x2F;遍历容器
	while (pStart !&#x3D; pEnd)&#123;
		cout &lt;&lt; *pStart &lt;&lt; endl;
		pStart++;
	&#125;

	int n &#x3D; mycount(pStart, pEnd, 5); &#x2F;&#x2F;算法 通过迭代器对容器中的元素进行统计
	cout &lt;&lt; &quot;n:&quot; &lt;&lt; n &lt;&lt; endl;

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="1-3-5总结"><a href="#1-3-5总结" class="headerlink" title="1.3.5总结"></a><strong>1.3.5总结</strong></h4><ul>
<li>容器就是数据结构，用来将数据元素按照一定的规则进行排列，不同的容器拥有不同的排列规则，不同的排列规则可以达到不同的数据操作特点，比如数据这种数据结构，我们随机存取就很高效，算法就是提供对容器数据元素的一些操作，比如遍历容器元素，删除容器元素等迭代器就是容器和算法之间的桥梁，粘合剂，用来将两个相对独立的部件建立起关系。</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wpsDDBC.tmp.jpg" alt="img"> </p>
<ul>
<li><p>STL中容器和算法的设计是彼此分离，这样的好处就是：</p>
<ul>
<li><p>容器和算法的编写可以分别编写，互补影响</p>
</li>
<li><p>容器只需要提供迭代器 算法只需要拿到迭代器就可以完成容器和算法之间的关联和操作</p>
</li>
</ul>
</li>
</ul>
<h2 id="第二章-常用容器"><a href="#第二章-常用容器" class="headerlink" title="第二章 常用容器"></a><strong>第二章 常用容器</strong></h2><h3 id="2-1本章学习重点"><a href="#2-1本章学习重点" class="headerlink" title="2.1本章学习重点"></a><strong>2.1本章学习重点</strong></h3><ul>
<li>掌握string容器特性,及其相关API的使用</li>
<li>掌握vector容器特性,及其相关API的使用</li>
<li>掌握deque容器特性,及其相关API的使用</li>
<li>掌握queue容器特性,及其相关API的使用</li>
<li>掌握stack容器特性,及其相关API的使用</li>
<li>掌握list容器特性,及其相关API的使用</li>
<li>掌握set/multiset容器特性,及其相关API的使用</li>
<li>掌握map/multiset容器特性,及其相关API的使用</li>
<li>掌握函数对象的概念</li>
<li>理解STL容器元素的深拷贝和浅拷贝问题</li>
</ul>
<h3 id="2-2-string容器"><a href="#2-2-string容器" class="headerlink" title="2.2 string容器"></a><strong>2.2 string容器</strong></h3><h4 id="2-2-1-string的特性"><a href="#2-2-1-string的特性" class="headerlink" title="2.2.1 string的特性"></a><strong>2.2.1 string的特性</strong></h4><ul>
<li><p>说到string的特性，就不得不和char*类型的字符串的对比：</p>
</li>
<li><p>Char*是一个指针，String是一个类</p>
</li>
<li><p>string封装了char * ，管理这个字符串，是一个char*型的容器。</p>
</li>
<li><p>String封装了很多实用的成员方法</p>
</li>
<li><p>查找find，拷贝copy，删除delete 替换replace，插入insert</p>
</li>
<li><p>不用考虑内存释放和越界</p>
</li>
<li><p>string管理char * 所分配的内存。每一次string的复制，取值都由string类负责维护，不用担心复制越界和取值越界等。</p>
</li>
<li><p>string和char*可以互相转换吗？如果能，怎么转换呢？</p>
</li>
<li><p>答案是可以转换。string转char*通过string提供的c_str()方法。</p>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;string 转 char*
string str &#x3D; &quot;itcast&quot;;
const char* cstr &#x3D; str.c_str();
&#x2F;&#x2F;char* 转 string 
char* s &#x3D; &quot;itcast&quot;;
string sstr(s);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="2-2-2-string-常用API"><a href="#2-2-2-string-常用API" class="headerlink" title="2.2.2 string 常用API"></a><strong>2.2.2 string 常用API</strong></h4><h5 id="2-2-2-1-string构造函数"><a href="#2-2-2-1-string构造函数" class="headerlink" title="2.2.2.1 string构造函数"></a><strong>2.2.2.1 string构造函数</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string();&#x2F;&#x2F;创建一个空的字符串 例如: string str;      
string(const string&amp; str);&#x2F;&#x2F;使用一个string对象初始化另一个string对象
string(const char* s);&#x2F;&#x2F;使用字符串s初始化
string(int n, char c);&#x2F;&#x2F;使用n个字符c初始化 
&#x2F;&#x2F;例子:
&#x2F;&#x2F;默认构造函数
string s1;
&#x2F;&#x2F;拷贝构造函数
string s2(s1);
string s2 &#x3D; s1;
&#x2F;&#x2F;带参数构造函数
char* str &#x3D; &quot;itcast&quot;;
string s3(str);
string s4(10, &#39;a&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="2-2-2-2-string基本赋值操作"><a href="#2-2-2-2-string基本赋值操作" class="headerlink" title="2.2.2.2 string基本赋值操作"></a><strong>2.2.2.2 string基本赋值操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string&amp; operator&#x3D;(const char* s);&#x2F;&#x2F;char*类型字符串 赋值给当前的字符串
string&amp; operator&#x3D;(const string &amp;s);&#x2F;&#x2F;把字符串s赋给当前的字符串
string&amp; operator&#x3D;(char c);&#x2F;&#x2F;字符赋值给当前的字符串
string&amp; assign(const char *s);&#x2F;&#x2F;把字符串s赋给当前的字符串
string&amp; assign(const char *s, int n);&#x2F;&#x2F;把字符串s的前n个字符赋给当前的字符串
string&amp; assign(const string &amp;s);&#x2F;&#x2F;把字符串s赋给当前字符串
string&amp; assign(int n, char c);&#x2F;&#x2F;用n个字符c赋给当前字符串
string&amp; assign(const string &amp;s, int start, int n);&#x2F;&#x2F;将s从start开始n个字符赋值给字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="2-2-2-3-string存取字符操作"><a href="#2-2-2-3-string存取字符操作" class="headerlink" title="2.2.2.3 string存取字符操作"></a><strong>2.2.2.3 string存取字符操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char&amp; operator[](int n);&#x2F;&#x2F;通过[]方式取字符
char&amp; at(int n);&#x2F;&#x2F;通过at方法获取字符
&#x2F;&#x2F;例子:
string s &#x3D; &quot;itcast&quot;;
char c &#x3D; s[1];
c &#x3D; s.at(1);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p><strong>问：</strong>string中存取字符[]和at的异同?</p>
<p><strong>答: 1 相同,[]和at都可以返回第n个字符</strong></p>
<p><strong>2 不同，at访问越界会抛出异常，[]越界会直接程序会挂掉。</strong></p>
</blockquote>
<h5 id="2-2-2-4-string拼接操作"><a href="#2-2-2-4-string拼接操作" class="headerlink" title="2.2.2.4 string拼接操作"></a><strong>2.2.2.4 string拼接操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string&amp; operator+&#x3D;(const string&amp; str);&#x2F;&#x2F;重载+&#x3D;操作符
string&amp; operator+&#x3D;(const char* str);&#x2F;&#x2F;重载+&#x3D;操作符
string&amp; operator+&#x3D;(const char c);&#x2F;&#x2F;重载+&#x3D;操作符
string&amp; append(const char *s);&#x2F;&#x2F;把字符串s连接到当前字符串结尾
string&amp; append(const char *s, int n);&#x2F;&#x2F;把字符串s的前n个字符连接到当前字符串结尾
string&amp; append(const string &amp;s);&#x2F;&#x2F;同operator+&#x3D;()
string&amp; append(const string &amp;s, int pos, int n);&#x2F;&#x2F;把字符串s中从pos开始的n个字符连接到当前字符串结尾
	string&amp; append(int n, char c);&#x2F;&#x2F;在当前字符串结尾添加n个字符c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="2-2-2-5-string查找和替换"><a href="#2-2-2-5-string查找和替换" class="headerlink" title="2.2.2.5 string查找和替换"></a><strong>2.2.2.5 string查找和替换</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int find(const string&amp; str, int pos &#x3D; 0) const; &#x2F;&#x2F;查找str第一次出现位置,从pos开始查找
int find(const char* s, int pos &#x3D; 0) const;  &#x2F;&#x2F;查找s第一次出现位置,从pos开始查找
int find(const char* s, int pos, int n) const;  &#x2F;&#x2F;从pos位置查找s的前n个字符第一次位置
int find(const char c, int pos &#x3D; 0) const;  &#x2F;&#x2F;查找字符c第一次出现位置
int rfind(const string&amp; str, int pos &#x3D; npos) const;&#x2F;&#x2F;查找str最后一次位置,从pos开始查找
int rfind(const char* s, int pos &#x3D; npos) const;&#x2F;&#x2F;查找s最后一次出现位置,从pos开始查找
int rfind(const char* s, int pos, int n) const;&#x2F;&#x2F;从pos查找s的前n个字符最后一次位置
int rfind(const char c, int pos &#x3D; 0) const; &#x2F;&#x2F;查找字符c最后一次出现位置
string&amp; replace(int pos, int n, const string&amp; str); &#x2F;&#x2F;替换从pos开始n个字符为字符串str
string&amp; replace(int pos, int n, const char* s); &#x2F;&#x2F;替换从pos开始的n个字符为字符串s<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="2-2-2-6-string比较操作"><a href="#2-2-2-6-string比较操作" class="headerlink" title="2.2.2.6 string比较操作"></a><strong>2.2.2.6 string比较操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*
compare函数在&gt;时返回 1，&lt;时返回 -1，&#x3D;&#x3D;时返回 0。
比较区分大小写，比较时参考字典顺序，排越前面的越小。
大写的A比小写的a小。
*&#x2F;
int compare(const string &amp;s) const;&#x2F;&#x2F;与字符串s比较
int compare(const char *s) const;&#x2F;&#x2F;与字符串s比较<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="2-2-2-7-string子串"><a href="#2-2-2-7-string子串" class="headerlink" title="2.2.2.7 string子串"></a><strong>2.2.2.7 string子串</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string substr(int pos &#x3D; 0, int n &#x3D; npos) const;&#x2F;&#x2F;返回由pos开始的n个字符组成的字符串<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h5 id="2-2-2-8-string插入和删除操作"><a href="#2-2-2-8-string插入和删除操作" class="headerlink" title="2.2.2.8 string插入和删除操作"></a><strong>2.2.2.8 string插入和删除操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string&amp; insert(int pos, const char* s); &#x2F;&#x2F;插入字符串
string&amp; insert(int pos, const string&amp; str); &#x2F;&#x2F;插入字符串
string&amp; insert(int pos, int n, char c);&#x2F;&#x2F;在指定位置插入n个字符c
string&amp; erase(int pos, int n &#x3D; npos);&#x2F;&#x2F;删除从Pos开始的n个字符 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="2-2-3-string课后练习"><a href="#2-2-3-string课后练习" class="headerlink" title="2.2.3 string课后练习"></a><strong>2.2.3 string课后练习</strong></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;用户邮箱地址验证
&#x2F;&#x2F; 1 判断邮箱有效性 是否包含@和. 并且.在@之后
&#x2F;&#x2F; 2 判断用户输入的用户名中是否包含除了小写字母之外字符(ASCII范围97~122)
&#x2F;&#x2F; 3 判断用户输入的邮箱地址是否正确(zhaosi@itcast.cn)

#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;

&#x2F;&#x2F; 1 判断邮箱有效性 是否包含@和.并且.在@之后
bool Check_Valid(string&amp; email)&#123;

	int pos1 &#x3D; email.find(&quot;@&quot;);
	int pos2 &#x3D; email.find(&quot;.&quot;);

	&#x2F;&#x2F;判断@和.是否存在
	if (pos1  &#x3D;&#x3D; -1 || pos2 &#x3D;&#x3D; -1)&#123;
		return false;
	&#125;
	&#x2F;&#x2F;判断@在.之前
	if (pos1 &gt; pos2)&#123;
		return false;
	&#125;

	return true;
&#125;

&#x2F;&#x2F;2 判断用户输入的用户名中是否包含除了小写字母之外字符(ASCII范围97~122)
bool Check_Username(string&amp; email)&#123;
	
	int pos &#x3D; email.find(&quot;@&quot;);
	string username &#x3D; email.substr(0,pos-1);
	for (string::iterator it &#x3D; username.begin(); it !&#x3D; username.end(); it++)&#123;
		if (*it &lt; 97 || *it &gt; 122)&#123;
			return false;
		&#125;
	&#125;

	return true;

&#125;

&#x2F;&#x2F; 3 判断用户输入的邮箱地址是否正确(zhaosi@itcast.cn)
bool Check_EqualtTo(string&amp; email)&#123;
	
	string rightEmail &#x3D; &quot;zhaosi@itcast.cn&quot;;
	if (email.compare(rightEmail) !&#x3D; 0)&#123;
		return false;
	&#125;
	return true;
&#125;

void testEmail()&#123;

	&#x2F;&#x2F;用户邮箱地址验证
	&#x2F;&#x2F; 1 判断邮箱有效性 是否包含@和. 并且.在@之后
	&#x2F;&#x2F; 2 判断用户输入的用户名中是否包含除了小写字母之外字符(ASCII范围97~122)
	&#x2F;&#x2F; 3 判断用户输入的邮箱地址是否正确(zhaosi@itcast.cn)

	string email;
	cout &lt;&lt; &quot;请输入您的邮箱：&quot; &lt;&lt; endl;
	cin &gt;&gt; email;

	bool flag &#x3D; Check_Valid(email);
	if (!flag)&#123;
		cout &lt;&lt; &quot;emain格式不合法!&quot; &lt;&lt; endl;
		return;
	&#125;

	flag &#x3D; Check_Username(email);
	if (!flag)&#123;
		cout &lt;&lt; &quot;用户名中包含除小写字母之外的字母!&quot; &lt;&lt; endl;
		return;
	&#125;

	flag &#x3D; Check_EqualtTo(email);
	if (!flag)&#123;
		cout &lt;&lt; &quot;邮箱地址不正确!&quot; &lt;&lt; endl;
		return;
	&#125;

	cout &lt;&lt; &quot;邮箱输入正确!&quot; &lt;&lt; endl;
&#125;

int main()&#123;

	testEmail();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-3-vector容器"><a href="#2-3-vector容器" class="headerlink" title="2.3 vector容器"></a><strong>2.3 vector容器</strong></h3><h4 id="2-3-1-vector特性"><a href="#2-3-1-vector特性" class="headerlink" title="2.3.1 vector特性"></a><strong>2.3.1 vector特性</strong></h4><ul>
<li>vector容器是一个长度动态改变的动态数组，既然也是数组，那么其内存是一段连续的内存，具有数组的随机存取的优点。</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wpsDDCD.tmp.jpg" alt="img"> </p>
<ul>
<li><p><strong>特性总结:</strong></p>
</li>
<li><p><strong>vector是动态数组，连续内存空间，具有随机存取效率高的优点。</strong></p>
</li>
<li><p><strong>vector是单口容器，在队尾插入和删除元素效率高，在指定位置插入会导致数据元素移动，效率低。</strong></p>
</li>
</ul>
<blockquote>
<p><strong>问：</strong>vector如何实现动态增长?</p>
<p><strong>答: 当vector空间满的时候，再当插入新元素的时候，vector会重新申请一块更大的内存空间，将原空间数据拷贝到新的内存空间，然后释放旧的内存空间，再将新元素插入到新空间中，以此可以看出vector的空间动态增长效率较低。</strong></p>
</blockquote>
<h4 id="2-3-2-vector常用API"><a href="#2-3-2-vector常用API" class="headerlink" title="2.3.2 vector常用API"></a><strong>2.3.2 vector常用API</strong></h4><h5 id="2-3-2-1-vector构造函数"><a href="#2-3-2-1-vector构造函数" class="headerlink" title="2.3.2.1 vector构造函数"></a><strong>2.3.2.1 vector构造函数</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;T&gt; v; &#x2F;&#x2F;采用模板实现类实现，默认构造函数
vector(v.begin(), v.end());&#x2F;&#x2F;将v[begin(), end())区间中的元素拷贝给本身。
vector(n, elem);&#x2F;&#x2F;构造函数将n个elem拷贝给本身。
vector(const vector &amp;vec);&#x2F;&#x2F;拷贝构造函数。

&#x2F;&#x2F;例子 使用第二个构造函数 我们可以...
int arr[] &#x3D; &#123;2,3,4,1,9&#125;;
vector&lt;int&gt; v1(arr, arr + sizeof(arr) &#x2F; sizeof(int)); <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="2-3-2-2-vector常用赋值操作"><a href="#2-3-2-2-vector常用赋值操作" class="headerlink" title="2.3.2.2 vector常用赋值操作"></a><strong>2.3.2.2 vector常用赋值操作</strong></h5><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">assign(beg, end);&#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。
assign(n, elem);&#x2F;&#x2F;将n个elem拷贝赋值给本身。
vector&amp; operator&#x3D;(const vector  &amp;vec);&#x2F;&#x2F;重载等号操作符
swap(vec);&#x2F;&#x2F; 将vec与本身的元素互换。

&#x2F;&#x2F;第一个赋值函数，可以这么写：
int arr[] &#x3D; &#123; 0, 1, 2, 3, 4 &#125;;
assign(arr, arr + 5);&#x2F;&#x2F;使用数组初始化vector<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="2-3-2-3-vector大小操作"><a href="#2-3-2-3-vector大小操作" class="headerlink" title="2.3.2.3 vector大小操作"></a><strong>2.3.2.3 vector大小操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">size();&#x2F;&#x2F;返回容器中元素的个数
empty();&#x2F;&#x2F;判断容器是否为空
resize(int num);&#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。
resize(int num, elem);&#x2F;&#x2F;重新指定容器的长度为num，若容器变长，则以elem值填充新位置。如果容器变短，则末尾超出容器长&gt;度的元素被删除。
capacity();&#x2F;&#x2F;容器的容量
reserve(int len);&#x2F;&#x2F;容器预留len个元素长度，预留位置不初始化，元素不可访问。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>注意: resize 若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。</li>
</ul>
<blockquote>
<p><strong>问：reserve和resize的区别?</strong></p>
<p><strong>答: reserve是容器预留空间，但在空间内不真正创建元素对象，所以在没有添加新的对象之前，不能引用容器内的元素.</strong></p>
<p><strong>resize是改变容器的大小，且在创建对象，因此，调用这个函数之后，就可以引用容器内的对象了.</strong></p>
<p><strong>巧用reserve增加程序效率？</strong></p>
</blockquote>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; v;
int* p &#x3D; NULL;
int count &#x3D; 0;&#x2F;&#x2F; 统计vector容量增长几次？
for (int i &#x3D; 0; i &lt; 100000;i++)&#123;
	v.push_back(i);
	if (p !&#x3D; &amp;v[0])&#123;
		p &#x3D; &amp;v[0];
		count++;
	&#125;
&#125;
cout &lt;&lt; &quot;count:&quot; &lt;&lt; count &lt;&lt; endl; &#x2F;&#x2F;打印出30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>我向vector插入了10万个元素，vector一共重新分配内存30次.</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;int&gt; v;
v.reserve(100000);
int* p &#x3D; NULL;
int count &#x3D; 0;&#x2F;&#x2F; 统计vector容量增长几次？
for (int i &#x3D; 0; i &lt; 100000;i++)&#123;
	v.push_back(i);
	if (p !&#x3D; &amp;v[0])&#123;
		p &#x3D; &amp;v[0];
		count++;
	&#125;
&#125;
cout &lt;&lt; &quot;count:&quot; &lt;&lt; count &lt;&lt; endl; &#x2F;&#x2F;打印出30<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>再次向vector插入了10万个元素，vector一共重新分配内存1次.</p>
</li>
<li><p>当我们知道我们存储的元素大概有多少的时候,我们就可以使用reserve方法，来减少vector重新申请内存-拷贝数据-释放旧空间的次数。</p>
</li>
</ul>
<h5 id="2-3-2-4-vector数据存取操作"><a href="#2-3-2-4-vector数据存取操作" class="headerlink" title="2.3.2.4 vector数据存取操作"></a><strong>2.3.2.4 vector数据存取操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">at(int idx); &#x2F;&#x2F;返回索引idx所指的数据，如果idx越界，抛出out_of_range异常。
operator[];&#x2F;&#x2F;返回索引idx所指的数据，越界时，运行直接报错
front();&#x2F;&#x2F;返回容器中第一个数据元素
back();&#x2F;&#x2F;返回容器中最后一个数据元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="2-3-2-5-vector插入和删除操作"><a href="#2-3-2-5-vector插入和删除操作" class="headerlink" title="2.3.2.5 vector插入和删除操作"></a><strong>2.3.2.5 vector插入和删除操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">insert(const_iterator pos, int count,ele);&#x2F;&#x2F;迭代器指向位置pos插入count个元素ele.
push_back(ele); &#x2F;&#x2F;尾部插入元素ele
pop_back();&#x2F;&#x2F;删除最后一个元素
erase(const_iterator start, const_iterator end);&#x2F;&#x2F;删除迭代器从start到end之间的元素
erase(const_iterator pos);&#x2F;&#x2F;删除迭代器指向的元素
clear();&#x2F;&#x2F;删除容器中所有元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>总结: vector是个动态数组，当空间不足的时候插入新元素，vector会重新申请一块更大的内存空间，将旧空间数据拷贝到新空间，然后释放旧空间。vector是单口容器，所以在尾端插入和删除元素效率较高，在指定位置插入，势必会引起数据元素移动，效率较低。</li>
</ul>
<h3 id="2-3-deque容器"><a href="#2-3-deque容器" class="headerlink" title="2.3 deque容器"></a><strong>2.3 deque容器</strong></h3><h4 id="2-3-1-deque特性"><a href="#2-3-1-deque特性" class="headerlink" title="2.3.1 deque特性"></a><strong>2.3.1 deque特性</strong></h4><ul>
<li><p>deque是“double-ended queue”的缩写,和vector一样，deque也支持随机存取。vector是单向开口的连续性空间，deque则是一种双向开口的连续性空间，所谓双向开口，意思是可以在头尾两端分别做元素的插入和删除操作，vector当然也可以在头尾两端进行插入和删除操作，但是头部插入和删除操作效率奇差，无法被接受。</p>
</li>
<li><p>deque和vector的最大差异？</p>
</li>
<li><p>一在于deque允许常数时间内对头端进行元素插入和删除操作。</p>
</li>
<li><p>二在于deque没有容量的概念，因为它是动态的以分段的连续空间组合而成，随时可以增加一段新的空间并链接起来，换句话说，像vector那样“因旧空间不足而重新分配一块更大的空间，然后再复制元素，释放空间”这样的操作不会发生在deque身上，也因此deque没有必要提供所谓的空间保留功能。</p>
</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wpsDDCE.tmp.jpg" alt="img"> </p>
<p><strong>deque操作示意图</strong></p>
<p><img src="http://qiniu.orangew.cn/img/wpsDDCF.tmp.jpg" alt="img"> </p>
<p><strong>deque原理示意图</strong></p>
<ul>
<li><p><strong>特性总结:</strong></p>
</li>
<li><p><strong>双端插入和删除元素效率较高.</strong></p>
</li>
<li><p><strong>指定位置插入也会导致数据元素移动,降低效率.</strong></p>
</li>
<li><p><strong>可随机存取,效率高.</strong></p>
</li>
</ul>
<h4 id="2-3-2-deque常用API"><a href="#2-3-2-deque常用API" class="headerlink" title="2.3.2 deque常用API"></a><strong>2.3.2 deque常用API</strong></h4><h5 id="2-3-2-1-deque构造函数"><a href="#2-3-2-1-deque构造函数" class="headerlink" title="2.3.2.1 deque构造函数"></a><strong>2.3.2.1 deque构造函数</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">deque&lt;T&gt; deqT;&#x2F;&#x2F;默认构造形式
deque(beg, end);&#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。
deque(n, elem);&#x2F;&#x2F;构造函数将n个elem拷贝给本身。
deque(const deque &amp;deq);&#x2F;&#x2F;拷贝构造函数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="2-3-2-2-deque赋值操作"><a href="#2-3-2-2-deque赋值操作" class="headerlink" title="2.3.2.2 deque赋值操作"></a><strong>2.3.2.2 deque赋值操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">assign(beg, end);&#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。
assign(n, elem);&#x2F;&#x2F;将n个elem拷贝赋值给本身。
deque&amp; operator&#x3D;(const deque &amp;deq); &#x2F;&#x2F;重载等号操作符 
swap(deq);&#x2F;&#x2F; 将deq与本身的元素互换<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="2-3-2-3-deque大小操作"><a href="#2-3-2-3-deque大小操作" class="headerlink" title="2.3.2.3 deque大小操作"></a><strong>2.3.2.3 deque大小操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">deque.size();&#x2F;&#x2F;返回容器中元素的个数
deque.empty();&#x2F;&#x2F;判断容器是否为空
deque.resize(num);&#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以默认值填充新位置。如果容器变短，则末尾超出容器长度的元素被删除。
deque.resize(num, elem); &#x2F;&#x2F;重新指定容器的长度为num,若容器变长，则以elem值填充新位置,如果容器变短，则末尾超出容器长度的元素被删除。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="2-3-2-3-deque双端插入和删除操作"><a href="#2-3-2-3-deque双端插入和删除操作" class="headerlink" title="2.3.2.3 deque双端插入和删除操作"></a><strong>2.3.2.3 deque双端插入和删除操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">push_back(elem);&#x2F;&#x2F;在容器尾部添加一个数据
push_front(elem);&#x2F;&#x2F;在容器头部插入一个数据
pop_back();&#x2F;&#x2F;删除容器最后一个数据
pop_front();&#x2F;&#x2F;删除容器第一个数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="2-3-2-4-deque数据存取"><a href="#2-3-2-4-deque数据存取" class="headerlink" title="2.3.2.4 deque数据存取"></a><strong>2.3.2.4 deque数据存取</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">at(idx);&#x2F;&#x2F;返回索引idx所指的数据，如果idx越界，抛出out_of_range。
operator[];&#x2F;&#x2F;返回索引idx所指的数据，如果idx越界，不抛出异常，直接出错。
front();&#x2F;&#x2F;返回第一个数据。
back();&#x2F;&#x2F;返回最后一个数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="2-3-2-5-deque插入操作"><a href="#2-3-2-5-deque插入操作" class="headerlink" title="2.3.2.5 deque插入操作"></a><strong>2.3.2.5 deque插入操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">insert(pos,elem);&#x2F;&#x2F;在pos位置插入一个elem元素的拷贝，返回新数据的位置。
insert(pos,n,elem);&#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。
insert(pos,beg,end);&#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li>经验之谈 : deque是分段连续的内存空间，通过中控器维持一种连续内存空间的状态，其实现复杂性要大于vector queue stack等容器，其迭代器的实现也更加复杂，在需要对deque容器元素进行排序的时候，建议先将deque容器中数据数据元素拷贝到vector容器中，对vector进行排序，然后再将排序完成的数据拷贝回deque容器。</li>
</ul>
<h5 id="2-3-2-5-deque删除操作"><a href="#2-3-2-5-deque删除操作" class="headerlink" title="2.3.2.5 deque删除操作"></a><strong>2.3.2.5 deque删除操作</strong></h5><pre class="line-numbers language-\" data-language="\"><code class="language-\">clear();&#x2F;&#x2F;移除容器的所有数据
erase(beg,end);&#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。
erase(pos);&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h4 id="2-3-3-deque课后练习"><a href="#2-3-3-deque课后练习" class="headerlink" title="2.3.3 deque课后练习"></a><strong>2.3.3 deque课后练习</strong></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;评委打分案例(sort算法排序)
&#x2F;&#x2F;创建5个选手(姓名，得分)，10个评委对5个选手进行打分
&#x2F;&#x2F;得分规则：去除最高分，去除最低分，取出平均分
&#x2F;&#x2F;按得分对5名选手进行排名

#define _CRT_SECURE_NO_WARNINGS

#include&lt;iostream&gt;
#include&lt;deque&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
using namespace std;

&#x2F;&#x2F;选手类
class Player&#123;
public:
	string name;
	int score;
&#125;;

&#x2F;&#x2F;创建选手
void Create_Player(vector&lt;Player&gt;&amp; plist)&#123;

	string randseed &#x3D; &quot;ABCDE&quot;;
	for (int i &#x3D; 0; i &lt; 5;i++)&#123;
		Player player;
		player.name &#x3D; &quot;选手&quot;;
		player.name +&#x3D; randseed[i];
		player.score &#x3D; 0;

		plist.push_back(player);
	&#125;
&#125;


bool myconpare(int v1,int v2)&#123;
	return v1 &lt; v2;
&#125;
&#x2F;&#x2F;对选手进行打分
&#x2F;&#x2F;打分规则： 去除最高分 去除最低分 取平均分
void Set_Player_Score(vector&lt;Player&gt;&amp; plist)&#123;

	for (vector&lt;Player&gt;::iterator it &#x3D; plist.begin(); it !&#x3D; plist.end();it++)&#123;
		
		deque&lt;int&gt; dscore; &#x2F;&#x2F;保存评委的10次打分
		for (int i &#x3D; 0; i &lt; 10;i++)&#123;
			int score &#x3D; 50 + rand() % 50;
			dscore.push_back(score);
		&#125;
		&#x2F;&#x2F;排序从大到小或者从小到大 sort算法
		sort(dscore.begin(), dscore.end(), myconpare);
		&#x2F;&#x2F;去除最低分 去除最高分
		dscore.pop_front();
		dscore.pop_back();
		&#x2F;&#x2F;求平均分
		int totalscore &#x3D; 0;
		for (deque&lt;int&gt;::iterator dit &#x3D; dscore.begin(); dit !&#x3D; dscore.end();dit++)&#123;
			totalscore +&#x3D; *dit;
		&#125;
		int scoreavg &#x3D; totalscore &#x2F; dscore.size();
		(*it).score &#x3D; scoreavg;
	&#125;

&#125;

bool conparePlayer(Player player1, Player player2)&#123;
	return player1.score &gt; player2.score;
&#125;
&#x2F;&#x2F;按照得分排名
void Show_Player_List(vector&lt;Player&gt;&amp; plist)&#123;

	sort(plist.begin(), plist.end(), conparePlayer);
	cout &lt;&lt; &quot;选手得分排名:&quot; &lt;&lt; endl;
	for (vector&lt;Player&gt;::iterator it &#x3D; plist.begin(); it !&#x3D; plist.end();it++)&#123;
		cout &lt;&lt; &quot;姓名:&quot; &lt;&lt; it-&gt;name &lt;&lt; &quot; 得分:&quot; &lt;&lt; it-&gt;score &lt;&lt; endl;
	&#125;

&#125;

void test()&#123;

	vector&lt;Player&gt; plist;
	&#x2F;&#x2F;创建5名选手
	Create_Player(plist);
	&#x2F;&#x2F;对5名选手进行打分
	Set_Player_Score(plist);
	&#x2F;&#x2F;按照得分排名
	Show_Player_List(plist);

&#125;
int main()&#123;

	test();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="2-4-stack容器"><a href="#2-4-stack容器" class="headerlink" title="2.4 stack容器"></a><strong>2.4 stack容器</strong></h3><h4 id="2-4-1-stack特性"><a href="#2-4-1-stack特性" class="headerlink" title="2.4.1 stack特性"></a><strong>2.4.1 stack特性</strong></h4><ul>
<li>stack是一种先进后出(first in last out,FILO)的数据结构，它只有一个出口，stack只允许在栈顶新增元素，移除元素，获得顶端元素，但是除了顶端之外，其他地方不允许存取元素，只有栈顶元素可以被外界使用，也就是说stack不具有遍历行为，没有迭代器。</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wpsDDE0.tmp.jpg" alt="img"> </p>
<p><strong>特性总结:</strong></p>
<p><strong>栈不能遍历,不支持随机存取，只能通过top从栈顶获取和删除元素.</strong></p>
<p>​    </p>
<h4 id="2-4-2-stack常用API"><a href="#2-4-2-stack常用API" class="headerlink" title="2.4.2 stack常用API"></a><strong>2.4.2 stack常用API</strong></h4><h5 id="2-4-2-1-stack构造函数"><a href="#2-4-2-1-stack构造函数" class="headerlink" title="2.4.2.1 stack构造函数"></a><strong>2.4.2.1 stack构造函数</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">stack&lt;T&gt; stkT;&#x2F;&#x2F;stack采用模板类实现， stack对象的默认构造形式： 
stack(const stack &amp;stk);&#x2F;&#x2F;拷贝构造函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h5 id="2-4-2-2-stack赋值操作"><a href="#2-4-2-2-stack赋值操作" class="headerlink" title="2.4.2.2 stack赋值操作"></a><strong>2.4.2.2 stack赋值操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">stack&amp; operator&#x3D;(const stack &amp;stk);&#x2F;&#x2F;重载等号操作符<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h5 id="2-4-2-3-stack数据存取操作"><a href="#2-4-2-3-stack数据存取操作" class="headerlink" title="2.4.2.3 stack数据存取操作"></a><strong>2.4.2.3 stack数据存取操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">push(elem);&#x2F;&#x2F;向栈顶添加元素
pop();&#x2F;&#x2F;从栈顶移除第一个元素
top();&#x2F;&#x2F;返回栈顶元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h5 id="2-4-2-3-stack大小操作"><a href="#2-4-2-3-stack大小操作" class="headerlink" title="2.4.2.3 stack大小操作"></a><strong>2.4.2.3 stack大小操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">empty();&#x2F;&#x2F;判断堆栈是否为空
size();&#x2F;&#x2F;返回堆栈的大小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h3 id="2-5-queue容器"><a href="#2-5-queue容器" class="headerlink" title="2.5 queue容器"></a><strong>2.5 queue容器</strong></h3><h4 id="2-5-1-queue特性"><a href="#2-5-1-queue特性" class="headerlink" title="2.5.1 queue特性"></a><strong>2.5.1 queue特性</strong></h4><ul>
<li>queue是一种先进先出(first in first out, FIFO)的数据类型,他有两个口，数据元素只能从一个口进，从另一个口出.队列只允许从队尾加入元素，队头删除元素，必须符合先进先出的原则，queue和stack一样不具有遍历行为。</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wpsDDF0.tmp.jpg" alt="img"> </p>
<p><strong>特性总结：</strong></p>
<ul>
<li><p> 必须从一个口数据元素入队，另一个口数据元素出队。</p>
</li>
<li><p> 不能随机存取，不支持遍历</p>
</li>
</ul>
<h4 id="2-5-2-queue常用API"><a href="#2-5-2-queue常用API" class="headerlink" title="2.5.2 queue常用API"></a><strong>2.5.2 queue常用API</strong></h4><h5 id="2-5-2-1-queue构造函数"><a href="#2-5-2-1-queue构造函数" class="headerlink" title="2.5.2.1 queue构造函数"></a><strong>2.5.2.1 queue构造函数</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">queue&lt;T&gt; queT;&#x2F;&#x2F;queue采用模板类实现，queue对象的默认构造形式：
queue(const queue &amp;que);&#x2F;&#x2F;拷贝构造函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h5 id="2-5-2-2-queue存取、插入和删除操作"><a href="#2-5-2-2-queue存取、插入和删除操作" class="headerlink" title="2.5.2.2 queue存取、插入和删除操作"></a><strong>2.5.2.2 queue存取、插入和删除操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">push(elem);&#x2F;&#x2F;往队尾添加元素
pop();&#x2F;&#x2F;从队头移除第一个元素
back();&#x2F;&#x2F;返回最后一个元素
front();&#x2F;&#x2F;返回第一个元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="2-5-2-3-queue赋值操作"><a href="#2-5-2-3-queue赋值操作" class="headerlink" title="2.5.2.3 queue赋值操作"></a><strong>2.5.2.3 queue赋值操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">queue&amp; operator&#x3D;(const queue &amp;que);&#x2F;&#x2F;重载等号操作符<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h5 id="2-5-2-3-queue大小操作"><a href="#2-5-2-3-queue大小操作" class="headerlink" title="2.5.2.3 queue大小操作"></a><strong>2.5.2.3 queue大小操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">empty();&#x2F;&#x2F;判断队列是否为空
size();&#x2F;&#x2F;返回队列的大小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>课后思考：</strong></p>
<p><strong>队列和栈的共同点是什么？</strong></p>
<p><strong>A. 都是先进先出 B.都是先进后出 C.只允许在端点出删除和插入操作 D.没有共同点</strong></p>
<h3 id="2-6-list容器"><a href="#2-6-list容器" class="headerlink" title="2.6 list容器"></a><strong>2.6 list容器</strong></h3><h4 id="2-6-1-list特性"><a href="#2-6-1-list特性" class="headerlink" title="2.6.1 list特性"></a><strong>2.6.1 list特性</strong></h4><ul>
<li>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wpsDDF1.tmp.jpg" alt="img"> </p>
<p><strong>list示意图</strong></p>
<p><img src="http://qiniu.orangew.cn/img/wpsDDF2.tmp.jpg" alt="img"> </p>
<p><strong>list操作示意图</strong></p>
<p><strong>特性总结:</strong></p>
<ul>
<li>采用动态存储分配，不会造成内存浪费和溢出</li>
<li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li>
<li>链表灵活，但是空间和时间额外耗费较大</li>
</ul>
<h4 id="2-6-2-list-常用API"><a href="#2-6-2-list-常用API" class="headerlink" title="2.6.2 list 常用API"></a><strong>2.6.2 list 常用API</strong></h4><h5 id="2-6-2-1-list构造函数"><a href="#2-6-2-1-list构造函数" class="headerlink" title="2.6.2.1 list构造函数"></a><strong>2.6.2.1 list构造函数</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">list&lt;T&gt; lstT;&#x2F;&#x2F;list采用采用模板类实现,对象的默认构造形式：
list(beg,end);&#x2F;&#x2F;构造函数将[beg, end)区间中的元素拷贝给本身。
list(n,elem);&#x2F;&#x2F;构造函数将n个elem拷贝给本身。
list(const list &amp;lst);&#x2F;&#x2F;拷贝构造函数。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="2-6-2-2-list数据元素插入和删除操作"><a href="#2-6-2-2-list数据元素插入和删除操作" class="headerlink" title="2.6.2.2 list数据元素插入和删除操作"></a><strong>2.6.2.2 list数据元素插入和删除操作</strong></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">push_back(elem);&#x2F;&#x2F;在容器尾部加入一个元素
pop_back();&#x2F;&#x2F;删除容器中最后一个元素
push_front(elem);&#x2F;&#x2F;在容器开头插入一个元素
pop_front();&#x2F;&#x2F;从容器开头移除第一个元素
insert(pos,elem);&#x2F;&#x2F;在pos位置插elem元素的拷贝，返回新数据的位置。
insert(pos,n,elem);&#x2F;&#x2F;在pos位置插入n个elem数据，无返回值。
insert(pos,beg,end);&#x2F;&#x2F;在pos位置插入[beg,end)区间的数据，无返回值。
clear();&#x2F;&#x2F;移除容器的所有数据
erase(beg,end);&#x2F;&#x2F;删除[beg,end)区间的数据，返回下一个数据的位置。
erase(pos);&#x2F;&#x2F;删除pos位置的数据，返回下一个数据的位置。
remove(elem);&#x2F;&#x2F;删除容器中所有与elem值匹配的元素。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="2-6-2-3-list大小操作"><a href="#2-6-2-3-list大小操作" class="headerlink" title="2.6.2.3 list大小操作"></a><strong>2.6.2.3 list大小操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">size();&#x2F;&#x2F;返回容器中元素的个数
empty();&#x2F;&#x2F;判断容器是否为空
resize(num);&#x2F;&#x2F;重新指定容器的长度为num，
若容器变长，则以默认值填充新位置。
如果容器变短，则末尾超出容器长度的元素被删除。
resize(num, elem);&#x2F;&#x2F;重新指定容器的长度为num，
若容器变长，则以elem值填充新位置。
如果容器变短，则末尾超出容器长度的元素被删除。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h5 id="2-6-2-4-list赋值操作"><a href="#2-6-2-4-list赋值操作" class="headerlink" title="2.6.2.4 list赋值操作"></a><strong>2.6.2.4 list赋值操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">assign(beg, end);&#x2F;&#x2F;将[beg, end)区间中的数据拷贝赋值给本身。
assign(n, elem);&#x2F;&#x2F;将n个elem拷贝赋值给本身。
list&amp; operator&#x3D;(const list &amp;lst);&#x2F;&#x2F;重载等号操作符
swap(lst);&#x2F;&#x2F;将lst与本身的元素互换。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="2-6-2-5-list数据的存取"><a href="#2-6-2-5-list数据的存取" class="headerlink" title="2.6.2.5 list数据的存取"></a><strong>2.6.2.5 list数据的存取</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">front();&#x2F;&#x2F;返回第一个元素。
back();&#x2F;&#x2F;返回最后一个元素。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h5 id="2-6-2-5-list反转排列排序"><a href="#2-6-2-5-list反转排列排序" class="headerlink" title="2.6.2.5 list反转排列排序"></a><strong>2.6.2.5 list反转排列排序</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">reverse();&#x2F;&#x2F;反转链表，比如lst包含1,3,5元素，运行此方法后，lst就包含5,3,1元素。
sort(); &#x2F;&#x2F;list排序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p><strong>课后思考:</strong> </p>
<ul>
<li>链表和数组有什么区别？</li>
<li>数组必须事先定义固定的长度（元素个数），不能适应数据动态地增减的情况。当数据增加时，可能超出原先定义的元素个数；当数据减少时，造成内存浪费。</li>
<li>链表动态地进行存储分配，可以适应数据动态地增减的情况，且可以方便地插入、删除数据元素。（数组中插入、删除数据项时，需要移动其它数据项）</li>
</ul>
<h3 id="2-7-set-multiset容器"><a href="#2-7-set-multiset容器" class="headerlink" title="2.7 set/multiset容器"></a><strong>2.7 set/multiset容器</strong></h3><h3 id="2-7-1-set-multis4et特性"><a href="#2-7-1-set-multis4et特性" class="headerlink" title="2.7.1 set/multis4et特性"></a><strong>2.7.1 set/multis4et特性</strong></h3><ul>
<li>set/multiset的特性是所有元素会根据元素的值自动进行排序。set是以RB-tree（红黑树，平衡二叉树的一种）为底层机制，其查找效率非常好。set容器中不允许重复元素,multiset允许重复元素。</li>
</ul>
<ul>
<li>二叉树就是任何节点最多只允许有两个字节点。分别是左子结点和右子节点。</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wpsDE03.tmp.png" alt="img"></p>
<p><strong>二叉树示意图</strong></p>
<ul>
<li>二叉搜索树，是指二叉树中的节点按照一定的规则进行排序，使得对二叉树中元素访问更加高效。二叉搜索树的放置规则是：任何节点的元素值一定大于其左子树中的每一个节点的元素值，并且小于其右子树的值。因此从根节点一直向左走，一直到无路可走，即得到最小值，一直向右走，直至无路可走，可得到最大值。那么在二叉搜索树中找到最大元素和最小元素是非常简单的事情。下图为二叉搜索树：</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wpsDE04.tmp.jpg" alt="img"></p>
<ul>
<li>上面我们介绍了二叉搜索树，那么当一个二叉搜索树的左子树和右子树不平衡的时候，那么搜索依据上图表示，搜索9所花费的时间要比搜索17所花费的时间要多，由于我们的输入或者经过我们插入或者删除操作，二叉树失去平衡，造成搜索效率降低。</li>
</ul>
<ul>
<li>所以我们有了一个平衡二叉树的概念，所谓的平衡不是指的完全平衡。</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wpsDE05.tmp.jpg" alt="img"> </p>
<ul>
<li>RB-tree(红黑树)为二叉树的一种。</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wpsDE15.tmp.jpg" alt="img"> </p>
<ul>
<li>问：我们可以通过set的迭代器改变元素的值吗？</li>
</ul>
<ul>
<li>答: 不行，因为set集合是根据元素值进行排序，关系到set的排序规则，如果任意改变set的元素值，会严重破坏set组织。</li>
</ul>
<h4 id="2-7-2set-常用API"><a href="#2-7-2set-常用API" class="headerlink" title="2.7.2set 常用API"></a><strong>2.7.2set 常用API</strong></h4><h5 id="2-7-2-1-set构造函数"><a href="#2-7-2-1-set构造函数" class="headerlink" title="2.7.2.1 set构造函数"></a><strong>2.7.2.1 set构造函数</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">set&lt;T&gt; st;&#x2F;&#x2F;set默认构造函数：
mulitset&lt;T&gt; mst; &#x2F;&#x2F;multiset默认构造函数: 
set(const set &amp;st);&#x2F;&#x2F;拷贝构造函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h5 id="2-7-2-2-set赋值操作"><a href="#2-7-2-2-set赋值操作" class="headerlink" title="2.7.2.2 set赋值操作"></a><strong>2.7.2.2 set赋值操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">set&amp; operator&#x3D;(const set &amp;st);&#x2F;&#x2F;重载等号操作符
swap(st);&#x2F;&#x2F;交换两个集合容器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h5 id="2-7-2-2-set大小操作"><a href="#2-7-2-2-set大小操作" class="headerlink" title="2.7.2.2 set大小操作"></a><strong>2.7.2.2 set大小操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">size();&#x2F;&#x2F;返回容器中元素的数目
empty();&#x2F;&#x2F;判断容器是否为空<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h5 id="2-7-2-2-set插入和删除操作"><a href="#2-7-2-2-set插入和删除操作" class="headerlink" title="2.7.2.2 set插入和删除操作"></a><strong>2.7.2.2 set插入和删除操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">insert(elem);&#x2F;&#x2F;在容器中插入元素。
clear();&#x2F;&#x2F;清除所有元素
erase(pos);&#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。
erase(beg, end);&#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。
erase(elem);&#x2F;&#x2F;删除容器中值为elem的元素。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="2-7-2-3-set查找操作"><a href="#2-7-2-3-set查找操作" class="headerlink" title="2.7.2.3 set查找操作"></a><strong>2.7.2.3 set查找操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">find(key);&#x2F;&#x2F;查找键key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回map.end();
lower_bound(keyElem);&#x2F;&#x2F;返回第一个key&gt;&#x3D;keyElem元素的迭代器。
upper_bound(keyElem);&#x2F;&#x2F;返回第一个key&gt;keyElem元素的迭代器。
equal_range(keyElem);&#x2F;&#x2F;返回容器中key与keyElem相等的上下限的两个迭代器。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><strong>问题:</strong> 我们发现打印出来set集合中的元素是从小到大的升序排列，那么我们如何指定排序为降序呢？这个问题呢？我们需要了解函数对象的概念。</li>
</ul>
<h3 id="2-8-map-multimap容器"><a href="#2-8-map-multimap容器" class="headerlink" title="2.8 map/multimap容器"></a><strong>2.8</strong> <strong>map/multimap容器</strong></h3><h4 id="2-8-1-map-multimap特性"><a href="#2-8-1-map-multimap特性" class="headerlink" title="2.8.1 map/multimap特性"></a><strong>2.8.1 map/multimap特性</strong></h4><ul>
<li>map相对于set区别，map具有键值和实值，所有元素根据键值自动排序。pair的第一元素被称为键值，第二元素被称为实值。map也是以红黑树为底层实现机制。</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wpsDE16.tmp.jpg" alt="img"> </p>
<p><strong>set容器示意图</strong></p>
<p><img src="http://qiniu.orangew.cn/img/wpsDE17.tmp.jpg" alt="img"> </p>
<p><strong>multiset容器示意图</strong></p>
<ul>
<li>问题 : 我们通过map的迭代器可以修改map的键值吗？</li>
</ul>
<ul>
<li>答案是否定的，键值关系到容器内元素的排列规则，任意改变键值会破坏容器的排列规则，但是你可以改变实值。</li>
</ul>
<ul>
<li>map和multimap区别在于，map不允许相同key值存在，multimap则允许相同key值存在。</li>
</ul>
<h4 id="2-8-2-对组"><a href="#2-8-2-对组" class="headerlink" title="2.8.2 对组"></a><strong>2.8.2 对组</strong></h4><ul>
<li>对组(pair)将一对值组合成一个值，这一对值可以具有不同的数据类型，两个值可以分别用pair的两个公有函数first和second访问。</li>
</ul>
<ul>
<li>类模板：template &lt;class T1, class T2&gt; struct pair.</li>
</ul>
<ul>
<li>如何创建对组?</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;第一种方法创建一个对组
pair&lt;string, int&gt; pair1(string(&quot;name&quot;), 20);
cout &lt;&lt; pair1.first &lt;&lt; endl; &#x2F;&#x2F;访问pair第一个值
cout &lt;&lt; pair1.second &lt;&lt; endl;&#x2F;&#x2F;访问pair第二个值
&#x2F;&#x2F;第二种
pair&lt;string, int&gt; pair2 &#x3D; make_pair(&quot;name&quot;, 30);
cout &lt;&lt; pair2.first &lt;&lt; endl;
cout &lt;&lt; pair2.second &lt;&lt; endl;
&#x2F;&#x2F;pair&#x3D;赋值
pair&lt;string, int&gt; pair3 &#x3D; pair2;
cout &lt;&lt; pair3.first &lt;&lt; endl;
cout &lt;&lt; pair3.second &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="2-8-3-map常用API"><a href="#2-8-3-map常用API" class="headerlink" title="2.8.3 map常用API"></a><strong>2.8.3 map常用API</strong></h4><h5 id="2-8-3-1-map构造函数"><a href="#2-8-3-1-map构造函数" class="headerlink" title="2.8.3.1 map构造函数"></a><strong>2.8.3.1 map构造函数</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">map&lt;T1, T2&gt; mapTT;&#x2F;&#x2F;map默认构造函数: 
map(const map &amp;mp);&#x2F;&#x2F;拷贝构造函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h5 id="2-8-3-2-map赋值操作"><a href="#2-8-3-2-map赋值操作" class="headerlink" title="2.8.3.2 map赋值操作"></a><strong>2.8.3.2 map赋值操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">map&amp; operator&#x3D;(const map &amp;mp);&#x2F;&#x2F;重载等号操作符
swap(mp);&#x2F;&#x2F;交换两个集合容器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<h5 id="2-8-3-3-map大小操作"><a href="#2-8-3-3-map大小操作" class="headerlink" title="2.8.3.3 map大小操作"></a><strong>2.8.3.3 map大小操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">size();&#x2F;&#x2F;返回容器中元素的数目
empty();&#x2F;&#x2F;判断容器是否为空<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h5 id="2-8-3-4-map插入数据元素操作"><a href="#2-8-3-4-map插入数据元素操作" class="headerlink" title="2.8.3.4 map插入数据元素操作"></a><strong>2.8.3.4 map插入数据元素操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">map.insert(...); &#x2F;&#x2F;往容器插入元素，返回pair&lt;iterator,bool&gt;
map&lt;int, string&gt; mapStu;
&#x2F;&#x2F; 第一种 通过pair的方式插入对象
mapStu.insert(pair&lt;int, string&gt;(3, &quot;小张&quot;));
&#x2F;&#x2F; 第二种 通过pair的方式插入对象
mapStu.inset(make_pair(-1, &quot;校长&quot;));
&#x2F;&#x2F; 第三种 通过value_type的方式插入对象
mapStu.insert(map&lt;int, string&gt;::value_type(1, &quot;小李&quot;));
&#x2F;&#x2F; 第四种 通过数组的方式插入值
mapStu[3] &#x3D; &quot;小刘&quot;;
mapStu[5] &#x3D; &quot;小王&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>注意:</strong></p>
<ul>
<li>前三种方法，采用的是insert()方法，该方法返回值为pair&lt;iterator,bool&gt;</li>
<li>第四种方法非常直观，但存在一个性能的问题。插入3时，先在mapStu中查找主键为3的项，若没发现，则将一个键为3，值为初始化值的对组插入到mapStu中，然后再将值修改成“小刘”。若发现已存在3这个键，则修改这个键对应的value</li>
<li>string strName = mapStu[2];  //取操作或插入操作</li>
<li>只有当mapStu存在2这个键时才是正确的取操作，否则会自动插入一个实例，    键为2，值为初始化值。</li>
</ul>
<h5 id="2-8-3-5-map删除操作"><a href="#2-8-3-5-map删除操作" class="headerlink" title="2.8.3.5 map删除操作"></a><strong>2.8.3.5 map删除操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">clear();&#x2F;&#x2F;删除所有元素
erase(pos);&#x2F;&#x2F;删除pos迭代器所指的元素，返回下一个元素的迭代器。
erase(beg,end);&#x2F;&#x2F;删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。
erase(keyElem);&#x2F;&#x2F;删除容器中key为keyElem的对组。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h5 id="2-8-3-5-map查找操作"><a href="#2-8-3-5-map查找操作" class="headerlink" title="2.8.3.5 map查找操作"></a><strong>2.8.3.5 map查找操作</strong></h5><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">find(key);&#x2F;&#x2F;查找键key是否存在,若存在，返回该键的元素的迭代器；&#x2F;若不存在，返回map.end();
count(keyElem);&#x2F;&#x2F;返回容器中key为keyElem的对组个数。对map来说，要么是0，要么是1。对multimap来说，值可能大于1。
lower_bound(keyElem);&#x2F;&#x2F;返回第一个key&lt;&#x3D;keyElem元素的迭代器。
upper_bound(keyElem);&#x2F;&#x2F;返回第一个key&gt;keyElem元素的迭代器。
equal_range(keyElem);&#x2F;&#x2F;返回容器中key与keyElem相等的上下限的两个迭代器。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="2-8-4-multimap案例操练"><a href="#2-8-4-multimap案例操练" class="headerlink" title="2.8.4 multimap案例操练"></a><strong>2.8.4 multimap案例操练</strong></h4><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS

#include&lt;iostream&gt;
#include&lt;map&gt;
#include&lt;string&gt;
#include&lt;vector&gt;
using namespace std;

&#x2F;&#x2F;multimap 案例
&#x2F;&#x2F;公司今天招聘了 5 个员工，5 名员工进入公司之后，需要指派员工在那个部门工作
&#x2F;&#x2F;人员信息有: 姓名 年龄 电话 工资等组成
&#x2F;&#x2F;通过 Multimap 进行信息的插入 保存 显示
&#x2F;&#x2F;分部门显示员工信息 显示全部员工信息


#define SALE_DEPATMENT 1 &#x2F;&#x2F;销售部门
#define DEVELOP_DEPATMENT 2 &#x2F;&#x2F;研发部门
#define FINACIAL_DEPATMENT 3 &#x2F;&#x2F;财务部门
#define ALL_DEPATMENT 4 &#x2F;&#x2F;所有部门

&#x2F;&#x2F;员工类
class person&#123;
public:
	string name; &#x2F;&#x2F;员工姓名
	int age; &#x2F;&#x2F;员工年龄
	double salary; &#x2F;&#x2F;员工工资
	string tele; &#x2F;&#x2F;员工电话
&#125;;

&#x2F;&#x2F;创建5个员工
void CreatePerson(vector&lt;person&gt;&amp; vlist)&#123;

	string seed &#x3D; &quot;ABCDE&quot;;
	for (int i &#x3D; 0; i &lt; 5;i++)&#123;
		person p;
		p.name &#x3D; &quot;员工&quot;;
		p.name +&#x3D; seed[i];
		p.age &#x3D; rand() % 30 + 20;
		p.salary &#x3D; rand() % 20000 + 10000;
		p.tele &#x3D; &quot;010-8888888&quot;;
		vlist.push_back(p);
	&#125;
	
&#125;

&#x2F;&#x2F;5名员工分配到不同的部门
void PersonByGroup(vector&lt;person&gt;&amp; vlist, multimap&lt;int, person&gt;&amp; plist)&#123;


	int operate &#x3D; -1; &#x2F;&#x2F;用户的操作

	for (vector&lt;person&gt;::iterator it &#x3D; vlist.begin(); it !&#x3D; vlist.end();it++)&#123;
		
		cout &lt;&lt; &quot;当前员工信息:&quot; &lt;&lt; endl;
		cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; it-&gt;name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; it-&gt;age &lt;&lt; &quot; 工资:&quot; &lt;&lt; it-&gt;salary &lt;&lt; &quot; 电话：&quot; &lt;&lt; it-&gt;tele &lt;&lt; endl;
		cout &lt;&lt; &quot;请对该员工进行部门分配(1 销售部门, 2 研发部门, 3 财务部门):&quot; &lt;&lt; endl;
		scanf(&quot;%d&quot;, &amp;operate);	
		
		while (true)&#123;
			
			if (operate &#x3D;&#x3D; SALE_DEPATMENT)&#123;  &#x2F;&#x2F;将该员工加入到销售部门
				plist.insert(make_pair(SALE_DEPATMENT, *it));
				break;
			&#125;
			else if (operate &#x3D;&#x3D; DEVELOP_DEPATMENT)&#123;
				plist.insert(make_pair(DEVELOP_DEPATMENT, *it));
				break;
			&#125;
			else if (operate &#x3D;&#x3D; FINACIAL_DEPATMENT)&#123;
				plist.insert(make_pair(FINACIAL_DEPATMENT, *it));
				break;
			&#125;else&#123;
				cout &lt;&lt; &quot;您的输入有误，请重新输入(1 销售部门, 2 研发部门, 3 财务部门):&quot; &lt;&lt; endl;
				scanf(&quot;%d&quot;, &amp;operate);
			&#125;
		
		&#125;

	&#125;
	cout &lt;&lt; &quot;员工部门分配完毕!&quot; &lt;&lt; endl;
	cout &lt;&lt; &quot;***********************************************************&quot; &lt;&lt; endl;

&#125;

&#x2F;&#x2F;打印员工信息
void printList(multimap&lt;int, person&gt;&amp; plist, int myoperate)&#123;

	if (myoperate &#x3D;&#x3D; ALL_DEPATMENT)&#123;	
		for (multimap&lt;int, person&gt;::iterator it &#x3D; plist.begin(); it !&#x3D; plist.end(); it++)&#123;
			cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; it-&gt;second.name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; it-&gt;second.age &lt;&lt; &quot; 工资:&quot; &lt;&lt; it-&gt;second.salary &lt;&lt; &quot; 电话：&quot; &lt;&lt; it-&gt;second.tele &lt;&lt; endl;
		&#125;
		return;
	&#125;

	multimap&lt;int, person&gt;::iterator it &#x3D; plist.find(myoperate);
	int depatCount &#x3D; plist.count(myoperate);
	int num &#x3D; 0;
	if (it !&#x3D; plist.end())&#123;
		while (it !&#x3D; plist.end() &amp;&amp; num &lt; depatCount)&#123;
			cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; it-&gt;second.name &lt;&lt; &quot; 年龄:&quot; &lt;&lt; it-&gt;second.age &lt;&lt; &quot; 工资:&quot; &lt;&lt; it-&gt;second.salary &lt;&lt; &quot; 电话：&quot; &lt;&lt; it-&gt;second.tele &lt;&lt; endl;
			it++;
			num++;
		&#125;
	&#125;
&#125;

&#x2F;&#x2F;根据用户操作显示不同部门的人员列表
void ShowPersonList(multimap&lt;int, person&gt;&amp; plist, int myoperate)&#123;

	switch (myoperate)
	&#123;
	case SALE_DEPATMENT:
		printList(plist, SALE_DEPATMENT);
		break;
	case DEVELOP_DEPATMENT:
		printList(plist, DEVELOP_DEPATMENT);
		break;
	case FINACIAL_DEPATMENT:
		printList(plist, FINACIAL_DEPATMENT);
		break;
	case ALL_DEPATMENT:
		printList(plist, ALL_DEPATMENT);
		break;
	&#125;
&#125;

&#x2F;&#x2F;用户操作菜单
void PersonMenue(multimap&lt;int, person&gt;&amp; plist)&#123;
	
	int flag &#x3D; -1;
	int isexit &#x3D; 0;
	while (true)&#123;
		cout &lt;&lt; &quot;请输入您的操作((1 销售部门, 2 研发部门, 3 财务部门, 4 所有部门, 0退出)：&quot; &lt;&lt; endl;
		scanf(&quot;%d&quot;,&amp;flag);

		switch (flag)
		&#123;
			case SALE_DEPATMENT:
				ShowPersonList(plist, SALE_DEPATMENT);
				break;
			case DEVELOP_DEPATMENT:
				ShowPersonList(plist, DEVELOP_DEPATMENT);
				break;
			case FINACIAL_DEPATMENT:
				ShowPersonList(plist, FINACIAL_DEPATMENT);
				break;
			case ALL_DEPATMENT:
				ShowPersonList(plist, ALL_DEPATMENT);
				break;
			case 0:
				isexit &#x3D; 1;
				break;
			default:
				cout &lt;&lt; &quot;您的输入有误，请重新输入!&quot; &lt;&lt; endl;
				break;
		&#125;

		if (isexit &#x3D;&#x3D; 1)&#123;
			break;
		&#125;
	&#125;

&#125;



int main()&#123;

	vector&lt;person&gt;  vlist; &#x2F;&#x2F;创建的5个员工 未分组
	multimap&lt;int, person&gt; plist; &#x2F;&#x2F;保存分组后员工信息

	&#x2F;&#x2F;创建5个员工
	CreatePerson(vlist);
	&#x2F;&#x2F;5名员工分配到不同的部门
	PersonByGroup(vlist, plist);
	&#x2F;&#x2F;根据用户输入显示不同部门员工信息列表 或者 显示全部员工的信息列表
	PersonMenue(plist);
	
	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="2-9-STL容器共性机制"><a href="#2-9-STL容器共性机制" class="headerlink" title="2.9 STL容器共性机制"></a><strong>2.9 STL容器共性机制</strong></h3><ul>
<li><p>STL容器所提供的都是值(value)寓意，而非引用(reference)寓意，也就是说当我们给容器中插入元素的时候，容器内部实施了拷贝动作，将我们要插入的元素再另行拷贝一份放入到容器中，而不是将原数据元素直接放进容器中，也就是说我们提供的元素必须能够被拷贝。</p>
</li>
<li><p>除了queue和stack之外，每个容器都提供可返回迭代器的函数，运用返回的迭代器就可以访问元素。</p>
</li>
<li><p>通常STL不会抛出异常，需要使用者传入正确参数。</p>
</li>
<li><p>每个容器都提供了一个默认的构造函数和默认的拷贝构造函数。</p>
</li>
<li><p>大小相关的构造方法: 1 size()返回容器中元素的个数 2 empty()判断容器是否为空</p>
</li>
<li><p>那么当我们在向容器插入元素的时候，需要考虑一种情况，代码：</p>
</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

class myclass&#123;
public:
	myclass(char* data)&#123;
		int len &#x3D; strlen(data) + 1; &#x2F;&#x2F;计算传进来的字符串长度
		this-&gt;data &#x3D; new char[len];  &#x2F;&#x2F;在堆区分配了len字节内存
		strcpy(this-&gt;data, data); &#x2F;&#x2F;将数据拷贝到我们在堆分配的内存中
	&#125;
	&#x2F;&#x2F;既然我们在堆区分配了内存，需要在析构函数中释放内存
	~myclass()&#123;
		delete[] this-&gt;data;
		this-&gt;data &#x3D; NULL;
	&#125;
private:
	char* data;
&#125;;

void test_deep_copy()&#123;
	char* data &#x3D; &quot;abcd&quot;;
	myclass mc(data); &#x2F;&#x2F;创建myclass的实例 并用char*字符串data初始化对象

	vector&lt;myclass&gt; v;&#x2F;&#x2F;创建vector容器
	v.push_back(mc); &#x2F;&#x2F;将mc实例插入到vector容器尾部
&#125;

int main()&#123;
	test_deep_copy(); &#x2F;&#x2F;调用测试函数
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>那么以上代码会发生什么问题呢？我们在函数test_deep_copy()中创建了一个myclass对象，vector对象，这两个对象在函数test_deep_copy()执行完毕之后，会调用自身的析构函数，我们开题说了，STL容器都是值引用，再向容器中加入元素的时候，实际上是对元数据进行了一份拷贝，将拷贝的数据放入到容器中，如下图：</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wpsDE28.tmp.jpg" alt="img"></p>
<ul>
<li>由于我们没有提供拷贝构造函数,没有重载=操作符，vector对我们的mc对象进行的简单的浅拷贝，将拷贝的对象插入到容器中，导致我们的mc对象的data指针和容器中mc对象的拷贝对象中的data指针都指向了我们在堆区分配的内存，当函数结束，两个对象都调用了析构函数，先调用析构函数的对象成功释放了堆区内存，后调用析构函数的对象一释放，程序挂掉了。</li>
</ul>
<ul>
<li>原因在于两个指针指向了同一块堆区内存，这样会导致不可预知的结果，函数结束其中一个调用析构函数，销毁了data指向的内存空间，而另一个对象析构的时候就会挂掉。</li>
</ul>
<ul>
<li>问题的解决办法就是，给我们的对象提供一个拷贝构造函数，并且重载=操作符,两个指针分别指向自己的那一块内存，互不影响。</li>
</ul>
<p><img src="http://qiniu.orangew.cn/img/wpsDE39.tmp.jpg" alt="img">  </p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

class myclass&#123;
public:
	myclass(char* data)&#123;
		int len &#x3D; strlen(data) + 1; &#x2F;&#x2F;计算传进来的字符串长度
		this-&gt;data &#x3D; new char[len];  &#x2F;&#x2F;在堆区分配了len字节内存
		strcpy(this-&gt;data, data); &#x2F;&#x2F;将数据拷贝到我们在堆分配的内存中
	&#125;
	&#x2F;&#x2F;增加拷贝构造函数
	myclass(const myclass&amp; mc)&#123;
		int len &#x3D; strlen(mc.data) + 1;
		this-&gt;data &#x3D; new char[len];
		strcpy(this-&gt;data, mc.data);
	&#125;
	&#x2F;&#x2F;重载operator&#x3D;操作符
	myclass&amp; operator&#x3D;(const myclass&amp; mc)&#123;
		int len &#x3D; strlen(mc.data) + 1;
		this-&gt;data &#x3D; new char[len];
		strcpy(this-&gt;data, mc.data);
		return *this;
	&#125;
	&#x2F;&#x2F;既然我们在堆区分配了内存，需要在析构函数中释放内存
	~myclass()&#123;
		if (NULL !&#x3D; this-&gt;data)&#123;
			delete[] this-&gt;data;
			this-&gt;data &#x3D; NULL;
		&#125;
	&#125;
private:
	char* data;
&#125;;

void test_deep_copy()&#123;
	char* data &#x3D; “abcd”;
	myclass mc(data); &#x2F;&#x2F;创建myclass的实例 并用char*字符串data初始化对象

	vector&lt;myclass&gt; v;&#x2F;&#x2F;创建vector容器
	v.push_back(mc); &#x2F;&#x2F;将mc实例插入到vector容器尾部

&#125;

int main()&#123;
	test_deep_copy(); &#x2F;&#x2F;调用测试函数
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="2-10-STL容器使用时机"><a href="#2-10-STL容器使用时机" class="headerlink" title="2.10 STL容器使用时机"></a><strong>2.10 STL容器使用时机</strong></h3><table>
<thead>
<tr>
<th></th>
<th>vector</th>
<th>deque</th>
<th>list</th>
<th>set</th>
<th>multiset</th>
<th>map</th>
<th>multimap</th>
</tr>
</thead>
<tbody><tr>
<td>典型内存结构</td>
<td>单端数组</td>
<td>双端数组</td>
<td>双向链表</td>
<td>二叉树</td>
<td>二叉树</td>
<td>二叉树</td>
<td>二叉树</td>
</tr>
<tr>
<td>可随机存取</td>
<td>是</td>
<td>是</td>
<td>否</td>
<td>否</td>
<td>否</td>
<td>对key而言：是</td>
<td>否</td>
</tr>
<tr>
<td>元素搜寻速度</td>
<td>慢</td>
<td>慢</td>
<td>非常慢</td>
<td>快</td>
<td>快</td>
<td>对key而言：快</td>
<td>对key而言：快</td>
</tr>
<tr>
<td>元素安插移除</td>
<td>尾端</td>
<td>头尾两端</td>
<td>任何位置</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<ul>
<li>vector的使用场景：比如软件历史操作记录的存储，我们经常要查看历史记录，比如上一次的记录，上上次的记录，但却不会去删除记录，因为记录是事实的描述。</li>
</ul>
<ul>
<li>deque的使用场景：比如排队购票系统，对排队者的存储可以采用deque，支持头端的快速移除，尾端的快速添加。如果采用vector，则头端移除时，会移动大量的数据，速度慢。</li>
</ul>
<ul>
<li><p>vector与deque的比较：</p>
<ul>
<li><p>vector.at()比deque.at()效率高，比如vector.at(0)是固定的，deque的开始位置却是不固定的。</p>
</li>
<li><p>如果有大量释放操作的话，vector花的时间更少，这跟二者的内部实现有关。</p>
</li>
<li><p>deque支持头部的快速插入与快速移除，这是deque的优点。</p>
</li>
</ul>
</li>
<li><p>list的使用场景：比如公交车乘客的存储，随时可能有乘客下车，支持频繁的不确实位置元素的移除插入。</p>
</li>
<li><p>set的使用场景：比如对手机游戏的个人得分记录的存储，存储要求从高分到低分的顺序排列。 </p>
</li>
<li><p>map的使用场景：比如按ID号存储十万个用户，想要快速要通过ID查找对应的用户。二叉树的查找效率，这时就体现出来了。如果是vector容器，最坏的情况下可能要遍历完整个容器才能找到该用户。</p>
</li>
</ul>
<h2 id="第三章-常用算法"><a href="#第三章-常用算法" class="headerlink" title="第三章 常用算法"></a><strong>第三章 常用算法</strong></h2><ul>
<li>掌握函数对象适配器</li>
<li>了解算法基本分类</li>
<li>掌握常用遍历算法</li>
<li>掌握常用查找算法</li>
<li>掌握常用排序算法</li>
<li>掌握常用拷贝和替换算法</li>
<li>掌握常用算数生成算法</li>
<li>掌握集合常用算法</li>
</ul>
<h3 id="3-1-函数对象"><a href="#3-1-函数对象" class="headerlink" title="3.1 函数对象"></a><strong>3.1 函数对象</strong></h3><h4 id="3-1-1-函数对象的概念"><a href="#3-1-1-函数对象的概念" class="headerlink" title="3.1.1 函数对象的概念"></a><strong>3.1.1 函数对象的概念</strong></h4><ul>
<li>重载函数调用操作符的类，其对象常称为函数对象（function object），即它们是行为类似函数的对象，也叫仿函数(functor),其实就是重载“()”操作符，使得类对象可以像函数那样调用。</li>
</ul>
<ul>
<li><p>注意:1.函数对象(仿函数)是一个类，不是一个函数。</p>
</li>
<li><p>2.函数对象(仿函数)重载了”() ”操作符使得它可以像函数一样调用。</p>
</li>
<li><p>假定某个类有一个重载的operator()，而且重载的operator()要求获取一个参数，我们就将这个类称为“一元仿函数”（unary functor）；相反，如果重载的operator()要求获取两个参数，就将这个类称为“二元仿函数”（binary functor）。</p>
</li>
</ul>
<ul>
<li>函数对象基本概念</li>
</ul>
<ul>
<li>函数对象也可以有参数和返回值</li>
</ul>
<ul>
<li>函数对象超出函数概念，可以保存函数调用状态</li>
</ul>
<ul>
<li>函数对象做参数和返回值</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS
#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;functional&gt;
using namespace std;

class FuncObject01&#123;
public:
	void operator()()&#123;
		cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;
	&#125;
&#125;;

void FuncObject02()&#123;
	cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;
&#125;

&#x2F;&#x2F;函数对象概念
void test01()&#123;
	
	FuncObject01 fobj;
	fobj();
	FuncObject02();

&#125;

class FuncObject03&#123;
public:
	int operator()(int a, int b)&#123;
		return a + b;
	&#125;
&#125;;

int FuncObject04(int a,int b)&#123;
	return a + b;
&#125;
&#x2F;&#x2F;函数对象也可以像普通函数一样 具有返回值和参数
void test02()&#123;
	
	FuncObject03 fobj;
	int ret &#x3D; fobj(10,20);
	cout &lt;&lt; &quot;ret :&quot; &lt;&lt; ret &lt;&lt; endl;

	ret &#x3D; FuncObject04(10,20);
	cout &lt;&lt; &quot;ret :&quot; &lt;&lt; ret &lt;&lt; endl;

&#125;
&#x2F;&#x2F;函数对象超出了普通函数的功能，可以具有保存函数调用状态
&#x2F;&#x2F;例如 我们要统计函数调用次数

class FuncObject05&#123;
public:
	FuncObject05() :count(0)&#123;&#125;
	void operator()()&#123;
		cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;
		count++;
	&#125;
	int count;
&#125;;

&#x2F;&#x2F;普通函数要统计调用次数 需要一个全局变量
int g_count &#x3D; 0;
void FuncObject06()&#123;
	cout &lt;&lt; &quot;hello world&quot; &lt;&lt; endl;
	g_count++;
&#125;
void test03()&#123;

	FuncObject06();
	FuncObject06();
	cout &lt;&lt; &quot;函数调用次数：&quot; &lt;&lt; g_count &lt;&lt; endl;

	&#x2F;&#x2F;使用函数对象 不需要使用全局变量
	FuncObject05 fobj;
	fobj();
	fobj();
	fobj();

	cout &lt;&lt; &quot;函数调用次数：&quot; &lt;&lt; fobj.count &lt;&lt; endl;

&#125;

&#x2F;&#x2F;函数对象做参数和返回值
class print&#123;
public:
	print() :count(0)&#123;&#125;
	void operator()(const int&amp; val)&#123;
		cout &lt;&lt; val &lt;&lt; &quot; &quot;;
		count++;
	&#125;
	int count;
&#125;;
void test04()&#123;
	
	vector&lt;int&gt; v;
	v.push_back(1);
	v.push_back(3);
	v.push_back(5);
	v.push_back(2);

	&#x2F;&#x2F;通过for_each算法 遍历容器元素
	print myprint;
	&#x2F;&#x2F;函数对象做返回值和参数
	myprint &#x3D; for_each(v.begin(), v.end(), myprint);
	cout &lt;&lt; endl;

	cout &lt;&lt; &quot;函数对象调用次数:&quot; &lt;&lt; myprint.count &lt;&lt; endl;
&#125;

int main()&#123;
	test01();
	test02();
	test03();
	test04();
	
	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="3-1-2-谓词概念"><a href="#3-1-2-谓词概念" class="headerlink" title="3.1.2 谓词概念"></a><strong>3.1.2 谓词概念</strong></h4><ul>
<li>谓词是指普通函数或重载的operator()返回值是bool类型的函数对象(仿函数)。如果operator接受一个参数，那么叫做一元谓词,如果接受两个参数，那么叫做二元谓词，谓词可作为一个判断式。</li>
</ul>
<ul>
<li>例如：</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct myfuncobj01&#123;
      bool operator(int v)&#123;&#125;  &#x2F;&#x2F;接受一个参数，并且返回值为Bool 即一元谓词
&#125;
bool compare01(int v); &#x2F;&#x2F;同样是叫做一元谓词

struct myfuncobj02&#123;
      bool operator(int v1，int v2)&#123;&#125;  &#x2F;&#x2F;接受两个参数，返回值为Bool 即二元谓词
&#125;
bool compare02(int v1，int v2); &#x2F;&#x2F;同样是叫做二元谓词<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>一元函数对象 应用举例: for_each</li>
</ul>
<ul>
<li>一元谓词 应用举例：find_if</li>
</ul>
<ul>
<li>二元函数对象 应用举例: transform</li>
</ul>
<ul>
<li>二元谓词 应用举例 : sort</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS

#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;functional&gt;

using namespace std;

&#x2F;&#x2F;一元函数对象
class print&#123;
public:
	void operator()(const int&amp; v)&#123;
		cout &lt;&lt; v &lt;&lt; &quot; &quot;;
	&#125;
&#125;;
void test01()&#123;

	vector&lt;int&gt; v;

	v.push_back(1);
	v.push_back(2);
	v.push_back(5);
	v.push_back(3);

	&#x2F;&#x2F;一元函数对象
	for_each(v.begin(),v.end(), print());
	cout &lt;&lt; endl;

&#125;

&#x2F;&#x2F;一元谓词
class mygreater&#123;
public:
	bool operator()(const int&amp; v)&#123;
		return v &gt; 2;
	&#125;
&#125;;
void test02()&#123;
	
	vector&lt;int&gt; v;
	v.push_back(1);
	v.push_back(2);
	v.push_back(5);
	v.push_back(3);

	vector&lt;int&gt;::iterator it &#x3D; find_if(v.begin(), v.end(), mygreater()); &#x2F;&#x2F;匿名函数对象
	cout &lt;&lt; *it &lt;&lt; endl;
&#125;

&#x2F;&#x2F;二元函数对象
class myplus&#123;
public:
	int operator()(int v1,int v2)&#123;
		return v1 + v2;
	&#125;
&#125;;
void test03()&#123;

	vector&lt;int&gt; v1, v2,v3;
	v1.push_back(3);
	v1.push_back(4);
	v1.push_back(5);

	v2.push_back(7);
	v2.push_back(8);
	v2.push_back(2);


	v3.resize(v1.size()+ v2.size()); &#x2F;&#x2F; 给v3开辟空间

	transform(v1.begin(), v1.end(), v2.begin(),v3.begin(), myplus());
	for_each(v3.begin(), v3.end(), print());
	cout &lt;&lt; endl;
&#125;

&#x2F;&#x2F;二元谓词
class mycompare&#123;
public:
	bool operator()(int v1,int v2)&#123;
		return v1 &gt; v2;
	&#125;
&#125;;
void test04()&#123;

	vector&lt;int&gt; v;
	v.push_back(1);
	v.push_back(2);
	v.push_back(5);
	v.push_back(3);

	sort(v.begin(), v.end(), mycompare());
	for_each(v.begin(), v.end(), print());
&#125;

int main()&#123;

	test01();
	test02();
	test03();
	test04();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="3-1-3-内建函数对象"><a href="#3-1-3-内建函数对象" class="headerlink" title="3.1.3 内建函数对象"></a><strong>3.1.3 内建函数对象</strong></h4><ul>
<li>STL内建了一些函数对象。分为:算数类函数对象,关系运算类函数对象，逻辑运算类仿函数。这些仿函数所产生的对象，用法和一般函数完全相同，当然我们还可以产生无名的临时对象来履行函数功能。使用内建函数对象，需要引入头文件 #include<functional>。</li>
</ul>
<ul>
<li>6个算数类函数对象,除了negate是一元运算，其他都是二元运算。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;class T&gt; T plus&lt;T&gt;&#x2F;&#x2F;加法仿函数
template&lt;class T&gt; T minute&lt;T&gt;&#x2F;&#x2F;减法仿函数
template&lt;class T&gt; T multiplies&lt;T&gt;&#x2F;&#x2F;乘法仿函数
template&lt;class T&gt; T divides&lt;T&gt;&#x2F;&#x2F;除法仿函数
template&lt;class T&gt; T modulus&lt;T&gt;&#x2F;&#x2F;取模仿函数
template&lt;class T&gt; T negate&lt;T&gt;&#x2F;&#x2F;取反仿函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>6个关系运算类函数对象,每一种都是二元运算。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;class T&gt; bool equal_to&lt;T&gt;&#x2F;&#x2F;等于
template&lt;class T&gt; bool not_equal_to&lt;T&gt;&#x2F;&#x2F;不等于
template&lt;class T&gt; bool greater&lt;T&gt;&#x2F;&#x2F;大于
template&lt;class T&gt; bool greater_equal&lt;T&gt;&#x2F;&#x2F;大于等于
template&lt;class T&gt; bool less&lt;T&gt;&#x2F;&#x2F;小于
template&lt;class T&gt; bool less_equal&lt;T&gt;&#x2F;&#x2F;小于等于<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>逻辑运算类运算函数,not为一元运算，其余为二元运算。</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;class T&gt; bool logical_and&lt;T&gt;&#x2F;&#x2F;逻辑与
template&lt;class T&gt; bool logical_or&lt;T&gt;&#x2F;&#x2F;逻辑或
template&lt;class T&gt; bool logical_not&lt;T&gt;&#x2F;&#x2F;逻辑非<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>使用例子:</strong></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;使用内建函数对象声明一个对象
plus&lt;int&gt; myPlus;
cout &lt;&lt; myPlus(5, 3) &lt;&lt; endl;
&#x2F;&#x2F;使用匿名临时对象
cout &lt;&lt; plus&lt;int&gt;()(5, 6) &lt;&lt; endl;
sort排序使用预定义函数对象进行排序。
count_if equal_to 参数绑定<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="3-1-4-函数对象适配器"><a href="#3-1-4-函数对象适配器" class="headerlink" title="3.1.4 函数对象适配器"></a><strong>3.1.4 函数对象适配器</strong></h4><ul>
<li>函数对象适配器是完成一些配接工作，这些配接包括绑定(bind)，否定(negate),以及对一般函数或成员函数的修饰，使其成为函数对象，重点掌握函数对象适配器(红色字体):</li>
</ul>
<ul>
<li>bind1st ：将参数绑定为函数对象的第一个参数</li>
</ul>
<ul>
<li>bind2nd ： 将参数绑定为函数对象的第二个参数</li>
</ul>
<ul>
<li>not1 ： 对一元函数对象取反</li>
</ul>
<ul>
<li>not2 : 对二元函数对象取反</li>
</ul>
<ul>
<li>ptr_fun ： 将普通函数修饰成函数对象</li>
</ul>
<ul>
<li>mem_fun ： 修饰成员函数</li>
</ul>
<ul>
<li>mem_fun_ref ： 修饰成员函数</li>
</ul>
<ul>
<li>预定义函数对象</li>
</ul>
<ul>
<li>仿函数适配器bind1st bind2nd</li>
</ul>
<ul>
<li>仿函数适配器not1 not2</li>
</ul>
<ul>
<li>仿函数适配器 ptr_fun</li>
</ul>
<ul>
<li>成员函数适配器 mem_fun mem_fun_ref</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS

#include&lt;iostream&gt;
#include&lt;functional&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
using namespace std;

&#x2F;*
	template&lt;class T&gt; T plus&lt;T&gt;&#x2F;&#x2F;加法仿函数
	template&lt;class T&gt; T minute&lt;T&gt;&#x2F;&#x2F;减法仿函数
	template&lt;class T&gt; T multiplies&lt;T&gt;&#x2F;&#x2F;乘法仿函数
	template&lt;class T&gt; T divides&lt;T&gt;&#x2F;&#x2F;除法仿函数
	template&lt;class T&gt; T modulus&lt;T&gt;&#x2F;&#x2F;取模仿函数
	template&lt;class T&gt; T negate&lt;T&gt;&#x2F;&#x2F;取反仿函数
*&#x2F;
&#x2F;&#x2F;预定义函数对象
class print&#123;
public:
	void operator()(int v)&#123;
		cout &lt;&lt; v &lt;&lt; &quot;    &quot;;
	&#125;
&#125;;
void test01()&#123;
	
	plus&lt;int&gt; myplus; &#x2F;&#x2F;实例化一个对象
	int ret &#x3D; myplus(10, 20);
	cout &lt;&lt; &quot;ret : &quot; &lt;&lt; ret &lt;&lt; endl;

	cout &lt;&lt; plus&lt;int&gt;()(30, 40) &lt;&lt; endl;

	vector&lt;int&gt; v1, v2, v3;
	for (int i &#x3D; 0; i &lt; 10;i++)&#123;
		v1.push_back(i);
		v2.push_back(i + 1);
	&#125;

	v3.resize(v1.size());
	transform(v1.begin(),v1.end(),v2.begin(),v3.begin(),plus&lt;int&gt;());

	for_each(v1.begin(), v1.end(), print());
	cout &lt;&lt; endl;

	for_each(v2.begin(), v2.end(), print());
	cout &lt;&lt; endl;

	for_each(v3.begin(), v3.end(), print());
	cout &lt;&lt; endl;

&#125;

&#x2F;&#x2F;函数适配器bind1st bind2nd
&#x2F;&#x2F;现在我有这个需求 在遍历容器的时候，我希望将容器中的值全部加上100之后显示出来，怎么做哇？
struct myprint : public binary_function&lt;int,int,void&gt;&#123;   &#x2F;&#x2F;二元函数对象 所以需要继承 binary_fucntion&lt;参数类型,参数类型,返回值类型&gt;
	void operator()(int v1 ,int v2) const&#123;
		cout &lt;&lt; v1 + v2 &lt;&lt; &quot; &quot;;
	&#125;
&#125;;
void test02()&#123;
	
	vector&lt;int&gt; v;
	v.push_back(1);
	v.push_back(2);
	v.push_back(3);
	v.push_back(4);

	&#x2F;&#x2F;我们直接给函数对象绑定参数 编译阶段就会报错
	&#x2F;&#x2F;for_each(v.begin(), v.end(), bind2nd(myprint(),100));
	&#x2F;&#x2F;如果我们想使用绑定适配器,需要我们自己的函数对象继承binary_function 或者 unary_function
	&#x2F;&#x2F;根据我们函数对象是一元函数对象 还是二元函数对象
	for_each(v.begin(), v.end(), bind2nd(myprint(), 100));
	cout &lt;&lt; endl;

	&#x2F;&#x2F;总结：  bind1st和bind2nd区别?
	&#x2F;&#x2F;bind1st ： 将参数绑定为函数对象的第一个参数
	&#x2F;&#x2F;bind2nd ： 将参数绑定为函数对象的第二个参数
	&#x2F;&#x2F;bind1st bind2nd将二元函数对象转为一元函数对象

&#125;

&#x2F;&#x2F;函数对象适配器 not1 not2
struct myprint02 &#123;
	void operator()(int v1) const&#123;
		cout &lt;&lt; v1 &lt;&lt; &quot; &quot;;
	&#125;
&#125;;
void test03()&#123;

	vector&lt;int&gt; v;
	v.push_back(2);
	v.push_back(1);
	v.push_back(5);
	v.push_back(4);
	
	vector&lt;int&gt;::iterator it &#x3D;  find_if(v.begin(), v.end(), not1(bind2nd(less_equal&lt;int&gt;(), 2)));
	cout &lt;&lt; &quot;it:&quot; &lt;&lt; *it &lt;&lt; endl;
	sort(v.begin(),v.end(),not2(greater&lt;int&gt;()));

	for_each(v.begin(), v.end(), myprint02());
	cout &lt;&lt; endl;

	&#x2F;&#x2F;not1 对一元函数对象取反
	&#x2F;&#x2F;not2 对二元函数对象取反
&#125;

&#x2F;&#x2F;如何给一个普通函数使用绑定适配器(bind1st bind2nd)绑定一个参数？(拓展)
&#x2F;&#x2F;ptr_fun
void myprint04(int v1,int v2)&#123;
	cout &lt;&lt; v1 + v2 &lt;&lt; &quot; &quot;;
&#125;
void test04()&#123;
	
	vector&lt;int&gt; v;
	v.push_back(2);
	v.push_back(1);
	v.push_back(5);
	v.push_back(4);


	&#x2F;&#x2F;1 将普通函数适配成函数对象
	&#x2F;&#x2F;2 然后通过绑定器绑定参数
	for_each(v.begin(), v.end(), bind2nd(ptr_fun(myprint04),100));
	cout &lt;&lt; endl;

	&#x2F;&#x2F;总结: ptr_fun 将普通函数转变为函数对象
&#125;

&#x2F;&#x2F;mem_fun mem_fun_ref
&#x2F;&#x2F;如果我们容器中存储的是对象或者对象指针，如果能指定某个成员函数处理成员数据。
class student&#123;
public:
	student(string name, int age) :name(name), age(age)&#123;&#125;
	void print()&#123;
		cout &lt;&lt; &quot;name:&quot; &lt;&lt; name &lt;&lt; &quot; age:&quot; &lt;&lt; age &lt;&lt; endl;;
	&#125;
	void print2(int a)&#123;
		cout &lt;&lt; &quot;name:&quot; &lt;&lt; name &lt;&lt; &quot; age:&quot; &lt;&lt; age &lt;&lt; &quot; a:&quot; &lt;&lt; a &lt;&lt; endl;
	&#125;
	int age;
	string name;
&#125;;
void test05()&#123;
	

	&#x2F;&#x2F;mem_fun : 如果存储的是对象指针，需要使用mem_fun
	vector&lt;student*&gt; v;
	student* s1 &#x3D; new student(&quot;zhaosi&quot;,10);
	student* s2 &#x3D; new student(&quot;liuneng&quot;, 20);
	student* s3 &#x3D; new student(&quot;shenyang&quot;, 30);
	student* s4 &#x3D; new student(&quot;xiaobao&quot;, 40);

	v.push_back(s1);
	v.push_back(s2);
	v.push_back(s3);
	v.push_back(s4);

	for_each(v.begin(), v.end(), mem_fun(&amp;student::print));
	cout &lt;&lt; &quot;-----------------------------&quot; &lt;&lt; endl;

	&#x2F;&#x2F;mem_fun_ref : 如果存储的是对象，需要使用mem_fun_ref

	vector&lt;student&gt; v2;
	v2.push_back(student(&quot;zhaosi&quot;,50));
	v2.push_back(student(&quot;liuneng&quot;, 60));
	v2.push_back(student(&quot;shenyang&quot;, 70));
	v2.push_back(student(&quot;xiaobao&quot;, 80));

	for_each(v2.begin(), v2.end(), mem_fun_ref(&amp;student::print));

&#125;


int main()&#123;

	&#x2F;&#x2F;test01();
	&#x2F;&#x2F;test02();
	&#x2F;&#x2F;test03();
	&#x2F;&#x2F;test04();
	test05();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-2-算法概述"><a href="#3-2-算法概述" class="headerlink" title="3.2 算法概述"></a><strong>3.2 算法概述</strong></h3><ul>
<li>算法主要是由头文件<algorithm> <functional> <numeric>组成。</li>
</ul>
<ul>
<li><p><algorithm>是所有STL头文件中最大的一个,其中常用的功能涉及到比较，交换，查找,遍历，复制，修改，反转，排序，合并等…</p>
</li>
<li><p><numeric>体积很小，只包括在几个序列容器上进行的简单运算的模板函数.</p>
</li>
<li><p><functional> 定义了一些模板类,用以声明函数对象。</p>
</li>
<li><p>STL算法分为：<strong>质变算法</strong>和<strong>非质变算法</strong>。</p>
</li>
</ul>
<ul>
<li>所有的STL算法都作用在由迭代器[first,end)所标示出来的区间上，所谓质变算法，是指运算过程中会改变区间内的(迭代器所指)的元素内容。比如，拷贝(copy)、互换(swap)、替换(replace)、填写(fill)、删除(remove)、排序(sort)等算法都属于此类。</li>
</ul>
<ul>
<li>非质变算法是指是指在运算过程中不会区间内(迭代器所指)的元素内容，比如查找(find)、计数(count)、遍历(for_each)、寻找极值(max,min)等，都属于此类。但是如果你在for_each遍历每个元素的时候试图应用一个会改变元素内容的仿函数，那么元素当然也会改变。</li>
</ul>
<h3 id="3-3-常用遍历算法"><a href="#3-3-常用遍历算法" class="headerlink" title="3.3 常用遍历算法"></a><strong>3.3 常用遍历算法</strong></h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*
    遍历算法 遍历容器元素
	@param beg 开始迭代器
	@param end 结束迭代器
	@param _callback  函数回调或者函数对象
	@return 函数对象
*&#x2F;
for_each(iterator beg, iterator end, _callback);
&#x2F;*
	transform算法 将指定容器区间元素搬运到另一容器中
	注意 : transform 不会给目标容器分配内存，所以需要我们提前分配好内存
	@param beg1 源容器开始迭代器
	@param end1 源容器结束迭代器
	@param beg2 目标容器开始迭代器
	@param _cakkback 回调函数或者函数对象
	@return 返回目标容器迭代器
*&#x2F;
transform(iterator beg1, iterator end1, iterator beg2, _callbakc)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h4 id="3-3-1-for-each练习代码："><a href="#3-3-1-for-each练习代码：" class="headerlink" title="3.3.1 for_each练习代码："></a><strong>3.3.1 for_each练习代码：</strong></h4><ul>
<li>基本正向遍历和逆向遍历</li>
</ul>
<ul>
<li>for_each绑定参数输出</li>
</ul>
<ul>
<li>for_each修改容器元素</li>
</ul>
<ul>
<li>for_each返回值</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS

#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;functional&gt;

using namespace std;

&#x2F;&#x2F;for_each正向遍历 反向遍历
struct print01&#123;
	void operator()(int v)&#123;
		cout &lt;&lt; v &lt;&lt; &quot; &quot;;
	&#125;
&#125;;
void test01()&#123;
	
	vector&lt;int&gt; v;
	for (int i &#x3D; 0; i &lt; 10;i++)&#123;
		v.push_back(rand() % 100);
	&#125;

	&#x2F;&#x2F;正向遍历
	for_each(v.begin(), v.end(), print01());
	cout &lt;&lt; endl;
	&#x2F;&#x2F;反向遍历
	for_each(v.rbegin(), v.rend(), print01());
	cout &lt;&lt; endl;
&#125;


&#x2F;&#x2F;for_each算法 绑定参数
&#x2F;&#x2F;将容器中的元素加上100 再输出
struct print2 : public binary_function&lt;int,int,void&gt;&#123;
	void operator()(int v1,int v2) const&#123;
		cout &lt;&lt; v1+v2 &lt;&lt; &quot; &quot;;
	&#125;
&#125;;
void print21(int v1, int v2)&#123;
	cout &lt;&lt; v1 + v2 &lt;&lt; &quot; &quot;;
&#125;
void test02()&#123;
	
	vector&lt;int&gt; v;
	for (int i &#x3D; 0; i &lt; 10; i++)&#123;
		v.push_back(rand() % 100);
	&#125;

	for_each(v.begin(), v.end(), print01());
	cout &lt;&lt; endl;

	&#x2F;&#x2F;函数对象做参数
	for_each(v.begin(), v.end(), bind2nd(print2(), 100));
	cout &lt;&lt; endl;
	&#x2F;&#x2F;普通回调函数做参数，并且绑定参数
	for_each(v.begin(), v.end(), bind2nd(ptr_fun(print21), 100));
	cout &lt;&lt; endl;

&#125;

&#x2F;&#x2F;for_each修改元素值
struct print3 &#123;
	void operator()(int&amp; v1) const&#123;
		v1 &#x3D; v1 + 100;
		cout &lt;&lt; v1 &lt;&lt; &quot; &quot;;
	&#125;
&#125;;
void test03()&#123;
	
	vector&lt;int&gt; v;
	for (int i &#x3D; 0; i &lt; 10; i++)&#123;
		v.push_back(rand() % 100);
	&#125;

	for_each(v.begin(), v.end(), print01());
	cout &lt;&lt; endl;

	for_each(v.begin(), v.end(), print3());
	cout &lt;&lt; endl;

	for_each(v.begin(), v.end(), print01());
	cout &lt;&lt; endl;
&#125;

&#x2F;&#x2F;for_each返回值
struct print4 &#123;
	print4() :count(0)&#123;&#125;
	void operator()(int v1)&#123;
		count++;
		cout &lt;&lt; v1 &lt;&lt; &quot; &quot;;
	&#125;
	int count;
&#125;;
void test04()&#123;
	
	vector&lt;int&gt; v;
	for (int i &#x3D; 0; i &lt; 10; i++)&#123;
		v.push_back(rand() % 100);
	&#125;
	print4 temp1;
	print4 temp2 &#x3D; for_each(v.begin(), v.end(), temp1);
	cout &lt;&lt; endl;

	cout &lt;&lt; &quot;temp1:&quot; &lt;&lt; temp1.count &lt;&lt; endl;
	cout &lt;&lt; &quot;temp2:&quot; &lt;&lt; temp2.count &lt;&lt; endl;

&#125;
int main()&#123;

	&#x2F;&#x2F;test01();
	test02();
	test03();
	test04();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h4 id="3-3-2-transform练习代码："><a href="#3-3-2-transform练习代码：" class="headerlink" title="3.3.2 transform练习代码："></a><strong>3.3.2 transform练习代码：</strong></h4><ul>
<li>从一个容器经过处理搬运到另一个容器:</li>
</ul>
<ul>
<li>两个容器数据处理搬运到第三个容器</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS

#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;functional&gt;

using namespace std;

&#x2F;&#x2F;容器中元素加10 搬运到另一容器中
void print1(int v)&#123;
	cout &lt;&lt; v &lt;&lt; &quot; &quot;;
&#125;
struct myplus01&#123;
	int operator()(int v1)&#123;
		return v1 + 100;
	&#125;
&#125;;
void test01()&#123;
	
	vector&lt;int&gt; v,dest;
	for (int i &#x3D; 0; i &lt; 10; i++)&#123;
		v.push_back(rand() % 100);
	&#125;
	for_each(v.begin(), v.end(), print1);
	cout &lt;&lt; endl;
	&#x2F;&#x2F;首先给dest开辟足够内存
	dest.resize(v.size());
	&#x2F;&#x2F;搬运元素

	&#x2F;*
		template&lt;class _InIt,
		class _OutIt,
		class _Fn1&gt; inline
		_OutIt _Transform(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1 _Func)
		&#123;	&#x2F;&#x2F; transform [_First, _Last) with _Func
		for (; _First !&#x3D; _Last; ++_First, ++_Dest)
		*_Dest &#x3D; _Func(*_First);
		return (_Dest);
		&#125;
	*&#x2F;
	transform(v.begin(), v.end(), dest.begin(), myplus01());
	for_each(dest.begin(), dest.end(), print1);
	cout &lt;&lt; endl;

&#125;

&#x2F;&#x2F;容器1的元素 + 容器2的元素 搬运到 第三个容器中
struct myplus02&#123;
	int operator()(int v1,int v2)&#123;
		return v1 + v2;
	&#125;
&#125;;
void test02()&#123;

	vector&lt;int&gt; v1,v2, dest;
	for (int i &#x3D; 0; i &lt; 10; i++)&#123;
		v1.push_back(i);
		v2.push_back(i + 1);
	&#125;
	for_each(v1.begin(), v1.end(), print1);
	cout &lt;&lt; endl;
	&#x2F;*
		template&lt;class _InIt1,
		class _InIt2,
		class _OutIt,
		class _Fn2&gt; inline
		_OutIt transform(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func)
		&#123;	&#x2F;&#x2F; transform [_First1, _Last1) and [_First2, ...) with _Func
		_DEBUG_RANGE(_First1, _Last1);
		_DEBUG_POINTER(_Dest);
		_DEBUG_POINTER(_Func);
		if (_First1 !&#x3D; _Last1)
		return (_Transform2(_Unchecked(_First1), _Unchecked(_Last1),
		_First2, _Dest, _Func,
		_Is_checked(_Dest)));
		return (_Dest);
		&#125;


		template&lt;class _InIt1,
		class _InIt2,
		class _OutIt,
		class _Fn2&gt; inline
		_OutIt _Transform(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func)
		&#123;	&#x2F;&#x2F; transform [_First1, _Last1) and [_First2, ...) with _Func
		for (; _First1 !&#x3D; _Last1; ++_First1, ++_First2, ++_Dest)
		*_Dest &#x3D; _Func(*_First1, *_First2);
		return (_Dest);
		&#125;

	*&#x2F;

	dest.resize(v1.size());
	transform(v1.begin(), v1.end(), v2.begin(), dest.begin(), myplus02());

	for_each(dest.begin(), dest.end(), print1);
	cout &lt;&lt; endl;
&#125;
int main()&#123;

	&#x2F;&#x2F;test01();
	test02();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-4-常用查找算法"><a href="#3-4-常用查找算法" class="headerlink" title="3.4 常用查找算法"></a><strong>3.4 常用查找算法</strong></h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*
	find算法 查找元素
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param value 查找的元素
	@return 返回查找元素的位置
*&#x2F;
find(iterator beg, iterator end, value)
&#x2F;*
	adjacent_find算法 查找相邻重复元素
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param  _callback 回调函数或者谓词(返回bool类型的函数对象)
	@return 返回相邻元素的第一个位置的迭代器
*&#x2F;
adjacent_find(iterator beg, iterator end, _callback);
&#x2F;*
	binary_search算法 二分查找法
	注意: 在无序序列中不可用
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param value 查找的元素
	@return bool 查找返回true 否则false
*&#x2F;
bool binary_search(iterator beg, iterator end, value);
&#x2F;*
	find_if算法 条件查找
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param  callback 回调函数或者谓词(返回bool类型的函数对象)
	@return bool 查找返回true 否则false
*&#x2F;
find_if(iterator beg, iterator end, _callback);
&#x2F;*
	count算法 统计元素出现次数
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param  value回调函数或者谓词(返回bool类型的函数对象)
	@return int返回元素个数
*&#x2F;
count(iterator beg, iterator end, value);
&#x2F;*
	count算法 统计元素出现次数
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param  callback 回调函数或者谓词(返回bool类型的函数对象)
	@return int返回元素个数
*&#x2F;
count_if(iterator beg, iterator end, _callback);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="3-4-1-find算法案例"><a href="#3-4-1-find算法案例" class="headerlink" title="3.4.1 find算法案例"></a><strong>3.4.1 find算法案例</strong></h3><ul>
<li>find查找基本数据类型，类对象，类指针:</li>
</ul>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define _CRT_SECURE_NO_WARNINGS

#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;functional&gt;

using namespace std;


&#x2F;&#x2F;find 算法
void test01()&#123;
	
	int arr[] &#x3D; &#123;5,2,8,9,1,3&#125;;
	vector&lt;int&gt; v(arr, arr + sizeof(arr) &#x2F; sizeof(int));

	&#x2F;*
		template&lt;class _InIt,
		class _Ty&gt; inline
		_InIt find(_InIt _First, _InIt _Last, const _Ty&amp; _Val)
		&#123;	&#x2F;&#x2F; find first matching _Val
		_DEBUG_RANGE(_First, _Last);
		return (_Rechecked(_First,
			_Find(_Unchecked(_First), _Unchecked(_Last), _Val)));
		&#125;
	
	*&#x2F;

	&#x2F;&#x2F;这里注意find返回值 如果没有找到 返回 v.end()
	vector&lt;int&gt;::iterator it &#x3D;  find(v.begin(),v.end(),1);
	&#x2F;&#x2F;可以这样判断是否找到元素
	if (it &#x3D;&#x3D; v.end())&#123;
		cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;
	&#125;
	else&#123;
		cout &lt;&lt; *it &lt;&lt; endl;
	&#125;

&#125;

&#x2F;&#x2F;find查找对象
class sutdent&#123;
public:
	sutdent(int age, int salary) :age(age), salary(salary)&#123;&#125;
	int age;
	int salary;

	bool operator&#x3D;&#x3D;(const sutdent&amp; stu)&#123;
		if (this-&gt;age &#x3D;&#x3D; stu.age &amp;&amp; this-&gt;salary &#x3D;&#x3D; stu.salary)&#123;
			return true;
		&#125;
		else&#123;
			return false;
		&#125;
	&#125;
&#125;;
void test02()&#123;
	
	&#x2F;&#x2F;对象查找  重载&#x3D;&#x3D;操作符
	sutdent s1(1, 2), s2(3, 4), s3(5, 6);
	vector&lt;sutdent&gt; vs;
	vs.push_back(s1);
	vs.push_back(s2);
	vs.push_back(s3);

	vector&lt;sutdent&gt;::iterator its &#x3D; find(vs.begin(), vs.end(), s2);
	if (its &#x3D;&#x3D; vs.end())&#123;
		cout &lt;&lt; &quot;s2没有找到！&quot; &lt;&lt; endl;
	&#125;
	else&#123;
		cout &lt;&lt; &quot;s2找到！&quot; &lt;&lt; endl;
	&#125;

&#125;


int main()&#123;

	&#x2F;&#x2F;test01();
	test02();

	system(&quot;pause&quot;);
	return EXIT_SUCCESS;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="3-5-常用排序算法"><a href="#3-5-常用排序算法" class="headerlink" title="3.5 常用排序算法"></a><strong>3.5 常用排序算法</strong></h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*
	merge算法 容器元素合并，并存储到另一容器中
	@param beg1 容器1开始迭代器
	@param end1 容器1结束迭代器
	@param beg2 容器2开始迭代器
	@param end2 容器2结束迭代器
	@param dest  目标容器开始迭代器
*&#x2F;
merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)
&#x2F;*
	sort算法 容器元素排序
	注意:两个容器必须是有序的
	@param beg 容器1开始迭代器
	@param end 容器1结束迭代器
	@param _callback 回调函数或者谓词(返回bool类型的函数对象)
*&#x2F;
sort(iterator beg, iterator end, _callback)
&#x2F;*
	sort算法 对指定范围内的元素随机调整次序
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
*&#x2F;
random_shuffle(iterator beg, iterator end)
&#x2F;*
	reverse算法 反转指定范围的元素
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
*&#x2F;
reverse(iterator beg, iterator end)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="3-6-常用拷贝和替换算法"><a href="#3-6-常用拷贝和替换算法" class="headerlink" title="3.6 常用拷贝和替换算法"></a><strong>3.6 常用拷贝和替换算法</strong></h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*
	copy算法 将容器内指定范围的元素拷贝到另一容器中
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param dest 目标容器结束迭代器
*&#x2F;
copy(iterator beg, iterator end, iterator dest)
&#x2F;*
	replace算法 将容器内指定范围的旧元素修改为新元素
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param oldvalue 旧元素
	@param oldvalue 新元素
*&#x2F;
replace(iterator beg, iterator end, oldvalue, newvalue)
&#x2F;*
	replace_if算法 将容器内指定范围满足条件的元素替换为新元素
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param callback函数回调或者谓词(返回Bool类型的函数对象)
	@param oldvalue 新元素
*&#x2F;
replace_if(iterator beg, iterator end, _callback, newvalue)
&#x2F;*
	swap算法 互换两个容器的元素
	@param c1容器1
	@param c2容器2
*&#x2F;
swap(container c1, container c2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="3-7-常用算数生成算法"><a href="#3-7-常用算数生成算法" class="headerlink" title="3.7 常用算数生成算法"></a><strong>3.7 常用算数生成算法</strong></h3><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*
	accumulate算法 计算容器元素累计总和
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param value累加值
*&#x2F;
accumulate(iterator beg, iterator end, value)
&#x2F;*
	fill算法 向容器中添加元素
	@param beg 容器开始迭代器
	@param end 容器结束迭代器
	@param value t填充元素
*&#x2F;
fill(iterator beg, iterator end, value)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="3-8-常用集合算法"><a href="#3-8-常用集合算法" class="headerlink" title="3.8 常用集合算法"></a><strong>3.8 常用集合算法</strong></h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;*
	set_intersection算法 求两个set集合的交集
	注意:两个集合必须是有序序列
	@param beg1 容器1开始迭代器
	@param end1 容器1结束迭代器
	@param beg2 容器2开始迭代器
	@param end2 容器2结束迭代器
	@param dest  目标容器开始迭代器
	@return 目标容器的最后一个元素的迭代器地址
*&#x2F;
set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)
&#x2F;*
	set_union算法 求两个set集合的并集
	注意:两个集合必须是有序序列
	@param beg1 容器1开始迭代器
	@param end1 容器1结束迭代器
	@param beg2 容器2开始迭代器
	@param end2 容器2结束迭代器
	@param dest  目标容器开始迭代器
	@return 目标容器的最后一个元素的迭代器地址
*&#x2F;
set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)
&#x2F;*
	set_difference算法 求两个set集合的差集
	注意:两个集合必须是有序序列
	@param beg1 容器1开始迭代器
	@param end1 容器1结束迭代器
	@param beg2 容器2开始迭代器
	@param end2 容器2结束迭代器
	@param dest  目标容器开始迭代器
	@return 目标容器的最后一个元素的迭代器地址
*&#x2F;
set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="第四章-STL综合案例"><a href="#第四章-STL综合案例" class="headerlink" title="第四章 STL综合案例"></a><strong>第四章 STL综合案例</strong></h2><h3 id="4-1案例学校演讲比赛"><a href="#4-1案例学校演讲比赛" class="headerlink" title="4.1案例学校演讲比赛"></a><strong>4.1案例学校演讲比赛</strong></h3><h3 id="4-2学校演讲比赛介绍"><a href="#4-2学校演讲比赛介绍" class="headerlink" title="4.2学校演讲比赛介绍"></a><strong>4.2学校演讲比赛介绍</strong></h3><p>1）某市举行一场演讲比赛（ speech_contest ），共有24个人参加。比赛共三轮，前两轮为淘汰赛，第三轮为决赛。</p>
<p>2）比赛方式：分组比赛，每组6个人；选手每次要随机分组，进行比赛；</p>
<p>第一轮分为4个小组，每组6个人。比如100-105为一组，106-111为第二组，依次类推，</p>
<p>3)每人分别按照抽签（draw）顺序演讲。当小组演讲完后，淘汰组内排名最后的三个选手，然后继续下一个小组的比赛。</p>
<p> 第二轮分为2个小组，每组6人。比赛完毕，淘汰组内排名最后的三个选手，然后继续下一个小组的比赛。</p>
<p>第三轮只剩下6个人，本轮为决赛，选出前三名。</p>
<p>​    </p>
<p>4）比赛评分：10个评委打分，去除最低、最高分，求平均分</p>
<p>每个选手演讲完由10个评委分别打分。该选手的最终得分是去掉一个最高分和一个最低分，求得剩下的8个成绩的平均分。</p>
<p>选手的名次按得分降序排列，若得分一样，按参赛号升序排名。</p>
<p>用STL编程，求解这个问题</p>
<p>1） 请打印出所有选手的名字与参赛号，并以参赛号的升序排列。</p>
<p>2） 打印每一轮比赛后，小组比赛成绩和小组晋级名单</p>
<p>3） 打印决赛前三名，选手名称、成绩。</p>
<h3 id="4-3需求分析"><a href="#4-3需求分析" class="headerlink" title="4.3需求分析"></a><strong>4.3需求分析</strong></h3><p>​        //产生选手 （ ABCDEFGHIJKLMNOPQRSTUVWXYZ ） 姓名、得分；选手编号</p>
<p>​        //第1轮    选手抽签 选手比赛 查看比赛结果 </p>
<p>​        //第2轮    选手抽签 选手比赛 查看比赛结果</p>
<p>​        //第3轮    选手抽签 选手比赛 查看比赛结果</p>
<h3 id="4-4实现思路"><a href="#4-4实现思路" class="headerlink" title="**4.**4实现思路"></a>**4.**4实现思路</h3><p>​        需要把选手信息、选手得分信息、选手比赛抽签信息、选手的晋级信息保存在容器中，需要涉及到各个容器的选型。（相当于信息的数据库E-R图设计）</p>
<p>​        选手可以设计一个类Speaker（姓名和得分）</p>
<p>​        所有选手编号和选手信息，可以放在容器内：map&lt;int, Speaker&gt; </p>
<p>​        所有选手的编号信息，可以放在容器：vecter<int> v1中</p>
<p>​        第1轮晋级名单，可以放在容器vecter<int> v2中 </p>
<p>​        第2轮晋级名单，可以放在容器vecter<int> v3中</p>
<p>​        第3轮前三名名单，可以放在容器vecter<int> v4中</p>
<p>​    </p>
<p>​        每个小组的比赛得分信息，按照从小到大的顺序放在 </p>
<p>​        multimap&lt;成绩, 编号, greater<int>&gt; multmapGroup      </p>
<p>​        也就是：multimap&lt;int, int, greater<int> &gt; multmapGroup;    </p>
<p>​        每个选手的得分，可以放在容器deque<int> dscore; 方便去除最低最高分</p>
<h3 id="4-5实现细节"><a href="#4-5实现细节" class="headerlink" title="**4.**5实现细节"></a>**4.**5实现细节</h3><p>1） 搭建框架</p>
<p>2） 完善业务函数</p>
<p>random_shuffle</p>
<p>3） 测试</p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void main()
&#123;
	&#x2F;&#x2F;定义数据结构 所有选手放到容器中
	map&lt;int, Speaker&gt;	mapSpeaker;
	vector&lt;int&gt;			v1; &#x2F;&#x2F;第1轮演讲比赛 名单
	vector&lt;int&gt;			v2; &#x2F;&#x2F;第2轮演讲比赛 名单
	vector&lt;int&gt;			v3; &#x2F;&#x2F;第3轮演讲比赛 名单
	vector&lt;int&gt;			v4; &#x2F;&#x2F;最后 演讲比赛 名单

	&#x2F;&#x2F;产生选手
	GenSpeaker(mapSpeaker, v1);

	&#x2F;&#x2F;第1轮	选手抽签 选手比赛 查看比赛结果(晋级名单 得分情况)
	cout &lt;&lt; &quot;\n\n\n任意键,开始第一轮比赛&quot; &lt;&lt; endl;
	cin.get();
	speech_contest_draw(v1);
	speech_contest(0,  v1, mapSpeaker, v2);
	speech_contest_print(0, v2, mapSpeaker);

	&#x2F;&#x2F;第2轮 选手抽签 选手比赛 查看比赛结果
	cout &lt;&lt; &quot;\n\n\n任意键,开始第二轮比赛&quot; &lt;&lt; endl;
	cin.get();
	speech_contest_draw(v2);
	speech_contest(1,  v2, mapSpeaker, v3);
	speech_contest_print(1, v3, mapSpeaker);

	&#x2F;&#x2F;第3轮 选手抽签 选手比赛 查看比赛结果
	cout &lt;&lt; &quot;\n\n\n任意键,开始第三轮比赛&quot; &lt;&lt; endl;
	cin.get();
	speech_contest_draw(v3);
	speech_contest(2,  v3, mapSpeaker, v4);
	speech_contest_print(2, v4, mapSpeaker);

	system(&quot;pause&quot;);
&#125;

&#x2F;&#x2F;产生选手
int GenSpeaker(map&lt;int, Speaker&gt; &amp;mapSpeaker, vector&lt;int&gt; &amp;v1)

&#x2F;&#x2F;选手抽签
int speech_contest_draw(vector&lt;int&gt;	&amp;v)

&#x2F;&#x2F;选手比赛
int speech_contest(int index,  vector&lt;int&gt; &amp;v1, map&lt;int, Speaker&gt; &amp;mapSpeaker, vector&lt;int&gt; &amp;v2)

&#x2F;&#x2F;打印选手比赛晋级名单
int speech_contest_print(int index, vector&lt;int&gt; v, map&lt;int, Speaker&gt; &amp; mapSpeaker)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>


    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/c/" rel="tag"><i class="fa fa-tag"></i> c++</a>
              <a href="/tags/STL/" rel="tag"><i class="fa fa-tag"></i> STL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/07/03/C-%E5%9F%BA%E7%A1%80/" rel="prev" title="C++基础">
      <i class="fa fa-chevron-left"></i> C++基础
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/07/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E8%AE%B2%E4%B9%89/" rel="next" title="设计模式讲义">
      设计模式讲义 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-STL%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="nav-number">1.</span> <span class="nav-text">第一章 STL理论基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1%E6%9C%AC%E7%AB%A0%E5%AD%A6%E4%B9%A0%E9%87%8D%E7%82%B9"><span class="nav-number">1.1.</span> <span class="nav-text">1.1本章学习重点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-STL%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 STL基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-STL%E4%B8%89%E5%A4%A7%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 STL三大组件介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-1%E5%AE%B9%E5%99%A8%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.3.1容器概念介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-2%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.3.2.</span> <span class="nav-text">1.3.2迭代器介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-3%E7%AE%97%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="nav-number">1.3.3.</span> <span class="nav-text">1.3.3算法介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-4%E6%A1%88%E4%BE%8B"><span class="nav-number">1.3.4.</span> <span class="nav-text">1.3.4案例</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-4-1-%E6%A1%88%E4%BE%8B%E4%B8%80-STL%E5%85%A5%E9%97%A8hello-world"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">1.3.4.1 案例一: STL入门hello world</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-4-2-%E6%A1%88%E4%BE%8B%E4%BA%8C-%E5%AE%B9%E5%99%A8%E7%AE%97%E6%B3%95%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="nav-number">1.3.5.</span> <span class="nav-text">13.4.2 案例二: 容器算法迭代器实现基本原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-5%E6%80%BB%E7%BB%93"><span class="nav-number">1.3.6.</span> <span class="nav-text">1.3.5总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8"><span class="nav-number">2.</span> <span class="nav-text">第二章 常用容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%E6%9C%AC%E7%AB%A0%E5%AD%A6%E4%B9%A0%E9%87%8D%E7%82%B9"><span class="nav-number">2.1.</span> <span class="nav-text">2.1本章学习重点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-string%E5%AE%B9%E5%99%A8"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 string容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-string%E7%9A%84%E7%89%B9%E6%80%A7"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1 string的特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2-string-%E5%B8%B8%E7%94%A8API"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2.2 string 常用API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-2-1-string%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.2.2.1.</span> <span class="nav-text">2.2.2.1 string构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-2-2-string%E5%9F%BA%E6%9C%AC%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="nav-number">2.2.2.2.</span> <span class="nav-text">2.2.2.2 string基本赋值操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-2-3-string%E5%AD%98%E5%8F%96%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C"><span class="nav-number">2.2.2.3.</span> <span class="nav-text">2.2.2.3 string存取字符操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-2-4-string%E6%8B%BC%E6%8E%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">2.2.2.4.</span> <span class="nav-text">2.2.2.4 string拼接操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-2-5-string%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2"><span class="nav-number">2.2.2.5.</span> <span class="nav-text">2.2.2.5 string查找和替换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-2-6-string%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C"><span class="nav-number">2.2.2.6.</span> <span class="nav-text">2.2.2.6 string比较操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-2-7-string%E5%AD%90%E4%B8%B2"><span class="nav-number">2.2.2.7.</span> <span class="nav-text">2.2.2.7 string子串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-2-8-string%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-number">2.2.2.8.</span> <span class="nav-text">2.2.2.8 string插入和删除操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-3-string%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0"><span class="nav-number">2.2.3.</span> <span class="nav-text">2.2.3 string课后练习</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-vector%E5%AE%B9%E5%99%A8"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 vector容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-vector%E7%89%B9%E6%80%A7"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.3.1 vector特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-vector%E5%B8%B8%E7%94%A8API"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.3.2 vector常用API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-2-1-vector%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.2.1.</span> <span class="nav-text">2.3.2.1 vector构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-2-2-vector%E5%B8%B8%E7%94%A8%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="nav-number">2.3.2.2.</span> <span class="nav-text">2.3.2.2 vector常用赋值操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-2-3-vector%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C"><span class="nav-number">2.3.2.3.</span> <span class="nav-text">2.3.2.3 vector大小操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-2-4-vector%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96%E6%93%8D%E4%BD%9C"><span class="nav-number">2.3.2.4.</span> <span class="nav-text">2.3.2.4 vector数据存取操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-2-5-vector%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-number">2.3.2.5.</span> <span class="nav-text">2.3.2.5 vector插入和删除操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-deque%E5%AE%B9%E5%99%A8"><span class="nav-number">2.4.</span> <span class="nav-text">2.3 deque容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-deque%E7%89%B9%E6%80%A7"><span class="nav-number">2.4.1.</span> <span class="nav-text">2.3.1 deque特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-deque%E5%B8%B8%E7%94%A8API"><span class="nav-number">2.4.2.</span> <span class="nav-text">2.3.2 deque常用API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-2-1-deque%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.4.2.1.</span> <span class="nav-text">2.3.2.1 deque构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-2-2-deque%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="nav-number">2.4.2.2.</span> <span class="nav-text">2.3.2.2 deque赋值操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-2-3-deque%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C"><span class="nav-number">2.4.2.3.</span> <span class="nav-text">2.3.2.3 deque大小操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-2-3-deque%E5%8F%8C%E7%AB%AF%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-number">2.4.2.4.</span> <span class="nav-text">2.3.2.3 deque双端插入和删除操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-2-4-deque%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96"><span class="nav-number">2.4.2.5.</span> <span class="nav-text">2.3.2.4 deque数据存取</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-2-5-deque%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C"><span class="nav-number">2.4.2.6.</span> <span class="nav-text">2.3.2.5 deque插入操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-2-5-deque%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-number">2.4.2.7.</span> <span class="nav-text">2.3.2.5 deque删除操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-deque%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0"><span class="nav-number">2.4.3.</span> <span class="nav-text">2.3.3 deque课后练习</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-stack%E5%AE%B9%E5%99%A8"><span class="nav-number">2.5.</span> <span class="nav-text">2.4 stack容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-1-stack%E7%89%B9%E6%80%A7"><span class="nav-number">2.5.1.</span> <span class="nav-text">2.4.1 stack特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-2-stack%E5%B8%B8%E7%94%A8API"><span class="nav-number">2.5.2.</span> <span class="nav-text">2.4.2 stack常用API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-2-1-stack%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.5.2.1.</span> <span class="nav-text">2.4.2.1 stack构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-2-2-stack%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="nav-number">2.5.2.2.</span> <span class="nav-text">2.4.2.2 stack赋值操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-2-3-stack%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96%E6%93%8D%E4%BD%9C"><span class="nav-number">2.5.2.3.</span> <span class="nav-text">2.4.2.3 stack数据存取操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-2-3-stack%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C"><span class="nav-number">2.5.2.4.</span> <span class="nav-text">2.4.2.3 stack大小操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-queue%E5%AE%B9%E5%99%A8"><span class="nav-number">2.6.</span> <span class="nav-text">2.5 queue容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-1-queue%E7%89%B9%E6%80%A7"><span class="nav-number">2.6.1.</span> <span class="nav-text">2.5.1 queue特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-2-queue%E5%B8%B8%E7%94%A8API"><span class="nav-number">2.6.2.</span> <span class="nav-text">2.5.2 queue常用API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-2-1-queue%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.6.2.1.</span> <span class="nav-text">2.5.2.1 queue构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-2-2-queue%E5%AD%98%E5%8F%96%E3%80%81%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-number">2.6.2.2.</span> <span class="nav-text">2.5.2.2 queue存取、插入和删除操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-2-3-queue%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="nav-number">2.6.2.3.</span> <span class="nav-text">2.5.2.3 queue赋值操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-2-3-queue%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C"><span class="nav-number">2.6.2.4.</span> <span class="nav-text">2.5.2.3 queue大小操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-list%E5%AE%B9%E5%99%A8"><span class="nav-number">2.7.</span> <span class="nav-text">2.6 list容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-1-list%E7%89%B9%E6%80%A7"><span class="nav-number">2.7.1.</span> <span class="nav-text">2.6.1 list特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-2-list-%E5%B8%B8%E7%94%A8API"><span class="nav-number">2.7.2.</span> <span class="nav-text">2.6.2 list 常用API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-6-2-1-list%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.7.2.1.</span> <span class="nav-text">2.6.2.1 list构造函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-2-2-list%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-number">2.7.3.</span> <span class="nav-text">2.6.2.2 list数据元素插入和删除操作</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-6-2-3-list%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C"><span class="nav-number">2.7.3.1.</span> <span class="nav-text">2.6.2.3 list大小操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-6-2-4-list%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="nav-number">2.7.3.2.</span> <span class="nav-text">2.6.2.4 list赋值操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-6-2-5-list%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%8F%96"><span class="nav-number">2.7.3.3.</span> <span class="nav-text">2.6.2.5 list数据的存取</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-6-2-5-list%E5%8F%8D%E8%BD%AC%E6%8E%92%E5%88%97%E6%8E%92%E5%BA%8F"><span class="nav-number">2.7.3.4.</span> <span class="nav-text">2.6.2.5 list反转排列排序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-set-multiset%E5%AE%B9%E5%99%A8"><span class="nav-number">2.8.</span> <span class="nav-text">2.7 set&#x2F;multiset容器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-1-set-multis4et%E7%89%B9%E6%80%A7"><span class="nav-number">2.9.</span> <span class="nav-text">2.7.1 set&#x2F;multis4et特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-2set-%E5%B8%B8%E7%94%A8API"><span class="nav-number">2.9.1.</span> <span class="nav-text">2.7.2set 常用API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-7-2-1-set%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.9.1.1.</span> <span class="nav-text">2.7.2.1 set构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-7-2-2-set%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="nav-number">2.9.1.2.</span> <span class="nav-text">2.7.2.2 set赋值操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-7-2-2-set%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C"><span class="nav-number">2.9.1.3.</span> <span class="nav-text">2.7.2.2 set大小操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-7-2-2-set%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-number">2.9.1.4.</span> <span class="nav-text">2.7.2.2 set插入和删除操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-7-2-3-set%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C"><span class="nav-number">2.9.1.5.</span> <span class="nav-text">2.7.2.3 set查找操作</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-8-map-multimap%E5%AE%B9%E5%99%A8"><span class="nav-number">2.10.</span> <span class="nav-text">2.8 map&#x2F;multimap容器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-1-map-multimap%E7%89%B9%E6%80%A7"><span class="nav-number">2.10.1.</span> <span class="nav-text">2.8.1 map&#x2F;multimap特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-2-%E5%AF%B9%E7%BB%84"><span class="nav-number">2.10.2.</span> <span class="nav-text">2.8.2 对组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-3-map%E5%B8%B8%E7%94%A8API"><span class="nav-number">2.10.3.</span> <span class="nav-text">2.8.3 map常用API</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-8-3-1-map%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">2.10.3.1.</span> <span class="nav-text">2.8.3.1 map构造函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-8-3-2-map%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C"><span class="nav-number">2.10.3.2.</span> <span class="nav-text">2.8.3.2 map赋值操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-8-3-3-map%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C"><span class="nav-number">2.10.3.3.</span> <span class="nav-text">2.8.3.3 map大小操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-8-3-4-map%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E6%93%8D%E4%BD%9C"><span class="nav-number">2.10.3.4.</span> <span class="nav-text">2.8.3.4 map插入数据元素操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-8-3-5-map%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C"><span class="nav-number">2.10.3.5.</span> <span class="nav-text">2.8.3.5 map删除操作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-8-3-5-map%E6%9F%A5%E6%89%BE%E6%93%8D%E4%BD%9C"><span class="nav-number">2.10.3.6.</span> <span class="nav-text">2.8.3.5 map查找操作</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-4-multimap%E6%A1%88%E4%BE%8B%E6%93%8D%E7%BB%83"><span class="nav-number">2.10.4.</span> <span class="nav-text">2.8.4 multimap案例操练</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-9-STL%E5%AE%B9%E5%99%A8%E5%85%B1%E6%80%A7%E6%9C%BA%E5%88%B6"><span class="nav-number">2.11.</span> <span class="nav-text">2.9 STL容器共性机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-10-STL%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="nav-number">2.12.</span> <span class="nav-text">2.10 STL容器使用时机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="nav-number">3.</span> <span class="nav-text">第三章 常用算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 函数对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.1.1 函数对象的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-%E8%B0%93%E8%AF%8D%E6%A6%82%E5%BF%B5"><span class="nav-number">3.1.2.</span> <span class="nav-text">3.1.2 谓词概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-%E5%86%85%E5%BB%BA%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.1.3.</span> <span class="nav-text">3.1.3 内建函数对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-4-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8"><span class="nav-number">3.1.4.</span> <span class="nav-text">3.1.4 函数对象适配器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 算法概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E5%B8%B8%E7%94%A8%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 常用遍历算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-for-each%E7%BB%83%E4%B9%A0%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.3.1 for_each练习代码：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-transform%E7%BB%83%E4%B9%A0%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.3.2 transform练习代码：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 常用查找算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-find%E7%AE%97%E6%B3%95%E6%A1%88%E4%BE%8B"><span class="nav-number">3.5.</span> <span class="nav-text">3.4.1 find算法案例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="nav-number">3.6.</span> <span class="nav-text">3.5 常用排序算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link"><span class="nav-number">4.</span> <span class="nav-text"></span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-%E5%B8%B8%E7%94%A8%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="nav-number">4.1.</span> <span class="nav-text">3.6 常用拷贝和替换算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-%E5%B8%B8%E7%94%A8%E7%AE%97%E6%95%B0%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95"><span class="nav-number">4.2.</span> <span class="nav-text">3.7 常用算数生成算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-8-%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%95"><span class="nav-number">5.</span> <span class="nav-text">3.8 常用集合算法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-STL%E7%BB%BC%E5%90%88%E6%A1%88%E4%BE%8B"><span class="nav-number">6.</span> <span class="nav-text">第四章 STL综合案例</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1%E6%A1%88%E4%BE%8B%E5%AD%A6%E6%A0%A1%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B"><span class="nav-number">6.1.</span> <span class="nav-text">4.1案例学校演讲比赛</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2%E5%AD%A6%E6%A0%A1%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E4%BB%8B%E7%BB%8D"><span class="nav-number">6.2.</span> <span class="nav-text">4.2学校演讲比赛介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="nav-number">6.3.</span> <span class="nav-text">4.3需求分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF"><span class="nav-number">6.4.</span> <span class="nav-text">**4.**4实现思路</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="nav-number">6.5.</span> <span class="nav-text">**4.**5实现细节</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="OrangeW"
      src="/images/orange.png">
  <p class="site-author-name" itemprop="name">OrangeW</p>
  <div class="site-description" itemprop="description">demo_study record</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>


<!-- CloudCalendar -->
<div class="widget-wrap" style="width: 90%;margin-left: auto;margin-right: auto; opacity: 0.97;">
	<div class="widget" id="CloudCalendar"></div>
</div>
      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">OrangeW</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">533k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">16:09</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
<!-- calendar widget -->

    <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-calendar/calendar.min.js"></script>
    <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-calendar/languages.min.js"></script>
    <script>
    $(function() {
        $('#CloudCalendar').aCalendar('zh-CN',
            $.extend(
                '', {
                    single:true,
                    root:'/calendar/'
                }
            )
        );
    });
    </script>


</body>
</html>
